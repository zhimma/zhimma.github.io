<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Consul初体验</title>
      <link href="/2020/03/20/Consul%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/03/20/Consul%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d xhyve nginx</span><br><span class="line">docker-machine create -d xhyve consul</span><br><span class="line">docker-machine create -d xhyve work1</span><br><span class="line">docker-machine create -d xhyve work2</span><br><span class="line">docker-machine ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-machine ls</span><br><span class="line">NAME     ACTIVE   DRIVER    STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class="line">consul   -        xhyve     Running   tcp://192.168.64.15:2376            v19.03.5</span><br><span class="line">nginx    -        xhyve     Running   tcp://192.168.64.14:2376            v19.03.5</span><br><span class="line">work1    -        xhyve     Running   tcp://192.168.64.16:2376            v19.03.5</span><br><span class="line">work2    -        xhyve     Running   tcp://192.168.64.17:2376            v19.03.5</span><br></pre></td></tr></table></figure><h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><h4 id="进入consul机器"><a href="#进入consul机器" class="headerlink" title="进入consul机器"></a>进入consul机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh consul</span><br></pre></td></tr></table></figure><h4 id="运行consul节点容器"><a href="#运行consul节点容器" class="headerlink" title="运行consul节点容器"></a>运行consul节点容器</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -d \</span><br><span class="line">    -v /data:/data \</span><br><span class="line">    -p 8500:8500 \</span><br><span class="line">    -p 8600:8600/udp \</span><br><span class="line">    --name=consul \</span><br><span class="line">    consul agent -server -ui -node=server1 -bootstrap-expect=1 -client=0.0.0.0</span><br></pre></td></tr></table></figure><h4 id="查看容器启动情况"><a href="#查看容器启动情况" class="headerlink" title="查看容器启动情况"></a>查看容器启动情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@consul:/home/docker# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                    NAMES</span><br><span class="line">2d9d0cdd3f13        consul              &quot;docker-entrypoint.s…&quot;   3 minutes ago       Up 3 minutes        8300-8302/tcp, 8600/tcp, 8301-8302/udp, 0.0.0.0:8500-&gt;8500/tcp, 0.0.0.0:8600-&gt;8600/udp   consul</span><br></pre></td></tr></table></figure><h4 id="访问web页面"><a href="#访问web页面" class="headerlink" title="访问web页面"></a>访问web页面</h4><p><a href="http://192.168.64.15:8500/ui/dc1/services" target="_blank" rel="noopener">http://192.168.64.15:8500/ui/dc1/services</a></p><p><img src="/Users/zhimma/Library/Application Support/typora-user-images/image-20200203183743444.png" alt="image-20200203183743444"></p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><h4 id="进入nginx节点机器"><a href="#进入nginx节点机器" class="headerlink" title="进入nginx节点机器"></a>进入nginx节点机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh nginx</span><br></pre></td></tr></table></figure><h4 id="consul-template配置"><a href="#consul-template配置" class="headerlink" title="consul-template配置"></a>consul-template配置</h4><h5 id="安装consul-template"><a href="#安装consul-template" class="headerlink" title="安装consul-template"></a>安装consul-template</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/consul-template/0.24.1/consul-template_0.24.1_linux_amd64.tgz </span><br><span class="line"></span><br><span class="line">tar -zxf consul-template_0.24.1_linux_amd64.tgz</span><br><span class="line"></span><br><span class="line">mv consul-template /usr/bin/</span><br></pre></td></tr></table></figure><h5 id="创建nginx-ctmpl模板"><a href="#创建nginx-ctmpl模板" class="headerlink" title="创建nginx.ctmpl模板"></a>创建nginx.ctmpl模板</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">mkdir /data/nginx</span><br><span class="line"></span><br><span class="line">vi /data/nginx/nginx.ctmpl</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> http_backend &#123;</span><br><span class="line">    &#123;&#123;range service "nginx"&#125;&#125;</span><br><span class="line">    server &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8000</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://http_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动consul-template服务"><a href="#启动consul-template服务" class="headerlink" title="启动consul-template服务"></a>启动consul-template服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template --consul-addr 192.168.64.15:8500 --template &quot;./nginx.ctmpl:vhost.conf:docker exec nginx nginx -s reload&quot; --log-level=info</span><br></pre></td></tr></table></figure><blockquote><p>–consul-addr：指定consul服务的ip和端口；<br>./nginx.ctmpl：这是用nginx.ctmpl这个模板来启动进程，这是写的相对路径，也可以写绝对路径；<br>vhost.conf：nginx.ctmpl模板生成后的文件名，这也可以写绝对路径，如果不写绝对路径，这个文件就在当前目录生成（/usr/local/nginx/consul/）</p></blockquote><h5 id="验证consul-template服务状态"><a href="#验证consul-template服务状态" class="headerlink" title="验证consul-template服务状态"></a>验证consul-template服务状态</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep consul-template</span><br></pre></td></tr></table></figure><p><img src="/Users/zhimma/Library/Application Support/typora-user-images/image-20200203185856803.png" alt="image-20200203185856803"></p><p>我们看到在本目录下生成了vhost.conf</p><p><img src="/Users/zhimma/Library/Application Support/typora-user-images/image-20200203190041025.png" alt="image-20200203190041025"></p><blockquote><p>由于我们是容器启动的nginx，所以需要挂载当前目录将这个加载在容器里面的nginx配置里面运行</p></blockquote><h4 id="运行nginx容器"><a href="#运行nginx容器" class="headerlink" title="运行nginx容器"></a>运行nginx容器</h4><h5 id="创建nginx-conf和conf-d目录"><a href="#创建nginx-conf和conf-d目录" class="headerlink" title="创建nginx.conf和conf.d目录"></a>创建nginx.conf和conf.d目录</h5><blockquote><ol><li>先运行一个nginx容器，随便挂载一个目录，拷贝出来nginx官方镜像生成的容器里面的conf.d目录和nginx.conf</li><li>再删除这个容器，重新运行并且挂载nginx.conf和conf.d目录到新容器</li><li>重新运行consul-template 并且重新指定vhost.conf的生成目录</li></ol></blockquote><p><strong>运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=nginx_tmp -v /zhimma:/zhimma -d nginx</span><br></pre></td></tr></table></figure><p><strong>进入容器并拷贝目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/data/nginx<span class="comment"># docker exec -it nginx_tmp bash</span></span><br><span class="line">root@49762af8ada3:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  devetc  home  liblib64  media  mnt  optproc  root  run  sbin  srv  sys  tmp  usr  varzhimma</span><br><span class="line"></span><br><span class="line">root@49762af8ada3:/<span class="comment"># cd /etc/nginx/</span></span><br><span class="line">root@49762af8ada3:/etc/nginx<span class="comment"># cp -r conf.d/ nginx.conf  /zhimma/</span></span><br><span class="line">root@49762af8ada3:/etc/nginx<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f nginx_tmp</span><br></pre></td></tr></table></figure><p><strong>放置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/data/nginx<span class="comment"># pwd</span></span><br><span class="line">/data/nginx</span><br><span class="line">root@nginx:/data/nginx<span class="comment"># ls</span></span><br><span class="line">nginx.ctmpl  vhost.conf</span><br><span class="line"></span><br><span class="line">root@nginx:/data/nginx<span class="comment"># mv /zhimma/conf.d/ /zhimma/nginx.conf ./</span></span><br><span class="line">root@nginx:/data/nginx<span class="comment"># ls</span></span><br><span class="line">conf.d       nginx.conf   nginx.ctmpl  vhost.conf</span><br></pre></td></tr></table></figure><h5 id="运行新容器"><a href="#运行新容器" class="headerlink" title="运行新容器"></a>运行新容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=nginx -p 8000:8000 -p 80:80 -v /data/nginx/nginx.conf:/etc/nginx/nginx.conf -v /data/nginx/conf.d:/etc/nginx/conf.d -d nginx</span><br></pre></td></tr></table></figure><blockquote><p>此步完成后可以去容器里面看看挂载是否成功</p></blockquote><h5 id="重新运行consul-template"><a href="#重新运行consul-template" class="headerlink" title="重新运行consul-template"></a>重新运行consul-template</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template --consul-addr 192.168.64.15:8500 --template <span class="string">"./nginx.ctmpl:./conf.d/vhost.conf:docker exec nginx nginx -s reload"</span> --<span class="built_in">log</span>-level=info</span><br></pre></td></tr></table></figure><blockquote><p>此步完成后可以去容器里面看看挂载是否成功</p><p><code>-template</code>参数来指定模板的解析，规则是：冒号第一段是模板文件路径，第二段是生成的配置文件路径，第三段是额外指令（<strong>这里特别重要：如果我们没有nginx -s reload这个，配置更新之后，无法自动生效。这个代表每次配置改变之后，都会自动执行此指令，用来reload nginx的配置，以便自动生效</strong>）</p></blockquote><h3 id="work1"><a href="#work1" class="headerlink" title="work1"></a>work1</h3><h4 id="进入work1机器"><a href="#进入work1机器" class="headerlink" title="进入work1机器"></a>进入work1机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh work1</span><br></pre></td></tr></table></figure><h4 id="创建registrator容器"><a href="#创建registrator容器" class="headerlink" title="创建registrator容器"></a>创建registrator容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name registrator --network=host -v /var/run/docker.sock:/tmp/docker.sock --restart=always gliderlabs/registrator:latest --ip 192.168.64.16 consul://192.168.64.15:8500</span><br></pre></td></tr></table></figure><h5 id="创建nginx容器并修改index-html内容"><a href="#创建nginx容器并修改index-html内容" class="headerlink" title="创建nginx容器并修改index.html内容"></a>创建nginx容器并修改index.html内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name work_81  -p 81:80 -v /data/www/81/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"work1_81"</span> &gt;&gt; /data/www/81/index.html</span><br><span class="line"></span><br><span class="line">docker run -itd --name work_82  -p 82:80 -v /data/www/82/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"work1_82"</span> &gt;&gt; /data/www/82/index.html</span><br></pre></td></tr></table></figure><h3 id="Work2"><a href="#Work2" class="headerlink" title="Work2"></a>Work2</h3><h4 id="进入work2机器"><a href="#进入work2机器" class="headerlink" title="进入work2机器"></a>进入work2机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh work2</span><br></pre></td></tr></table></figure><h4 id="创建registrator容器-1"><a href="#创建registrator容器-1" class="headerlink" title="创建registrator容器"></a>创建registrator容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name registrator --network=host -v /var/run/docker.sock:/tmp/docker.sock --restart=always gliderlabs/registrator:latest --ip 192.168.64.17 consul://192.168.64.15:8500</span><br></pre></td></tr></table></figure><h5 id="创建nginx容器并修改index-html内容-1"><a href="#创建nginx容器并修改index-html内容-1" class="headerlink" title="创建nginx容器并修改index.html内容"></a>创建nginx容器并修改index.html内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name work_83  -p 83:80 -v /data/www/83/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"work2_83"</span> &gt;&gt; /data/www/83/index.html</span><br><span class="line"></span><br><span class="line">docker run -itd --name work_84  -p 84:80 -v /data/www/84/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"work2_84"</span> &gt;&gt; /data/www/84/index.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Consul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq名称解释</title>
      <link href="/2020/03/17/Rabbitmq%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A/"/>
      <url>/2020/03/17/Rabbitmq%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="1、基础模块"><a href="#1、基础模块" class="headerlink" title="1、基础模块"></a>1、基础模块</h2><p>要熟练使用Rabbitmq就必须知道其名词含义和工作机制</p><blockquote><p>基本流程</p></blockquote><p>基本的工作流程是这样的：生产者，就是你的发送程序，通过TCP连接，创建channel(通道)向指定的exchange(交换机)发送一个消息，exchange再将消息下发到binding(绑定)的queue(队列)中，然后消费者(处理程序)监听接收queue中的消息进行处理。</p><p>这是google的一张流程图</p><p><a href="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><blockquote><p>生产者，消费者</p></blockquote><p>即发送消息和接收处理消息的逻辑程序</p><blockquote><p>Channel</p></blockquote><p>通道，rabbitmq的本质是tcp通信，利用tcp连接创建内部的逻辑连接，注意，此通道不是tcp本身通道(tcp一个连接就是一个通道)，而是共享一个tcp连接的其内部实现的连接，至于rabbitmq内部如何实现的我也没吃透，应该是用到了多路复用，总之rabbitmq一切收发都是通过channel实现的，避免了重复连接tcp产生的资源消耗。</p><blockquote><p>Exchange</p></blockquote><p>交换机，相当于是一个消息中转控制中心，负责接收消息然后根据路由规则将消息下发到指定的queue。</p><blockquote><p>Queue</p></blockquote><p>队列，即存放消息的地方，消费的时候直接从队列里取。</p><h2 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h2><blockquote><p>Routing Key</p></blockquote><p>路由键，是exchange跟queue之间的桥梁，exchange根据绑定的routing key下发消息到对应的queue中，决定了消息的流向，键名可以自定义。</p><blockquote><p>Type</p></blockquote><p>exchange的类型，有’fanout’、’direct’、’topic’、’headers’四个类型。</p><ul><li><strong>fanout</strong>：不需要指定路由键，直接将消息发送给exchange中的所有queue，类似于广播。</li><li><strong>direct</strong>：将消息发给exchange中指定路由键的queue中，相当于精准投放。</li><li><strong>topic</strong>：匹配模式，消息下发到匹配规则的routing key的queue中，有’<em>‘与’#’两个通配符，’</em>‘表示只匹配一个词，’#’表示匹配多个，比如’user.*‘只能匹配到’user.name’而不能匹配到’user.name.wang’，’user.#’则都可以匹配到。</li><li><strong>headers</strong>：根据消息体的headers匹配，这种用到的比较少，绑定的时候指定相关header参数即可。</li></ul><blockquote><p>Durable</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，表示是否持久化。</p><blockquote><p>Auto delete</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，我试了一下，当exchange绑定的queue全都解绑的时候exchange会自动删除，queue好像没什么影响。</p><blockquote><p>Internal</p></blockquote><p>exchange有这个参数，类型为boolean，内部的，意味着不能对这个exchange发送消息，通过管理后台还是可以发送消息的。</p><blockquote><p>noWait</p></blockquote><p>几乎每个步骤都有这个参数，类型为boolean，不需要服务器任何返回值的意思，指服务端创建队列发送消息等，rabbitmq不需要这个返回状态即可进行下一步，正常来说不会用到这个参数，容易报异常。</p><blockquote><p>Exclusive</p></blockquote><p>queue有这个参数，类型为boolean，排他队列，只对创建该队列的用户可见，其它用户无法访问。</p><blockquote><p>延伸扩展</p></blockquote><p>rabbitmq还提供了很多扩展参数，比如’x-message-ttl’给消息设置过时时间，’x-max-length-bytes’设置消息最大长度，’x-dead-letter-exchange’设置消息过时后推送到的exchange等等，具体的官方文档也提供了，也可以看管理后台创建exchange、queue的时候会有提示的额外参数。</p><p><a href="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>引用这里：<a href="https://shuangdeyu.gitee.io/2019/04/16/基于Go的Rabbitmq实践/" target="_blank" rel="noopener">https://shuangdeyu.gitee.io/2019/04/16/%E5%9F%BA%E4%BA%8EGo%E7%9A%84Rabbitmq%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目LNMP环境搭建</title>
      <link href="/2019/12/02/%E9%A1%B9%E7%9B%AELNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/12/02/%E9%A1%B9%E7%9B%AELNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p><a href="https://www.daehub.com/archives/2254.html" target="_blank" rel="noopener">https://www.daehub.com/archives/2254.html</a></p><ol><li>为了能够安装PHP7，需要安装<strong>EPEL</strong>和<strong>Remi</strong>的软件源，执行如下命令安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure><ol><li>现在需要安装<strong>yum-utils</strong>工具，这个一个yum工具的增强工具，可以更加方便的管理yum软件源：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-utils</span><br></pre></td></tr></table></figure><ol><li>yum-utils的提供了一个yum-config-manager程序，它可以将<strong>Remi</strong>软件包作为默认源来安装PHP7：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php70   [安装 PHP 7.0]</span><br></pre></td></tr></table></figure><p>如果想在CentOS 7系统中安装PHP 7.1或PHP 7.2，则使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php71   [安装 PHP 7.1]</span><br><span class="line">yum-config-manager --enable remi-php72   [安装 PHP 7.2]</span><br></pre></td></tr></table></figure><ol><li>最后，使用如下命令将PHP及常的扩展安装至系统：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php php-mcrypt php-cli php-gd php-curl php-mysql php-ldap php-zip php-fileinfo php-devel php-mbstring php-simplexml php-dom php-common php-fpm</span><br></pre></td></tr></table></figure><p>最后，可以使用php -v命令来检查PHP是否正确的安装至CentOS 7系统中。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7" target="_blank" rel="noopener">https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7</a></p><h4 id="添加-yum-源"><a href="#添加-yum-源" class="headerlink" title="添加 yum 源"></a>添加 yum 源</h4><p>Nginx 不在默认的 yum 源中，可以使用 epel 或者官网的 yum 源，本例使用官网的 yum 源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装完 yum 源之后，可以查看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">repo id                          repo name                          status</span><br><span class="line">base/7/x86_64                    CentOS-7 - Base                    9,911</span><br><span class="line">extras/7/x86_64                  CentOS-7 - Extras                    368</span><br><span class="line">nginx/x86_64                     nginx repo                           108</span><br><span class="line">updates/7/x86_64                 CentOS-7 - Updates                 1,041</span><br><span class="line">repolist: 11,428</span><br></pre></td></tr></table></figure><p>可以发现 <code>nginx repo</code> 已经安装到本机了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>yum 安装 Nginx，非常简单，一条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install nginx</span><br></pre></td></tr></table></figure><h4 id="配置-Nginx-服务"><a href="#配置-Nginx-服务" class="headerlink" title="配置 Nginx 服务"></a>配置 Nginx 服务</h4><h5 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="https://juejin.im/post/5c088b066fb9a049d4419985" target="_blank" rel="noopener">https://juejin.im/post/5c088b066fb9a049d4419985</a></p><h4 id="添加Mysql5-7仓库"><a href="#添加Mysql5-7仓库" class="headerlink" title="添加Mysql5.7仓库"></a>添加Mysql5.7仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="确认Mysql仓库成功添加"><a href="#确认Mysql仓库成功添加" class="headerlink" title="确认Mysql仓库成功添加"></a>确认Mysql仓库成功添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist all | grep mysql | grep enabled</span><br></pre></td></tr></table></figure><p>如果展示像下面,则表示成功添加仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql-connectors-community/x86_64  MySQL Connectors Community    enabled:     51</span><br><span class="line">mysql-tools-community/x86_64       MySQL Tools Community         enabled:     63</span><br><span class="line">mysql57-community/x86_64           MySQL 5.7 Community Server    enabled:    267</span><br></pre></td></tr></table></figure><h4 id="开始安装Mysql5-7"><a href="#开始安装Mysql5-7" class="headerlink" title="开始安装Mysql5.7"></a>开始安装Mysql5.7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><h4 id="启动Mysql"><a href="#启动Mysql" class="headerlink" title="启动Mysql"></a>启动Mysql</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure><h5 id="设置系统启动时自动启动"><a href="#设置系统启动时自动启动" class="headerlink" title="设置系统启动时自动启动"></a>设置系统启动时自动启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mysqld</span><br></pre></td></tr></table></figure><h5 id="查看启动状态"><a href="#查看启动状态" class="headerlink" title="查看启动状态"></a>查看启动状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure><h5 id="Mysql的安全设置"><a href="#Mysql的安全设置" class="headerlink" title="Mysql的安全设置"></a>Mysql的安全设置</h5><p>CentOS上的root默认密码可以在文件/var/log/mysqld.log找到，通过下面命令可以打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep -i &apos;temporary password&apos;</span><br></pre></td></tr></table></figure><p>执行下面命令进行安全设置，这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation     (Prod@Mysql@Passw0rd)</span><br></pre></td></tr></table></figure><h5 id="设置数据库编码为utf8"><a href="#设置数据库编码为utf8" class="headerlink" title="设置数据库编码为utf8"></a>设置数据库编码为utf8</h5><ol><li>打开配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/my.cnf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>在[mysqld]，[client]，[mysql]节点下添加编码设置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">collation-server = utf8_unicode_ci</span><br><span class="line">init-connect=&apos;SET NAMES utf8&apos;</span><br><span class="line">character-set-server = utf8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>重启Mysql即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/</a></p><h4 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h4><ol><li><p>Add the EPEL repository, and update YUM to confirm your change:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li><li><p>Install Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install redis</span><br></pre></td></tr></table></figure></li><li><p>Start Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis</span><br></pre></td></tr></table></figure><p><strong>Optional</strong>: To automatically start Redis on boot:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable redis</span><br></pre></td></tr></table></figure></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>Verify that Redis is running with <code>redis-cli</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>If Redis is running, it will return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv composer.phar  /usr/local/bin/composer</span><br></pre></td></tr></table></figure><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer -V</span><br><span class="line">Composer version 1.9.1 2019-11-01 17:20:17</span><br></pre></td></tr></table></figure><h4 id="设置镜像地址"><a href="#设置镜像地址" class="headerlink" title="设置镜像地址"></a>设置镜像地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目压测及调优</title>
      <link href="/2019/12/02/%E9%A1%B9%E7%9B%AE%E5%8E%8B%E6%B5%8B%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
      <url>/2019/12/02/%E9%A1%B9%E7%9B%AE%E5%8E%8B%E6%B5%8B%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="性能概念TPS、QPS、RPS"><a href="#性能概念TPS、QPS、RPS" class="headerlink" title="性能概念TPS、QPS、RPS"></a>性能概念TPS、QPS、RPS</h2><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p>TPS：Transactions Per Second（每秒事务处理数），指服务器每秒处理的事务次数。一般用于评估数据库、交易系统的基准性能。</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>QPS：Queries Per Second（查询量/秒），是服务器每秒能够处理的查询次数，例如域名服务器、Mysql查询性能。</p><h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS：Request Per Second（请求数/秒）RPS（Request Per Second）和QPS可以认为是一回事。RT：Response Time（响应时间）：客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。也叫Think Time。</p><h3 id="并发数与TPS-QPS的关系"><a href="#并发数与TPS-QPS的关系" class="headerlink" title="并发数与TPS/QPS的关系"></a>并发数与TPS/QPS的关系</h3><p>QPS（TPS）= 并发数/平均响应时间这里的并发数如果为事务处理请求数，则为TPS，如果为查询请求数，则为QPS。</p><h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><p><a href="https://blog.csdn.net/u011636440/article/details/78611838" target="_blank" rel="noopener">https://blog.csdn.net/u011636440/article/details/78611838</a></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>查看当前操作系统发行版信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]#  cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    8</span><br><span class="line">座：                 1</span><br><span class="line">NUMA 节点：         1</span><br><span class="line">厂商 ID：           GenuineIntel</span><br><span class="line">CPU 系列：          6</span><br><span class="line">型号：              79</span><br><span class="line">型号名称：        Intel(R) Xeon(R) CPU E5-26xx v4</span><br><span class="line">步进：              1</span><br><span class="line">CPU MHz：             2394.446</span><br><span class="line">BogoMIPS：            4788.89</span><br><span class="line">超管理器厂商：  KVM</span><br><span class="line">虚拟化类型：     完全</span><br><span class="line">L1d 缓存：          32K</span><br><span class="line">L1i 缓存：          32K</span><br><span class="line">L2 缓存：           4096K</span><br><span class="line">NUMA 节点0 CPU：    0-7</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch bmi1 avx2 bmi2 rdseed adx xsaveopt</span><br></pre></td></tr></table></figure><h4 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line">cpu cores: 8</span><br></pre></td></tr></table></figure><h4 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="查看概要内存使用情况"><a href="#查看概要内存使用情况" class="headerlink" title="查看概要内存使用情况"></a>查看概要内存使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# free -g</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:             15           1           9           0           4          13</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><blockquote><p>-g是以GB为单位；也可以使用-m，即以MB为单位</p></blockquote><h2 id="压测和优化"><a href="#压测和优化" class="headerlink" title="压测和优化"></a>压测和优化</h2><h3 id="未优化压测"><a href="#未优化压测" class="headerlink" title="未优化压测"></a>未优化压测</h3><h4 id="压测结果预览"><a href="#压测结果预览" class="headerlink" title="压测结果预览"></a>压测结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/php-fpm%E6%9C%AA%E4%BC%98%E5%8C%96.gif" alt=""></p><h4 id="PHP-FPM配置"><a href="#PHP-FPM配置" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96php-fpm%E9%85%8D%E7%BD%AE.png" alt=""></p><h4 id="wrk压测结果"><a href="#wrk压测结果" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png" alt=""></p><h4 id="Nginx报错"><a href="#Nginx报错" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png" alt=""></p><h3 id="优化PHP-FPM"><a href="#优化PHP-FPM" class="headerlink" title="优化PHP-FPM"></a>优化PHP-FPM</h3><h4 id="PHP-FPM优化-示例：这是另一台服务器"><a href="#PHP-FPM优化-示例：这是另一台服务器" class="headerlink" title="PHP-FPM优化(示例：这是另一台服务器)"></a>PHP-FPM优化(示例：这是另一台服务器)</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/psaux.png" alt=""></p><p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><p> 格式说明：</p><p>USER: 行程拥有者</p><p>PID: pid</p><p>%CPU: 占用的 CPU 使用率</p><p>%MEM: 占用的记忆体使用率</p><p>VSZ: 占用的虚拟记忆体大小</p><p>RSS: 占用的记忆体大小</p><p>TTY: 终端的次要装置号码 (minor device number of tty)</p><p>STAT: 该行程的状态，linux的进程有5种状态：</p><p>​    D 不可中断 uninterruptible sleep (usually IO)</p><p>​    R 运行 runnable (on run queue)</p><p>​    S 中断 sleeping</p><p>​    T 停止 traced or stopped</p><p>​    Z 僵死 a defunct (”zombie”) process</p><p>注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p><p>START: 行程开始时间</p><p>TIME: 执行的时间</p><p>COMMAND:所执行的指令</p><h4 id="查看进程的消息"><a href="#查看进程的消息" class="headerlink" title="查看进程的消息"></a>查看进程的消息</h4><p><code>ps auxf | grep php | grep -v grep</code></p><blockquote><p>grep -v grep 过滤当前命令grep</p></blockquote><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/ps.png" alt="image-20191016153558487"></p><h4 id="占用的内存数量"><a href="#占用的内存数量" class="headerlink" title="占用的内存数量"></a><code>占用的内存数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | awk &apos;&#123;sum+=$6&#125; END &#123;print sum&#125;&apos;</span><br><span class="line"></span><br><span class="line">18207120</span><br></pre></td></tr></table></figure><h4 id="查看进程数量"><a href="#查看进程数量" class="headerlink" title="查看进程数量"></a><code>查看进程数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | wc -l</span><br><span class="line"></span><br><span class="line">800</span><br></pre></td></tr></table></figure><p>可以看到第6列，每一个子进程的内存占用大概在22M之间（单位为KB）。平均的内存占用为<code>18207120KB/800/1024 = 22.2M</code>。</p><h5 id="进程数限制"><a href="#进程数限制" class="headerlink" title="进程数限制"></a>进程数限制</h5><p>此时如果我们分配全部的内存给<code>PHP-FPM</code>使用，那么进程数可以限制在`16*1000/22 = 744,但是由于我们的服务器同时服务了很多内容，所以我们可以向下调整到256个进程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.max = 700</span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = 700</span><br><span class="line">pm.start_servers = 450</span><br><span class="line">pm.min_spare_servers = 200</span><br><span class="line">pm.max_spare_servers = 700</span><br></pre></td></tr></table></figure><h5 id="max-children"><a href="#max-children" class="headerlink" title="max_children"></a>max_children</h5><ul><li><strong>这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。</strong></li><li>设置”max_children”也需要根据服务器的性能进行设定</li><li>一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右</li><li>假设“max_children”设置成100个，20M*100=2000M</li><li>也就是说在峰值的时候所有PHP-CGI所耗内存在2000M以内。</li><li>假设“max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。</li><li>如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。</li></ul><h5 id="start-servers"><a href="#start-servers" class="headerlink" title="start_servers"></a>start_servers</h5><ul><li>pm.start_servers的默认值为2。并且php-fpm中给的计算方式也为：<br>{（cpu空闲时等待连接的php的最小子进程数） + （cpu空闲时等待连接的php的最大子进程数 - cpu空闲时等待连接的php的最小子进程数）/ 2}；</li><li>用配置表示就是：min_spare_servers + (max_spare_servers - min_spare_servers) / 2；</li><li>一般而言，设置成10-20之间的数据足够满足需求了。</li></ul><h5 id="max-requests（最大请求数）"><a href="#max-requests（最大请求数）" class="headerlink" title="max_requests（最大请求数）"></a>max_requests（最大请求数）</h5><blockquote><p>最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn一个新的。<br>这个配置的主要目的是避免php解释器或程序引用的第三方库造成的内存泄露。<br>pm.max_requests = 10240</p></blockquote><ul><li>当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，自动重启该进程。</li><li>502，是后端 PHP-FPM 不可用造成的，间歇性的502一般认为是由于 PHP-FPM 进程重启造成的.</li><li>但是为什么要重启进程呢？</li><li>如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长（比如第三方库有问题等）。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长。</li><li>正是因为这个机制，在高并发中，经常导致 502 错误</li><li>目前我们解决方案是把这个值尽量设置大些，减少 PHP-CGI 重新 SPAWN 的次数，同时也能提高总体性能。PS：刚开始我们是500导致内存飙高，现在改成5120，当然可以再大一些，10240等，这个主要看测试结果，如果没有内存泄漏等问题，可以再大一些。</li></ul><h5 id="request-terminate-timeout（最长执行时间）"><a href="#request-terminate-timeout（最长执行时间）" class="headerlink" title="request_terminate_timeout（最长执行时间）"></a>request_terminate_timeout（最长执行时间）</h5><p><strong>max_execution_time</strong>和<strong>request_terminate_timeout</strong></p><blockquote><p>; The timeout for serving a single request after which the worker process will<br>; be killed. This option should be used when the ‘max_execution_time’ ini option<br>; does not stop script execution for some reason. A value of ‘0’ means ‘off’.<br>; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)<br>; Default Value: 0<br>;request_terminate_timeout = 0<br>＝＝＝＝＝＝＝＝＝＝＝＝<br>设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。</p></blockquote><ul><li>这两项都是用来配置一个PHP脚本的最大执行时间的。当超过这个时间时，PHP-FPM不只会终止脚本的执行，还会终止执行脚本的Worker进程。</li><li>Nginx会发现与自己通信的连接断掉了，就会返回给客户端502错误。</li></ul><h3 id="优化PHP-FPM压测"><a href="#优化PHP-FPM压测" class="headerlink" title="优化PHP-FPM压测"></a>优化PHP-FPM压测</h3><h4 id="优化PHP-FPM结果预览"><a href="#优化PHP-FPM结果预览" class="headerlink" title="优化PHP-FPM结果预览"></a>优化PHP-FPM结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/php-fpm%E4%BC%98%E5%8C%96.gif" alt=""></p><h4 id="PHP-FPM配置-1"><a href="#PHP-FPM配置-1" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96php-fpm.png" alt=""></p><h4 id="wrk压测结果-1"><a href="#wrk压测结果-1" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png" alt=""></p><h4 id="Nginx报错-1"><a href="#Nginx报错-1" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png" alt=""></p><h3 id="优化Nginx压测"><a href="#优化Nginx压测" class="headerlink" title="优化Nginx压测"></a>优化Nginx压测</h3><p><a href="https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/</a></p><p><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/" target="_blank" rel="noopener">http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/</a></p><h4 id="错误：24-Too-many-open-files"><a href="#错误：24-Too-many-open-files" class="headerlink" title="错误：24: Too many open files"></a>错误：<code>24: Too many open files</code></h4><h5 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h5><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/nginx%E6%8A%A5%E9%94%99.png" alt="image-20191113164407658"> </p><h5 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h5><p>Linux / UNIX对文件句柄和打开文件的数量设置了软限制和硬限制。您可以使用ulimit命令查看这些限制</p><p>查看硬值和软值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>在Linux OS级别上增加开放FD限制</p><p>编辑文件/etc/sysctl.conf，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>追加/修改以下行：<br><code>fs.file-max = 100000</code></p><p>保存并关闭文件。编辑/etc/security/limits.conf，输入：<br><code># vi /etc/security/limits.conf</code></p><p>Set soft and hard limit for all users or nginx user as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx       soft    nofile   100000</span><br><span class="line">nginx       hard    nofile  100000</span><br></pre></td></tr></table></figure><p>保存并并关闭文件输入下面命令使之生效<br><code>sysctl -p</code></p><h4 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h4><p><a href="https://www.mtyun.com/library/how-to-optimize-nginx" target="_blank" rel="noopener">https://www.mtyun.com/library/how-to-optimize-nginx</a></p><p><a href="https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html" target="_blank" rel="noopener">https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html</a></p><p>对于Nginx的调优，可以大致从如下指令着手</p><ol><li>worker_processes </li><li>worker_connections</li><li>Buffers</li><li>Timeouts</li><li>Gzip Compression</li><li>Static File Caching</li><li>logging</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">8</span>;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="attribute">accept_mutex</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">accept_mutex_delay</span> <span class="number">500ms</span>;</span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>     <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">10</span>;</span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">crit</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> any;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">gzip_types</span><br><span class="line">text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">text/javascript application/javascript application/x-javascript</span><br><span class="line">text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">text/css text/plain text/x-component</span><br><span class="line">font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">image/x-icon;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\.(?!.*SV1)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">100000</span> inactive=<span class="number">20s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">30s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">12</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####worker_processes-配置工作进程数量</p><p><code>worker_processes</code>表示工作进程的数量，一般情况设置成CPU核的数量即可，一个cpu配置多于一个worker数，对Nginx而言没有任何益处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep processor /proc/cpuinfo | wc -l</span><br></pre></td></tr></table></figure><p>这个命令会告诉你当前机器是多少核，输出为8即表示8核。</p><h5 id="worker-cpu-affinity-配置cpu亲和性"><a href="#worker-cpu-affinity-配置cpu亲和性" class="headerlink" title="worker_cpu_affinity-配置cpu亲和性"></a>worker_cpu_affinity-配置cpu亲和性</h5><p>设置<code>worker_cpu_affinity</code>，这个配置用于将worker process与指定cpu核绑定，降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。 </p><h5 id="worker-rlimit-nofile-配置-worker-进程的最大打开文件数"><a href="#worker-rlimit-nofile-配置-worker-进程的最大打开文件数" class="headerlink" title="worker_rlimit_nofile-配置 worker 进程的最大打开文件数"></a>worker_rlimit_nofile-配置 worker 进程的最大打开文件数</h5><p>调整配置 Nginx worker 进程的最大打开文件数，这个控制连接数的参数为<code>worker_rlimit_nofile</code>。该参数的实际配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure><p>可设置为系统优化后的 <code>ulimit -HSn</code> 的结果</p><h5 id="events块-配置事件处理模型的优化"><a href="#events块-配置事件处理模型的优化" class="headerlink" title="events块-配置事件处理模型的优化"></a>events块-配置事件处理模型的优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="comment"># accept_mutex off;</span></span><br><span class="line"><span class="comment"># accept_mutex_delay 500ms;</span></span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>use epoll</strong></p><p>Nginx 的连接处理机制在不同的操作系统中会采用不同的 I/O 模型，在 linux 下，Nginx 使用 epoll 的 I/O 多路复用模型，在 Freebsd 中使用 kqueue 的 I/O 多路复用模型，在 Solaris 中使用 /dev/poll 方式的 I/O 多路复用模型，在 Windows 中使用 icop，等等。</p><p><code>events</code> 指令是设定 Nginx 的工作模式及连接数上限。<code>use</code>指令用来指定 Nginx 的工作模式。Nginx 支持的工作模式有 select、 poll、 kqueue、 epoll 、 rtsig 和/ dev/poll。当然，也可以不指定事件处理模型，Nginx 会自动选择最佳的事件处理模型。</p><p><strong>accept_mutex off/on ?</strong></p><p><a href="https://blog.huoding.com/2013/08/24/281" target="_blank" rel="noopener">https://blog.huoding.com/2013/08/24/281</a></p><p><a href="https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a>    </p><p>关闭 accept_mutex ，请求在多个 worker 间的分配更均衡</p><h5 id="accept-mutex-delay"><a href="#accept-mutex-delay" class="headerlink" title="accept_mutex_delay"></a>accept_mutex_delay</h5><p>当accept_mutex功能启用后，只有一个持有mutex锁的worker进程会接受并处理请求，其他worker进程等待。accept_mutex_delay指定的时间就是这些worker进程的等待时间，过了等待时间下一个worker进程便取得mutex锁，处理请求。accept_mutex_delay在events模块中指定，默认的值为500ms。</p><h5 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h5><p>通过调整控制连接数的参数来调整 Nginx 单个进程允许的客户端最大连接数。    </p><p><code>worker_connections</code> 也是个事件模块指令，用于定义 Nginx 每个进程的最大连接数，默认是 1024。</p><p>最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients = worker_processes * worker_connections;</span><br></pre></td></tr></table></figure><p>如果作为反向代理，因为浏览器默认会开启 2 个连接到 server，而且 Nginx 还会使用fds（file descriptor）从同一个连接池建立连接到 upstream 后端。则最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients = worker_processes * worker_connections / 4;</span><br></pre></td></tr></table></figure><p>另外，<strong>进程的最大连接数受 Linux 系统进程的最大打开文件数限制</strong>，在执行操作系统命令 <code>ulimit -HSn 65535</code>或配置相应文件后， <code>worker_connections</code> 的设置才能生效。</p><p><strong>multi_accept</strong></p><p>默认情况下，Nginx 进程只会在一个时刻接收一个新的连接，我们可以配置<code>multi_accept</code> 为 <code>on</code>，实现在一个时刻内可以接收多个新的连接，提高处理效率。该参数默认是 <code>off</code>，建议开启。</p><h5 id="tcp优化"><a href="#tcp优化" class="headerlink" title="tcp优化"></a>tcp优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">  <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendfile</strong></p><p>第一行的 <code>sendfile</code> 配置可以提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。</p><p><strong>tcp_nopush</strong></p><p>TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 <code>tcp_nopush</code> 来控制它，并且只有在启用了 <code>sendfile</code> 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。</p><p><strong>keepalive_timeout</strong></p><p>Nginx 使用 keepalive_timeout 来指定 KeepAlive 的超时时间（timeout）。指定每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以可以设定为 60 秒。若将它设置为 0，就禁止了 keepalive 连接。</p><p><strong>keepalive_requests</strong></p><p>keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100。</p><p>这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。<br>大多数情况下当QPS(每秒请求数)不是很高时，默认值100凑合够用。但是，对于一些QPS比较高（比如超过10000QPS，甚至达到30000,50000甚至更高) 的场景，默认的100就显得太低。<br>简单计算一下，QPS=10000时，客户端每秒发送10000个请求(通常建立有多个长连接)，每个连接只能最多跑100次请求，意味着平均每秒钟就会有100个长连接因此被nginx关闭。同样意味着为了保持QPS，客户端不得不每秒中重新新建100个连接。因此，就会发现有大量的TIME_WAIT的socket连接(即使此时keep alive已经在client和nginx之间生效)。因此对于QPS较高的场景，非常有必要加大这个参数，以避免出现大量连接被生成再抛弃的情况，减少TIME_WAIT。</p><p><strong>tcp_nodelay</strong></p><p>TCP_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 <code>tcp_nodelay</code>。</p><h5 id="优化连接参数"><a href="#优化连接参数" class="headerlink" title="优化连接参数"></a>优化连接参数</h5><p>这部分更多是更具业务场景来决定的。例如<code>client_max_body_size</code>用来决定请求体的大小，用来限制上传文件的大小。上面列出的参数可以作为起始参数。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">  <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line">  <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Buffers：另一个很重要的参数为buffer，如果buffer太小，Nginx会不停的写一些临时文件，这样会导致磁盘不停的去读写，现在我们先了解设置buffer的一些相关参数：</p></blockquote><p><strong>client_body_buffer_size</strong></p><p>允许客户端请求的最大单个文件字节数</p><p><strong>client_header_buffer_size</strong></p><p>用于设置客户端请求的Header头缓冲区大小，大部分情况1KB大小足够</p><p><strong>client_max_body_size</strong></p><p>设置客户端能够上传的文件大小，默认为1m</p><p><strong>large_client_header_buffers</strong></p><p>该指令用于设置客户端请求的Header头缓冲区大小</p><h5 id="超时时间优化"><a href="#超时时间优化" class="headerlink" title="超时时间优化"></a>超时时间优化</h5><p><strong>client_body_timeout</strong></p><p>设定客户端与服务器建立连接后发送request body的超时时间。如果客户端在此时间内没有发送任何内容，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http, server 和 location模块中定义。</p><p><strong>client_header_timeout</strong></p><p>设定客户端向服务器发送一个完整的request header的超时时间。如果客户端在此时间内没有发送一个完整的request header，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http 和 server模块中定义。</p><p><strong>send_timeout</strong></p><p>指定了向客户端传输数据的超时时间。默认值为60秒，可以在http, server 和 location模块中定义</p><h5 id="压缩优化"><a href="#压缩优化" class="headerlink" title="压缩优化"></a>压缩优化</h5><p><strong>Gzip 压缩</strong></p><p>开启Gzip，gzip可以帮助Nginx减少大量的网络传输工作，另外要注意<code>gzip_comp_level</code>的设置，太高的话，Nginx服务会浪费CPU的执行周期。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">  <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">gzip_proxied</span> any;</span><br><span class="line">  <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">  gzip_types</span><br><span class="line">    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">    text/javascript application/javascript application/x-javascript</span><br><span class="line">    text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">    text/css text/plain text/x-component</span><br><span class="line">    font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">    image/x-icon;</span><br><span class="line">  <span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\.(?!.*SV1)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(jpg|jpeg|png|gif|ico|css|js)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">365d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测总结"><a href="#压测总结" class="headerlink" title="压测总结"></a>压测总结</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E5%8E%8B%E6%B5%8Bcupp.png" alt="">服务器负载已达到最大，php-fpm+nginx模式进行优化不能再明显的提高PRS</p><h2 id="Swoole"><a href="#Swoole" class="headerlink" title="Swoole"></a>Swoole</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1024</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"msie6"</span>;</span><br><span class="line"><span class="attribute">upstream</span> swoole &#123;</span><br><span class="line">    <span class="comment"># 通过 IP:Port 连接</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:5200</span> weight=<span class="number">5</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="comment"># 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能</span></span><br><span class="line">    <span class="comment">#server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.2:5200 backup;</span></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> dabao.zhimma.com;</span><br><span class="line">    <span class="attribute">index</span>       index.php index.html index default;</span><br><span class="line">    <span class="attribute">root</span> /data/wwwroot/dabao/api/public;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/<span class="variable">$server_name</span>.access.log  main;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># Nginx处理静态资源(建议开启gzip)，LaravelS处理动态资源。</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">@laravels</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 当请求PHP文件时直接响应404，防止暴露public/*.php</span></span><br><span class="line">    <span class="comment">#location ~* \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    return 404;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@laravels</span> &#123;</span><br><span class="line">        <span class="comment"># proxy_connect_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_send_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_read_timeout 120s;</span></span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-PORT <span class="variable">$remote_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Scheme <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Protocol <span class="variable">$server_protocol</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Name <span class="variable">$server_name</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Addr <span class="variable">$server_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">"HttpOnly"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">"Secure"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Frame-Options <span class="string">"SAMEORIGIN"</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://swoole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /backend &#123;</span><br><span class="line">        <span class="attribute">alias</span> /data/wwwroot/dabao/web/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole1.gif" alt=""></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole2.gif" alt=""></p><h2 id="php-fpm-配置文件解读"><a href="#php-fpm-配置文件解读" class="headerlink" title="php-fpm 配置文件解读"></a>php-fpm 配置文件解读</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid</span> = /usr/local/var/run/php-fpm.pid</span><br><span class="line"><span class="comment">#pid设置，一定要开启,上面是Mac平台的。默认在php安装目录中的var/run/php-fpm.pid。比如centos的在: /usr/local/php/var/run/php-fpm.pid</span></span><br><span class="line"><span class="attr">error_log</span>  = /usr/local/var/log/php-fpm.log</span><br><span class="line"><span class="comment">#错误日志，上面是Mac平台的，默认在php安装目录中的var/log/php-fpm.log，比如centos的在: /usr/local/php/var/log/php-fpm.log</span></span><br><span class="line"><span class="attr">log_level</span> = notice</span><br><span class="line"><span class="comment">#错误级别. 上面的php-fpm.log纪录的登记。可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</span></span><br><span class="line"><span class="attr">emergency_restart_threshold</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">emergency_restart_interval</span> = <span class="number">60</span>s</span><br><span class="line"><span class="comment">#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。0 表示 '关闭该功能'. 默认值: 0 (关闭).</span></span><br><span class="line"><span class="attr">process_control_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</span></span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="comment">#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: 'ip:port', 'port', '/path/to/unix/socket'. 每个进程池都需要设置。如果nginx和php在不同的机器上，分布式处理，就设置ip这里就可以了。</span></span><br><span class="line">listen.backlog = -1</span><br><span class="line"><span class="comment">#backlog数，设置 listen 的半连接队列长度，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41</span></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line"><span class="comment">#允许访问FastCGI进程的IP白名单，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接。</span></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0666</span><br><span class="line"><span class="comment">#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</span></span><br><span class="line"><span class="attr">user</span> = www</span><br><span class="line"><span class="attr">group</span> = www</span><br><span class="line"><span class="comment">#启动进程的用户和用户组，FPM 进程运行的Unix用户, 必须要设置。用户组，如果没有设置，则默认用户的组被使用。</span></span><br><span class="line"><span class="attr">pm</span> = dynamic </span><br><span class="line"><span class="comment">#php-fpm进程启动模式，pm可以设置为static和dynamic和ondemand</span></span><br><span class="line"><span class="comment">#如果选择static，则进程数就数固定的，由pm.max_children指定固定的子进程数。</span></span><br><span class="line"><span class="comment">#如果选择dynamic，则进程数是动态变化的,由以下参数决定：</span></span><br><span class="line">pm.max_children = 50 #子进程最大数</span><br><span class="line">pm.start_servers = 2 #启动时的进程数，默认值为: min_spare_servers + (max_spare_servers - min_spare_servers) / 2</span><br><span class="line">pm.min_spare_servers = 1 #保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</span><br><span class="line">pm.max_spare_servers = 3 #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</span><br><span class="line">pm.max_requests = 10000</span><br><span class="line"><span class="comment">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 '0' 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span></span><br><span class="line">pm.status_path = /status</span><br><span class="line"><span class="comment">#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</span></span><br><span class="line">ping.path = /ping</span><br><span class="line"><span class="comment">#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</span></span><br><span class="line">ping.response = pong</span><br><span class="line"><span class="comment">#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</span></span><br><span class="line">access.log = log/$pool.access.log</span><br><span class="line"><span class="comment">#每一个请求的访问日志，默认是关闭的。</span></span><br><span class="line">access.format = "%R - %u %t \"%m %r%Q%q\" %s %f %&#123;mili&#125;d %&#123;kilo&#125;M %C%%"</span><br><span class="line"><span class="comment">#设定访问日志的格式。</span></span><br><span class="line"><span class="attr">slowlog</span> = log/<span class="variable">$pool</span>.log.slow</span><br><span class="line"><span class="comment">#慢请求的记录日志,配合request_slowlog_timeout使用，默认关闭</span></span><br><span class="line"><span class="attr">request_slowlog_timeout</span> = <span class="number">10</span>s</span><br><span class="line"><span class="comment">#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 '0' 表示 'Off'</span></span><br><span class="line"><span class="attr">request_terminate_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的'max_execution_time'因为某些特殊原因没有中止运行的脚本有用. 设置为 '0' 表示 'Off'.当经常出现502错误时可以尝试更改此选项。</span></span><br><span class="line"><span class="attr">rlimit_files</span> = <span class="number">1024</span></span><br><span class="line"><span class="comment">#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</span></span><br><span class="line"><span class="attr">rlimit_core</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置核心rlimit最大限制值. 可用值: 'unlimited' 、0或者正整数. 默认值: 系统定义值.</span></span><br><span class="line"><span class="attr">chroot</span> =</span><br><span class="line"><span class="comment">#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</span></span><br><span class="line"><span class="attr">chdir</span> =</span><br><span class="line"><span class="comment">#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</span></span><br><span class="line"><span class="attr">catch_workers_output</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</span></span><br></pre></td></tr></table></figure><h2 id="Nginx错误日志说明"><a href="#Nginx错误日志说明" class="headerlink" title="Nginx错误日志说明"></a>Nginx错误日志说明</h2><table><thead><tr><th>错误信息</th><th>错误说明</th></tr></thead><tbody><tr><td>upstream prematurely（过早的） closed connection</td><td>请求uri的时候出现的异常，是由于upstream还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略</td></tr><tr><td>recv() failed (104: Connection reset by peer)</td><td>（1）服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉； （2）客户关掉了浏览器，而服务器还在给客户端发送数据； （3）浏览器端按了Stop</td></tr><tr><td>(111: Connection refused) while connecting to upstream</td><td>用户在连接时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while reading response header from upstream</td><td>用户在连接成功后读取数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while sending request to upstream</td><td>Nginx和upstream连接成功后发送数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(110: Connection timed out) while connecting to upstream</td><td>nginx连接后面的upstream时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(110: Connection timed out) while reading response header from upstream</td><td>nginx读取来自upstream的响应头时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(104: Connection reset by peer) while connecting to upstream</td><td>upstream发送了RST，将连接重置</td></tr><tr><td>upstream sent invalid header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>upstream sent no valid HTTP/1.0 header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>client intended to send too large body</td><td>用于设置允许接受的客户端请求内容的最大值，默认值是1M，client发送的body超过了设置值</td></tr><tr><td>reopening logs</td><td>用户发送kill  -WINCH命令</td></tr><tr><td>no servers are inside upstream</td><td>upstream下未配置server</td></tr><tr><td>no live upstreams while connecting to upstream</td><td>upstream下的server全都挂了</td></tr><tr><td>SSL_do_handshake() failed</td><td>SSL握手失败</td></tr><tr><td>SSL_write() failed (SSL:) while sending to client</td><td></td></tr><tr><td>(13: Permission denied) while reading upstream</td><td></td></tr><tr><td>(98: Address already in use) while connecting to upstream</td><td></td></tr><tr><td>(99: Cannot assign requested address) while connecting to upstream</td><td></td></tr><tr><td>ngx_slab_alloc() failed: no memory in SSL session shared cache</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>could not add new SSL session to the session cache while SSL handshaking</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>send() failed (111: Connection refused)</td></tr></tbody></table><h3 id="错误日志类型"><a href="#错误日志类型" class="headerlink" title="错误日志类型"></a>错误日志类型</h3><ul><li>类型1: upstream timed out</li><li>类型2: connect() failed</li><li>类型3: no live upstreams</li><li>类型4: upstream prematurely closed connection</li><li>类型5: 104: Connection reset by peer</li><li>类型6: client intended to send too large body</li><li>类型7: upstream sent no valid HTTP/1.0 header</li></ul><table><thead><tr><th>类型</th><th>错误日志</th><th>原因</th><th>解决办法</th></tr></thead><tbody><tr><td>1</td><td>upstream timed out (110: Connection timed out) while connecting to upstream</td><td>nginx与upstream建立tcp连接超时，nginx默认连接建立超时为200ms</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>1</td><td>upstream timed out (110: Connection timed out) while reading response header from upstream</td><td>nginx从upstream读取响应时超时，nginx默认的读超时为20s，读超时不是整体读的时间超时，而是指两次读操作之间的超时，整体读耗时有可能超过20s</td><td>排查upstream响应请求为什么过于缓慢</td></tr><tr><td>2</td><td>connect() failed (104: Connection reset by peer) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被reset</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>2</td><td>connect() failed (111: Connection refused) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被拒</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td><strong>3</strong></td><td><strong>no live upstreams while connecting to upstream</strong></td><td><strong>nginx向upstream转发请求时发现upstream状态全都为down</strong></td><td><strong>排查nginx的upstream的健康检查为什么失败</strong></td></tr><tr><td>4</td><td>upstream prematurely closed connection</td><td>nginx在与upstream建立完tcp连接之后，试图发送请求或者读取响应时，连接被upstream强制关闭</td><td>排查upstream程序是否异常，是否能正常处理http请求</td></tr><tr><td>5</td><td>recv() failed (104: Connection reset by peer) while reading response header from upstream</td><td>nginx从upstream读取响应时连接被对方reset</td><td>排查upstream应用已经tcp连接状态是否异常</td></tr><tr><td>6</td><td>client intended to send too large body</td><td>客户端试图发送过大的请求body，nginx默认最大允许的大小为1m，超过此大小，客户端会受到http 413错误码</td><td>调整请求客户端的请求body大小；调大相关域名的nginx配置：client_max_body_size；</td></tr><tr><td>7</td><td>upstream sent no valid HTTP/1.0 header</td><td>nginx不能正常解析从upstream返回来的请求行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> PHP-FPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> PHP-FPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen接入Azure的blob存储配置</title>
      <link href="/2019/08/16/Lumen%E6%8E%A5%E5%85%A5Azure%E7%9A%84blob%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/08/16/Lumen%E6%8E%A5%E5%85%A5Azure%E7%9A%84blob%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>最近在做的一个项目使用的是Azure服务器，其中数据库、redis、和对象存储和国内厂商都有不同，最直观的区别就是Azure基本都是SSL方式进行连接，相对国内云服务器厂商的服务接入没有那么无脑，今天简单记录下Azure提供的blob存储在lumen框架的接入</p><h3 id="几个轮子"><a href="#几个轮子" class="headerlink" title="几个轮子"></a>几个轮子</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer require league/flysystem</span><br><span class="line">composer require league/flysystem-azure-blob-storage</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Laravel/Lumen 提供了很强大的文件管理系统和云存储功能的集成</p><p><code>/Users/zhimma/Data/www/lumen/vendor/laravel/lumen-framework/config</code>目录复制一份到项目根目录下,主要检查<code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code>这个文件是否存在</p><p>下面进行配置：</p><ol><li><p><code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code></p><p>在配置s3下方添加如下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">'azure'</span> =&gt; [</span><br><span class="line">    <span class="string">'driver'</span>    =&gt; <span class="string">'azure'</span>,</span><br><span class="line">    <span class="string">'name'</span>      =&gt; env(<span class="string">'AZURE_STORAGE_NAME'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">    <span class="string">'key'</span>       =&gt; env(<span class="string">'AZURE_STORAGE_KEY'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">    <span class="string">'container'</span> =&gt; env(<span class="string">'AZURE_STORAGE_CONTAINER'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p><code>/Users/zhimma/Data/www/lumen/bootstrap/app.php</code></p><ol><li>添加<code>$app-&gt;configure(&#39;filesystems&#39;);</code>表示加载该配置文件项</li><li>添加<code>$app-&gt;register(\Illuminate\Filesystem\FilesystemServiceProvider::class);</code>加载该服务提供者</li></ol></li><li><p><code>/Users/zhimma/Data/www/lumen/app/Providers/AppServiceProvider.php</code></p><p>新增下面的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Storage::extend(<span class="string">'azure'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app, $config)</span> </span>&#123;</span><br><span class="line">        $endpoint = sprintf(<span class="string">'DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=%s;EndpointSuffix=core.chinacloudapi.cn'</span>,</span><br><span class="line">            $config[<span class="string">'name'</span>], $config[<span class="string">'key'</span>], $config[<span class="string">'url'</span>] ?? <span class="keyword">null</span>, $config[<span class="string">'prefix'</span>] ?? <span class="keyword">null</span>);</span><br><span class="line">        $client = BlobRestProxy::createBlobService($endpoint);</span><br><span class="line">        $adapter = <span class="keyword">new</span> AzureBlobStorageAdapter($client, $config[<span class="string">'container'</span>], $config[<span class="string">'prefix'</span>] ?? <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filesystem($adapter);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems" target="_blank" rel="noopener">https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems</a></p></li></ol><h3 id="上传测试"><a href="#上传测试" class="headerlink" title="上传测试"></a>上传测试</h3><p>新增好路由后，我们进行上传测试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>  zhimma</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>    2019/5/27 12:00 PM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!$request-&gt;hasFile(<span class="string">'file'</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        $file = $request-&gt;file(<span class="string">'file'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!$file-&gt;isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>($file-&gt;getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        $path = Storage::put(date(<span class="string">'Ymd'</span>), $file);</span><br><span class="line">        $url = env(<span class="string">'AZURE_BLOB_URL'</span>).<span class="string">'/'</span>.env(<span class="string">'AZURE_STORAGE_CONTAINER'</span>).<span class="string">'/'</span>.$path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success([<span class="string">'url'</span> =&gt; $url]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"httpCode"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"statusCode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"https://xxx.blob.core.chinacloudapi.cn/xxx/20190816/FKRJQXqo1Rdm77mAW2biuBSaVx12mH4U52NtKlZI.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此配置完成</p><p>参考</p><blockquote><p><a href="https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/" target="_blank" rel="noopener">https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</a></p><p><a href="https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen" target="_blank" rel="noopener">https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Azure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Azure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins初始化及常见问题整理</title>
      <link href="/2019/06/19/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2019/06/19/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="错误异常处理"><a href="#错误异常处理" class="headerlink" title="错误异常处理"></a>错误异常处理</h2><h3 id="1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h"><a href="#1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h" class="headerlink" title="1. Failed to connect to repository : Error performing command: git ls-remote -h"></a>1. Failed to connect to repository : Error performing command: git ls-remote -h</h3><p><strong>产生原因:</strong> </p><p>Jenkins服务器没有安装git</p><p><strong>解决方式：</strong></p><p><strong>1. Jenkins服务器上查看git是否已安装及安装位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ci ~]<span class="comment"># git version</span></span><br><span class="line">-bash: git: <span class="built_in">command</span> not found</span><br><span class="line">[root@ci ~]<span class="comment"># yum install git -y</span></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line">[root@ci ~]<span class="comment"># whereis git</span></span><br><span class="line">git: /usr/bin/git</span><br></pre></td></tr></table></figure><p><strong>2. 打开Jenkins的 主页面 &gt; 系统管理 &gt; Global Tool Configuration</strong></p><p>配置下git 的path   </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs1.gif" alt=""></p><h3 id="2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists."></a>2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.</h3><p><strong>产生原因:</strong> </p><p>代码仓库没有添加允许jenkins服务器用户拉取代</p><p><strong>解决方式：</strong></p><blockquote><p>创建秘钥可以参考第三个错误的解决步骤</p></blockquote><ul><li><p>检查jenkins服务器ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="comment"># cd .ssh</span></span><br><span class="line">[jenkins@ci ~]<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 1675 Jun 19 11:06 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  389 Jun 19 11:06 id_rsa.pub</span><br></pre></td></tr></table></figure><p>如果没有文件，则使用下面命令进行创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="variable">$ssh</span>-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/var/lib/jenkins/.ssh/id_rsa):</span><br><span class="line">// 一路回车即可</span><br></pre></td></tr></table></figure></li><li><p>在代码仓库添加jenkins服务器用户的公钥</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic3.png" alt=""></p></li><li><p>在jenkins管理端创建全局凭证并使用</p><ul><li><p>创建全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs2.gif" alt=""></p></li><li><p>使用全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic4.gif" alt=""></p></li></ul></li></ul><h3 id="3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied"><a href="#3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied" class="headerlink" title="3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied"></a>3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied</h3><p><a href="https://blog.csdn.net/cdnight/article/details/81078191" target="_blank" rel="noopener">参考1</a></p><p>这里需要对Jenkins密钥进行配置</p><h4 id="3-1-切换jenkins用户不成功"><a href="#3-1-切换jenkins用户不成功" class="headerlink" title="3-1 切换jenkins用户不成功"></a>3-1 切换jenkins用户不成功</h4><p>jenkins系统本身有bug的，下面切换用户会失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su jenkins</span><br></pre></td></tr></table></figure><p>解决办法如下：</p><p><code>/etc/passwd</code>文件中的<code>/bin/bash</code>被yum安装的时候变成了<code>/bin/false</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic5.png" alt=""></p><p>然后我执行<code>cat /etc/passwd</code>命令，果然被改成了<code>/bin/false</code></p><p><code>cat /etc/passwd</code></p><p>接着执行<code>sudo vim /etc/passwd</code>命令,把<code>false</code>改为<code>bash</code></p><p><code>sudo vim /etc/passwd</code></p><p>改完后使用<code>grep jenkins /etc/passwd</code> 查看下是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins:x:997:995:Jenkins Automation Server:/var/lib/jenkins:/bin/bash</span><br></pre></td></tr></table></figure><h4 id="3-2-su-jenkins-bash-4-2问题"><a href="#3-2-su-jenkins-bash-4-2问题" class="headerlink" title="3-2 su jenkins  bash-4.2问题"></a>3-2 su jenkins  bash-4.2问题</h4><p>当我们切换到jenkins用户后，命令提示符的用户名不是jenkins而变成了<br><code>-bash-4.2#</code></p><p>网上一查，原因是在安装jenkins时，jenkins只是创建了jenkins用户，并没有为其创建home目录。所以系统就不会在创建用户的时候，自动拷贝/etc/skel目录下的用户环境变量文件到用户家目录，也就导致这些文件不存在，出现-bash-4.2#的问题了<br>以下命令是在切换到jenkins用户下执行的！（只是用户现在显示的是-bash-4.2）</p><p>这个时候呢，参考网上的做法我执行下面步骤： </p><ol><li><p>vim ~/.bash_profile<br>执行上面的命令，即使没有.bash_profile文件，linux会自动创建。 </p></li><li><p>然后再添加这句</p><p><code>export PS1=&#39;[\u@\h \W]\$&#39;</code></p></li><li><p>我们最后再刷新.bash_profile文件，使其起作用</p><p><code>source ~/.bash_profile</code></p></li></ol><h4 id="3-2-su-jenkins-bash-4-2再解决"><a href="#3-2-su-jenkins-bash-4-2再解决" class="headerlink" title="3-2 su jenkins  bash-4.2再解决"></a>3-2 su jenkins  bash-4.2再解决</h4><p><a href="https://www.mgchen.com/227.html" target="_blank" rel="noopener">参考</a></p><p>在上面操作后，我使用su jenkins 还是会有bash-4.2界面，只需把命令变为su - jenkins可以解决，同事给了一个其他的方法</p><p>​    将/etc/skel/目录下 .bashrc和 .bash_profile 文件拷贝到用户的家目录下，然后对复制过去的文件授予该用户、用户组权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/skel/.bashrc /var/lib/jenkins/</span><br><span class="line">cp /etc/skel/.bash_profile /var/lib/jenkins/</span><br><span class="line">chown jenkins.jenkins /var/lib/jenkins/.bashrc</span><br><span class="line">chown jenkins.jenkins /var/lib/jenkins/.bash_profile</span><br></pre></td></tr></table></figure><p>​    然后退出重新登录，就恢复正常了。</p><p><strong>/etc/skel/目录作用：</strong></p><p>​       用来存放新用户环境变量文件，添加新用户时，将该目录下文件拷贝到新用户家目录中。</p><p>​       默认情况下该目录下都是隐藏文件（以.点开头的文件）；</p><p>​       通过修改、添加、删除该目录下的文件，可为新添加的用户提供统一的、标准的、初始化用户环境。</p><p>####3-3 su jenkins  需要输密码</p><p>上面我们解决了bash-4.2，下次从root切换jenkins用户的时候，发现需要输入密码，下面解决下这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>添加<code>jenkins ALL=(ALL) NOPASSWD: ALL</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic6.png" alt=""></p><p>然后执行<code>/etc/init.d/jenkins restart</code></p><h4 id="3-4-Jenkins密钥配置"><a href="#3-4-Jenkins密钥配置" class="headerlink" title="3-4 Jenkins密钥配置"></a>3-4 Jenkins密钥配置</h4><p><code>su - jenkins</code>切换到jenkins用户后，使用下面命令生成秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]$ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/var/lib/jenkins/.ssh/id_rsa):</span><br><span class="line">// 一路回车即可</span><br></pre></td></tr></table></figure><p>生成后，</p><ol><li>把公钥添加到代码管理工具gitlab或者其他平台，使得jenkins用户有权限拉取代码</li><li>把公钥添加到需要发布代码的服务器，使得jenkins所在服务器有权限进行scp 或 ssh操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go零零碎碎</title>
      <link href="/2019/06/17/Go%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
      <url>/2019/06/17/Go%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型：基本数据类型int、float、bool、string、数组和结构体struct都属于值类型,使用这些类型的变量是直接使用指向存在内存中的值，值类型的变量的值通常存储在栈中</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>golang的统一编码为utf-8，golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8，所以字母数字占一字节，汉字占3字节</p><p>要获取一个字符串的长度，有以下2种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 芝麻开门"</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">"str 的长度:"</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"str 的RuneCountInString长度:"</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">"str 的rune convert长度："</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang中还有一个<strong>byte</strong>数据类型，与<strong>rune</strong>相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于int8，常用来处理ascii字符</li><li>rune 等同于int32，常用来处理unicode或utf-8字符</li><li>循环一个字符串时，如果有中文，需要转切片，不然会出现乱码，因为是按照字符串的字节长度遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 芝麻开门"</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">"str 的长度:"</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"str 的RuneCountInString长度:"</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">"str 的rune convert长度："</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">runeStr := []<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runeStr); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, runeStr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment">h</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">芝</span></span><br><span class="line"><span class="comment">麻</span></span><br><span class="line"><span class="comment">开</span></span><br><span class="line"><span class="comment">门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 字符串函数</span></span><br><span class="line"><span class="comment">// 判断一个字符串是否包含指定的字符串</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计一个字符串有几个指定的字符，判断字符重复次数</span></span><br><span class="line">fmt.Println(strings.Count(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较：不区分大小写==</span></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">"hello world"</span>, <span class="string">"Hello World"</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串第一次出现的index值</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串最后一次出现的位置</span></span><br><span class="line">fmt.Println(strings.LastIndex(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换 n=-1表示全部替换</span></span><br><span class="line">fmt.Println(strings.Replace(<span class="string">"hello world"</span>, <span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="number">1</span>)) <span class="comment">// 你好 world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查分字符串为数组，类似PHP中的explode</span></span><br><span class="line">strArr := strings.Split(<span class="string">"hello world"</span>, <span class="string">"o w"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"strArr 类型 %T,值%v\n"</span>, strArr, strArr) <span class="comment">// strArr 类型 []string,值[hell orld]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr); i++ &#123;</span><br><span class="line">fmt.Println(strArr[i])</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hell</span></span><br><span class="line"><span class="comment">orld</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字符串大小写转换</span></span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">"HELLO WORLD"</span>)) <span class="comment">// hello world</span></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">"hello world"</span>)) <span class="comment">// HELLO WORLD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串两边的字符</span></span><br><span class="line">fmt.Println(strings.TrimRight(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>)) <span class="comment">// ~hello world</span></span><br><span class="line">fmt.Println(strings.TrimLeft(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>))  <span class="comment">// hello world~</span></span><br><span class="line">fmt.Println(strings.Trim(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>))      <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 评断字符串头尾是否存在指定字符</span></span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join联合组合字符串</span></span><br><span class="line">fmt.Println(strings.Join(strArr, <span class="string">"o w"</span>)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"go "</span>, <span class="number">3</span>)) <span class="comment">// go go go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义并初始化一个长度为3的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr, arr1) <span class="comment">// [1 2 3] [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个长度为6的数组，最后一个元素值为-1</span></span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">5</span>: <span class="number">-1</span>&#125;</span><br><span class="line">fmt.Println(arr2) <span class="comment">// [0 0 0 0 0 -1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3的int型数组，初始值是3个0,数组“零值”状态</span></span><br><span class="line"><span class="keyword">var</span> arr3 [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(arr3) <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">arr4 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">arr5 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;, &#123;<span class="string">"AA"</span>, <span class="string">"BB"</span>&#125;, &#123;<span class="string">"AAA"</span>, <span class="string">"BBB"</span>&#125;&#125;</span><br><span class="line">fmt.Println(arr4, arr5) <span class="comment">// [[0 0] [0 0] [0 0]] [[a b] [AA BB] [AAA BBB]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new声明数组</span></span><br><span class="line">arr6 := <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr6类型%T，值%v"</span>, arr6, arr6) <span class="comment">// arr6类型*[3]int，值&amp;[0 0 0]</span></span><br><span class="line"></span><br><span class="line">arr7 := <span class="built_in">new</span>([<span class="number">2</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr7类型%T，值%v"</span> , arr7 , arr7) <span class="comment">// arr7类型*[2]int，值&amp;[0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">for_range</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">string</span>&#123;<span class="string">"go"</span>, <span class="string">"php"</span>, <span class="string">"java"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">"key = %v , value = %v"</span>, key, value)</span><br><span class="line"><span class="comment">// key = 0 , value = gokey = 1 , value = phpkey = 2 , value = java</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h3><h4 id="定义和创建"><a href="#定义和创建" class="headerlink" title="定义和创建"></a>定义和创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sliceDemo1()</span><br><span class="line">   sliceDemo2()</span><br><span class="line">   sliceDemo3()</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo1() &#123;</span><br><span class="line">   var arr [5]int = [...]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">   var slice = arr[1:3]</span><br><span class="line">   // slice value=[2 3] , cap=4 , len=2</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo2() &#123;</span><br><span class="line">   var slice []int = make([]int, 5, 10)</span><br><span class="line">   fmt.Println(slice) // [0 0 0 0 0]</span><br><span class="line">   slice[1] = 5</span><br><span class="line">   slice[3] = 10</span><br><span class="line">   // slice value=[0 5 0 10 0] , cap=10 , len=5</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo3() &#123;</span><br><span class="line">   // 声明和初始化一个切片</span><br><span class="line">   var slice []string = []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三种方式说明及区别"><a href="#三种方式说明及区别" class="headerlink" title="三种方式说明及区别"></a>三种方式说明及区别</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>sliceDemo1</strong>：让切片引用一个已经存在的数组创建切片</p><p><strong>sliceDemo2</strong>：使用make来创建，可以指定切片的大小和容量，如果没有给切片赋值，则会使用默认值，(int、float=&gt;0, strint=&gt;””, bool=&gt;false)；make方式创建的切片对应的数组由make底层维护，对外不开见，只能通过slice访问各个元素</p><p><strong>sliceDemo3</strong>：定义一个切片直接指定具体数组</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>sliceDemo1方式是直接引用数组，这个数组是事先存在的，对程序员可见</p><p>sliceDemo2通过make创建切片，make也会创建一个数组，是由切片在底层维护，该数组对程序员不可见    </p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">8</span>]<span class="keyword">int</span>&#123;<span class="number">22</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">55</span>, <span class="number">54</span>, <span class="number">33</span>&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    [1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">fmt.Println(bubble1(arr))</span><br><span class="line">fmt.Println(bubble2(arr))</span><br><span class="line">fmt.Println(bubble3(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble1</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8] <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">fmt.Println(data[i])</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble2</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(data); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] &gt; data[j] &#123;</span><br><span class="line">tmp := data[i]</span><br><span class="line">data[i] = data[j]</span><br><span class="line">data[j] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble3</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map相当于PHP中的关联数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mapDemo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 声明方式1</span></span><br><span class="line">   <span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">   map1[<span class="string">"name"</span>] = <span class="string">"zhimma"</span></span><br><span class="line">   map1[<span class="string">"address"</span>] = <span class="string">"xian"</span></span><br><span class="line">   fmt.Println(map1) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式2</span></span><br><span class="line">   map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   map2[<span class="string">"name"</span>] = <span class="string">"zhimma"</span></span><br><span class="line">   map2[<span class="string">"address"</span>] = <span class="string">"xian"</span></span><br><span class="line">   fmt.Println(map2) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式3</span></span><br><span class="line">   map3 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">      <span class="string">"name"</span>:    <span class="string">"zhimma"</span>,</span><br><span class="line">      <span class="string">"address"</span>: <span class="string">"xian"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(map3) <span class="comment">// // map[name:zhimma address:xian]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针相关概念"><a href="#指针相关概念" class="headerlink" title="指针相关概念"></a>指针相关概念</h2><p><strong>变量</strong>：变量是基本类型，变量存的就是值，也叫值类型</p><p><strong>地址</strong>：用于引用计算机的内存地址，可理解为内存地址的标签，通俗一点讲就是一个房子在小区门牌号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量name并赋值</span></span><br><span class="line">name := <span class="string">"zhimma"</span></span><br><span class="line">fmt.Println(<span class="string">"name 的地址是"</span>, &amp;name) <span class="comment">// name 的地址是 0xc000092030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针</strong>：指针变量存的是一个<strong>地址</strong>，这个地址指向的空间存的才是值，指针是一个指向另一个变量内存地址的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"i 的地址是"</span>, &amp;i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">"ptr=%v\n"</span>, ptr)</span><br><span class="line">fmt.Printf(<span class="string">"ptr的地址是%v\n"</span>, &amp;ptr)</span><br><span class="line">fmt.Printf(<span class="string">"ptr指向的值是%v\n"</span>, *ptr)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    i 的地址是 0xc00001a080</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">ptr=0xc00001a080</span></span><br><span class="line"><span class="comment">ptr的地址是0xc00000c030</span></span><br><span class="line"><span class="comment">ptr指向的值是1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&amp;:取地址符，指针 := &amp;变量</p><p><em>:取值符， 变量 := </em>指针</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>定义匿名函数有2种方式</p><ul><li><p>定义时直接使用（这种方式只使用一次）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">totalNum := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(totalNum) <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将匿名函数赋值给变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数赋值给变量sunFunc</span></span><br><span class="line">sumFunc := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">total := sumFunc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局匿名函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalFunc = <span class="function"><span class="keyword">func</span><span class="params">(params <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"this is globalFunc and receive params str is'"</span> + params + <span class="string">"'"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := globalFunc(<span class="string">"hello world"</span>)</span><br><span class="line">fmt.Println(str) <span class="comment">// this is globalFunc and receive params str is'hello world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数用来分配内存，主要分配值类型，比如int、float32、struct等，返回的是指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num 的类型是%T,值是%v,地址是%v"</span>, num, num, &amp;num) </span><br><span class="line">    <span class="comment">// num 的类型是int,值是100,地址是0xc00001a178</span></span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"num1 的类型是%T,值是%v,地址是%v"</span>, num1, num1, &amp;num1)                </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a190,地址是0xc00000c030</span></span><br><span class="line">fmt.Printf(<span class="string">"num1 的类型是%T,值是%v,地址是%v,指向的值是%v"</span>, num1, num1, &amp;num1, *num1) </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a098,地址是0xc00000c030,指向的值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据管理-volume/bind mount/tmpfs mount</title>
      <link href="/2019/04/10/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-volume-bind-mount-tmpfs-mount/"/>
      <url>/2019/04/10/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-volume-bind-mount-tmpfs-mount/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，它绕过<code>UFS</code>，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h2 id="v-mount-如何选择"><a href="#v-mount-如何选择" class="headerlink" title="-v/-mount 如何选择"></a>-v/-mount 如何选择</h2><p>最初，<code>-v</code> 和 <code>-volume</code> 用于独立的容器，<code>--mount</code> 用于 swarm server。但 docker 17.06 之后，也可以使用 <code>--mount</code>。两者的区别在于，<code>-v</code> 将所有选项组合在一个字段中，<code>--mount</code> 则将它们分开。</p><blockquote><p>新用户应使用 <code>--mount</code> 语法，老用户推荐使用 <code>--mount</code>。</p></blockquote><ul><li><code>-v/--volume</code>，由（<code>:</code>）分隔的三个字段组成，<code>&lt;卷名&gt;:&lt;容器路径&gt;:&lt;选项列表&gt;</code>。选项列表，如：<code>ro</code>只读。</li><li><code>--mount</code>，由多个键值对组成，由<code>,</code>分隔，每个由一个<code>&lt;key=&lt;value&gt;&gt;</code>元组组成。<ul><li><code>type</code>，值可以为 <code>bind</code>，<code>volume</code>，<code>tmpfs</code>。</li><li><code>source</code>，对于命名卷，是卷名。对于匿名卷，这个字段被省略。可能被指定为 <code>source</code> 或 <code>src</code>。</li><li><code>destination</code>，文件或目录将被挂载到容器中的路径。可以指定为 <code>destination</code>，<code>dst</code> 或 <code>target</code>。</li><li><code>volume-opt</code> 可以多次指定。</li></ul></li></ul><h2 id="选择合适的挂载方式"><a href="#选择合适的挂载方式" class="headerlink" title="选择合适的挂载方式"></a>选择合适的挂载方式</h2><p>Docker提供了3种方法将数据从Docker宿主机挂载（mount）到容器：<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>。一般来说，<code>volumes</code>总是最好的选择。</p><p>不管你选择哪种挂载方式，从容器中看都是一样的。数据在容器的文件系统中被展示为一个目录或者一个单独的文件。</p><p>一个简单区分<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>不同点的方法是：<strong>思考数据在宿主机上是如何存在的。</strong></p><ul><li><strong>Volumes</strong>由Docker管理，存储在宿主机的某个地方（在linux上是<code>/var/lib/docker/volumes/</code>）。非Docker应用程序不能改动这一位置的数据。Volumes是Docker最好的数据持久化方法。</li><li><strong>Bind mounts</strong>的数据可以存放在宿主机的任何地方。数据甚至可以是重要的系统文件或目录。非Docker应用程序可以改变这些数据。</li><li><strong>tmpfs mounts</strong>的数据只存储在宿主机的内存中，不会写入到宿主机的文件系统。</li></ul><h2 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h2><p><strong>Volumes</strong>：由Docker创建和管理。你可以通过<code>docker volume create</code>命令显式地创建<code>volume</code>，Docker也可以在创建容器或服务是自己创建volume。</p><p>例如下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">☁  Docker  docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name demo \</span><br><span class="line">  --mount type=volume,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line">7eb04d34a87ecd4a7996f8ad4da83bd613d2e992f6860faf730b876a66efd19f</span><br><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               0c06952c157c3b6550e7f71a9c6463a1b70c893c15b0d8e0b8d05ad398ced427</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure><blockquote><p>第一行：先查看下volume列表</p><p>第四行：创建container，并使用type=volume类型，指向container内部app目录</p><p>第十行：查看最新的volume列表</p></blockquote><p>当你创建了一个volume，它会被存放在宿主机的一个目录下。当你将这个volume挂载到某个容器时，这个目录就是挂载到容器的东西。这一点和<code>bind mounts</code>类似，除了volumes是由Docker创建的，和宿主机的核心（<code>core functionality</code>）隔离。</p><p>一个volume可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个volume，volume依然存在，不会被自动清除。可以通过<code>docker volume prune</code>清除不再使用的volumes。</p><p>volumes也支持<code>volume driver</code>，可以将数据存放在另外的机器或者云上。</p><p><strong>Bind mounts</strong>：Docker早期就支持这个特性。与volumes相比，<code>Bind mounts</code>支持的功能有限。使用<code>bind mounts</code>时，可以将你主机上的任何文件或目录（<strong>绝对路径</strong>）挂载到容器中。</p><blockquote><p>警告：使用<code>Bind mounts</code>的一个副作用是，容器中运行的程序可以修改宿主机的文件系统，包括创建，修改，删除重要的系统文件或目录。这个功能可能会有安全问题。</p></blockquote><p><strong>tmpfs mounts</strong>：<code>tmpfs mounts</code>的数据不会落盘。在容器的生命周期内，它可以被用来存储一些不需要持久化的状态或敏感数据。例如，<code>swarm</code>服务通过<code>tmpfs mounts</code>来将<a href="https://docs.docker.com/engine/swarm/secrets/" target="_blank" rel="noopener">secrets</a>挂载到一个服务的容器中去。</p><h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><h3 id="适合volume的场景"><a href="#适合volume的场景" class="headerlink" title="适合volume的场景"></a>适合volume的场景</h3><ul><li>在不同的容器中共享数据，如果未显式创建它，则会在第一次将其装入容器时创建。当该容器停止或被移除时，该卷仍然存在。多个容器可以同时安装相同的卷，可以是读写也可以是只读。仅在您明确删除卷时才会删除卷</li><li>当Docker主机不能保证具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时分离。</li><li>如果要将容器的数据存储在远程主机或云提供程序上，而不是本地存储。</li><li>当你需要备份或迁移数据的时候，当您需要能够将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是更好的选择。您可以使用卷停止容器，然后备份卷的目录（例如/var/lib/docker/volumes/）</li></ul><h3 id="适合bind-mounts的场景"><a href="#适合bind-mounts的场景" class="headerlink" title="适合bind mounts的场景"></a>适合bind mounts的场景</h3><ul><li>宿主机和容器共享配置文件。Docker提供的DNS解决方案就是如此，将宿主机的<code>/etc/resolv.conf</code>挂载到每个容器中。</li><li>开发环境需要在宿主机和容器中共享代码。docker的开发就是如此，毕竟容器中一般是没有编辑器的</li><li>当Docker主机的文件或目录结构保证与容器所需的绑定安装一致时</li></ul><h2 id="适合tmpfs-mounts的场景"><a href="#适合tmpfs-mounts的场景" class="headerlink" title="适合tmpfs mounts的场景"></a>适合tmpfs mounts的场景</h2><p><code>tmpfs mounts</code>主要用在你既不想在容器内，又不想在宿主机文件系统保存数据的时候。这可能是出于安全原因，也可能是你的应用需要写非常多的非持久化数据，<code>tmpfs mounts</code>这时候可以保证容器性能。    </p><p>##本文转自<a href="https://michaelyou.github.io/2017/09/17/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-Volume%EF%BC%8C-bind-mount%E5%92%8Ctmpfs-mount/" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记8-Go语言并发</title>
      <link href="/2019/03/22/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/03/22/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Go 语言通过编译器运行时（runtime）,从语言上支持了并发的特性。Go 语言的并发通过goroutine 特性完成。<br>goroutine 类似于线程，但可以根据需要创建多个goroutine并发工作<br>goroutine 是由Go 语言的运行时调度完成，而线程是由操作系统调度完成</p><p>Go 语言还提供channel 在多个goroutine 间进行通信。goroutine 和 channel是Go 语言秉承CSP并发模式的重要实现基础。</p><h2 id="Go-语言goroutine"><a href="#Go-语言goroutine" class="headerlink" title="Go 语言goroutine"></a>Go 语言goroutine</h2><p>在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。<br>开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。</p><p>如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go 语言中被称为 <strong>goroutine</strong>。</p><p>goroutine 的概念类似于线程，但 goroutine 是由Go 程序运行时进行调度和管理。Go 程序会智能地将goroutine 中的任务合理地分配给每个CPU</p><p>Go 程序从main 包的main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的goroutine</p><h3 id="使用普通函数创建-goroutine"><a href="#使用普通函数创建-goroutine" class="headerlink" title="使用普通函数创建 goroutine"></a>使用普通函数创建 goroutine</h3><p>Go 语言程序中使用<strong>go</strong>关键字为一个函数创建一个goroutine。一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数</p><p><strong>格式</strong></p><p>为一个普通函数创建goroutine的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>使用 <strong>go</strong>关键字创建goroutine时，被调用函数的返回值会被忽略</p><p>如果需要在goroutine中返回数据，需要使用channel特性，通过通道(channel)把数据从goroutine中作为返回值传出</p><p><strong>例子</strong></p><p>使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> running()</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input) <span class="comment">// 接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">running</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times++</span><br><span class="line">fmt.Println(<span class="string">"tick"</span> , times)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行输出如下：<br>tick 1<br>tick 2<br>tick 3<br>tick 4<br>tick 5</p><p>代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。</p><p>这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。</p><h3 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a>使用匿名函数创建goroutine</h3><p>go 关键字后也可以为匿名函数或者闭包启动goroutine</p><p><strong>使用匿名函数创建goroutine</strong></p><p>使用匿名函数或者闭包创建goroutine时，除了将函数定义部分卸载go 的后面之外，还需要加上匿名函数的调用参数，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;(调用参数列表)</span><br></pre></td></tr></table></figure><p><strong>使用匿名函数创建goroutine例子</strong></p><p>在main() 函数中创建一个匿名函数并未匿名函数启动goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times ++</span><br><span class="line">fmt.Println(<span class="string">"tick"</span> , times)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。</p><p>终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数</p><h2 id="Go语言GOMAXPROCS-调整并发的运行性能"><a href="#Go语言GOMAXPROCS-调整并发的运行性能" class="headerlink" title="Go语言GOMAXPROCS(调整并发的运行性能)"></a>Go语言GOMAXPROCS(调整并发的运行性能)</h2><p>在 Go 程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br></pre></td></tr></table></figure><p>这里的逻辑CPU数量可以有以下几种数值：</p><ul><li>&lt;1不修改任何数值</li><li>=1单核心执行</li><li>>1多喝并发执行</li></ul><p>一般情况下，可以使用 <code>runtime.NumCPU()</code>查询 CPU 数量，并使用<code>runtime.GOMAXPROCS()</code> 函数进行设置，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure><p>GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。</p><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>下面让我们来了解并发和并行之间的区别：</p><ul><li>并发：把任务在不同的时间点交给处理器进行处理，在同一时间点，任务并不会同时运行</li><li>并行：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li></ul><p>两个概念的区别是：任务是否同时执行。举一个生活中的例子：打电话和吃饭。</p><p>吃饭时，电话来了，需要停止吃饭去接电话。电话接完后回来继续吃饭，这个过程是并发执行。</p><p>吃饭时，电话来了，边吃饭边接电话。这个过程是并行执行。</p><p>GO 语言在 GOMAXPROCS 数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。</p><h3 id="goroutine-和-coroutine的区别"><a href="#goroutine-和-coroutine的区别" class="headerlink" title="goroutine 和 coroutine的区别"></a>goroutine 和 coroutine的区别</h3><p>coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p><ul><li>goroutine 可能发生并行执行；</li><li>但 coroutine 始终顺序执行。</li></ul><p>狭义的说，</p><p>goroutine 可能发生在多线程环境下，goroutine无法控制自己获取高优先度支持</p><p>coroutine始终发生在单线程，coroutine 程序需要主动交出控制器，宿主才能获得控制权并将控制权交给其他coroutine</p><p>goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。</p><p>coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。</p><p>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p><h2 id="Go语言通道-chan"><a href="#Go语言通道-chan" class="headerlink" title="Go语言通道(chan)"></a>Go语言通道(chan)</h2>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记7-包(package)</title>
      <link href="/2019/03/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-%E5%8C%85-package/"/>
      <url>/2019/03/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-%E5%8C%85-package/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>终于学到包了，前面有忘得差不多了，特别是接口，晕晕乎乎的，期待学完之后的项目实战</p><p>Go 语言的源码复用建立在包(package) 基础之上。Go 语言的入口main() 函数所在的包叫main，main 包想要引用别的代码，必须同样以包的方式进行。</p><p>Go 于洋的包与文件夹一一对应，所有与包相关的操作，必须依赖工作目录（GOPATH）</p><h2 id="GOPATH详解"><a href="#GOPATH详解" class="headerlink" title="GOPATH详解"></a>GOPATH详解</h2><p>GOPATH 是Go 语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  go env // 执行 go env 指令，将输出当前 Go 开发包的环境变量状态。 </span><br><span class="line">GOARCH="amd64" // GOARCH 表示目标处理器架构</span><br><span class="line">GOBIN="" // GOBIN 表示编译器和链接器的安装位置。 </span><br><span class="line">GOCACHE="/Users/zhimma/Library/Caches/go-build"</span><br><span class="line">GOEXE=""</span><br><span class="line">GOFLAGS=""</span><br><span class="line">GOHOSTARCH="amd64"</span><br><span class="line">GOHOSTOS="darwin"</span><br><span class="line">GOOS="darwin" // GOOS 表示目标操作系统 </span><br><span class="line">GOPATH="/Users/zhimma/go" // GOPATH 表示当前工作目录</span><br><span class="line">GOPROXY=""</span><br><span class="line">GORACE=""</span><br><span class="line">GOROOT="/usr/local/go" // GOROOT 表示 Go 开发包的安装目录</span><br><span class="line">GOTMPDIR=""</span><br><span class="line">GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"</span><br><span class="line">GCCGO="gccgo"</span><br><span class="line">CC="clang"</span><br><span class="line">CXX="clang++"</span><br><span class="line">CGO_ENABLED="1"</span><br><span class="line">GOMOD=""</span><br><span class="line">CGO_CFLAGS="-g -O2"</span><br><span class="line">CGO_CPPFLAGS=""</span><br><span class="line">CGO_CXXFLAGS="-g -O2"</span><br><span class="line">CGO_FFLAGS="-g -O2"</span><br><span class="line">CGO_LDFLAGS="-g -O2"</span><br><span class="line">PKG_CONFIG="pkg-config"</span><br></pre></td></tr></table></figure><p>在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。</p><table><thead><tr><th>平  台</th><th>GOPATH 默认值</th><th>举 例</th></tr></thead><tbody><tr><td>Windows 平台</td><td>%USERPROFILE%/go</td><td>C:\Users\用户名\go</td></tr><tr><td>Unix 平台</td><td>$HOME/go</td><td>/home/用户名/go</td></tr></tbody></table><h3 id="使用GOPATH的工程结构"><a href="#使用GOPATH的工程结构" class="headerlink" title="使用GOPATH的工程结构"></a>使用GOPATH的工程结构</h3><p>在GOPATH 指定的工作目录下，代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过go build、go install或者go get 等指令后，会将产生的二进制可执行文件放在<code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code>下。</p><p>如果需要将整个源码添加到版本管理工具中时，只需要添加 <code>$GOPATH/src</code> 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</p><h3 id="设置和使用GOPATH"><a href="#设置和使用GOPATH" class="headerlink" title="设置和使用GOPATH"></a>设置和使用GOPATH</h3><p>下面以Linux为例进行演示</p><h4 id="设置当前目录为GOPATH"><a href="#设置当前目录为GOPATH" class="headerlink" title="设置当前目录为GOPATH"></a>设置当前目录为GOPATH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br></pre></td></tr></table></figure><h4 id="建立GOPATH中的源码目录"><a href="#建立GOPATH中的源码目录" class="headerlink" title="建立GOPATH中的源码目录"></a>建立GOPATH中的源码目录</h4><p>使用下面指令创建GOPATH中的src 目录，在src目录下还有一个hello目录，该目录用于保存源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/hello</span><br></pre></td></tr></table></figure><h4 id="添加main-go源码文件"><a href="#添加main-go源码文件" class="headerlink" title="添加main.go源码文件"></a>添加main.go源码文件</h4><p>使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 $GOPATH/src/hello 目录下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译源码并运行"><a href="#编译源码并运行" class="headerlink" title="编译源码并运行"></a>编译源码并运行</h4><p>此时我们已经设定了 GOPATH，因此在 Go 语言中可以通过 GOPATH 找到工程的位置。</p><p>在命令行中执行如下指令编译源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install hello</span><br></pre></td></tr></table></figure><p>编译完成的可执行文件会保存在 $GOPATH/bin 目录下。</p><p>在 bin 目录中执行 ./hello，命令行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="package-创建包"><a href="#package-创建包" class="headerlink" title="package(创建包)"></a>package(创建包)</h2><p>包 是多个Go 源码的集合，是一种高级的代码复用方案，Go 语言默认为我们提供了很多包，如fmt、os、io包等。</p><p>包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>包的特性如下：</p><ul><li>一个目录下的同级文件归属一个包。</li><li>包名可以与其目录不同名。</li><li>包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。</li></ul><h2 id="包中的标识符"><a href="#包中的标识符" class="headerlink" title="包中的标识符"></a>包中的标识符</h2><p>如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的<strong>首字母大写</strong>就可以让引用者可以访问这些标识符了。</p><h2 id="import-导入包"><a href="#import-导入包" class="headerlink" title="import 导入包"></a>import 导入包</h2><p>要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用<code>/</code>进行路径分隔。</p><h3 id="默认导入的写法"><a href="#默认导入的写法" class="headerlink" title="默认导入的写法"></a>默认导入的写法</h3><p>导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的</p><h4 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h4><p>单行导入格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包2"</span></span><br></pre></td></tr></table></figure><h4 id="2-多行导入"><a href="#2-多行导入" class="headerlink" title="2) 多行导入"></a>2) 多行导入</h4><p>当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"包1"</span></span><br><span class="line">    <span class="string">"包2"</span></span><br><span class="line">    …</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="导入包后自定义引用的包名"><a href="#导入包后自定义引用的包名" class="headerlink" title="导入包后自定义引用的包名"></a>导入包后自定义引用的包名</h3><p>在默认导入包的基础上，在导入包路径前添加标识符即可形成自定义引用包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customName <span class="string">"path/to/package"</span></span><br></pre></td></tr></table></figure><p>其中，path/to/package 为要导入的包路径，customName 为自定义的包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    renameLib <span class="string">"chapter08/importadd/mylib"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(renameLib.Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h3><p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"path/to/package"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，path/to/package 表示要导入的包名，下画线<code>_</code>表示匿名导入包。</p><p>匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。</p><h3 id="包在程序启动前的初始化入口：init"><a href="#包在程序启动前的初始化入口：init" class="headerlink" title="包在程序启动前的初始化入口：init"></a>包在程序启动前的初始化入口：init</h3><p>在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。</p><p>init() 函数的特性如下：</p><ul><li>每个源码可以使用 1 个 init() 函数。</li><li>init() 函数会在程序执行前（main() 函数执行前）被自动调用。</li><li>调用顺序为 main() 中引用的包，以深度优先顺序初始化。</li></ul><p>例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.init→B.init→A.init→main</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>同一个包中的多个 init() 函数的调用顺序不可预期。</li><li>init() 函数不能被其他函数调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记6-接口</title>
      <link href="/2019/03/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/03/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p><p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p><p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p><h2 id="Go语言接口声明定义"><a href="#Go语言接口声明定义" class="headerlink" title="Go语言接口声明定义"></a>Go语言接口声明定义</h2><p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p><h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成，接口的形式代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名<span class="number">1</span>(参数列表<span class="number">1</span>) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>(参数列表<span class="number">2</span>) 返回值列表<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各个部分的说明：</p><ul><li><p>接口类型名： 使用 type 将接口定义为自定义的类型名。Go 语言在接口命名时，一并会在单词后面添加 <strong>er</strong>，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer…</p></li><li><p>方法名： 当方法名首字母大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问</p></li><li><p>参数列表、返回值列表： 参数列表和返回值列表中的参数变量名可以被忽略，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发中常见接口及写法"><a href="#开发中常见接口及写法" class="headerlink" title="开发中常见接口及写法"></a>开发中常见接口及写法</h3><p>Go 语言提供的很多包中都有接口，例如 io 包中提供的Writer 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口可以调用 Write() 方法写入一个字节数组([]byte)，返回值告知写入字节数（n int）和可能发生的错误（err error）</p><h2 id="Go语言实现接口的条件"><a href="#Go语言实现接口的条件" class="headerlink" title="Go语言实现接口的条件"></a>Go语言实现接口的条件</h2><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用</p><h3 id="条件一：接口的方法与实现接口的类型方式格式一致"><a href="#条件一：接口的方法与实现接口的类型方式格式一致" class="headerlink" title="条件一：接口的方法与实现接口的类型方式格式一致"></a>条件一：接口的方法与实现接口的类型方式格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该接口。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><p>数据写入器的抽象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，入参接收interface&#123;&#125; 类型的 data，返回一个 error 结构表示可能发生的错误</span></span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="comment">// file 的 WriteData() 方法使用指针接收器。输入一个 interface&#123;&#125; 类型的 data，返回 error。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *file)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"实现了DataWriter接口的WriteData方法"</span> , data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化结构file</span></span><br><span class="line"><span class="comment">// 实例化 file 赋值给 f，f 的类型为 *file。</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter类型的writer接口变量</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口复赋值给f，也就是*file类型</span></span><br><span class="line">    <span class="comment">// 将 *file 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">writer.WriteData(<span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p><h4 id="1-函数名不一致导致的报错"><a href="#1-函数名不一致导致的报错" class="headerlink" title="1) 函数名不一致导致的报错"></a>1) 函数名不一致导致的报错</h4><h4 id="2-实现接口的方法签名不一致导致的报错"><a href="#2-实现接口的方法签名不一致导致的报错" class="headerlink" title="2) 实现接口的方法签名不一致导致的报错"></a>2) 实现接口的方法签名不一致导致的报错</h4><h3 id="条件二：接口中所有方法均被实现"><a href="#条件二：接口中所有方法均被实现" class="headerlink" title="条件二：接口中所有方法均被实现"></a>条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p><p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    <span class="comment">// 能否写入</span></span><br><span class="line">    CanWrite() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (<span class="keyword">type</span> *file) as <span class="keyword">type</span> DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></table></figure><p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p><p>Go 语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p><p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p><h2 id="Go语言类型与接口的关系"><a href="#Go语言类型与接口的关系" class="headerlink" title="Go语言类型与接口的关系"></a>Go语言类型与接口的关系</h2><p>类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。</p><h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口见彼此独立，不知道对方的实现</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p><p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p><p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Socket 结构的Write方法实现了io.Writer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时，Socket 结构也实现了 io.Close 接口：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6100I14b.jpg" alt=""></p><p>在代码中使用Socket结构实现的Writer接口和Closer接口代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingWriter</span><span class="params">(writer io.Writer)</span></span> &#123;</span><br><span class="line">writer.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingCloser</span><span class="params">(closer io.Closer)</span></span> &#123;</span><br><span class="line">closer.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(Socket)</span><br><span class="line">usingWriter(s)</span><br><span class="line">usingCloser(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个服务需要满足能够开启和写日志的功能</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()  <span class="comment">// 开启服务</span></span><br><span class="line">    Log(<span class="keyword">string</span>)  <span class="comment">// 日志输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日志器 定义能输出日志的日志器结构。</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(l <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 GameService 结构。</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">    Logger  <span class="comment">// 在 GameService 中嵌入 Logger 日志器，以实现日志功能。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Service的Start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Service = <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></table></figure><p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>Go语言中不同结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口</p><p>接口与接口嵌套组合而成了新接口，只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用</p><h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go 语言的io 包中定义写入器（Writer）、关闭器（Closer）和写入关闭器（WriteClose）3个接口，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriterCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</span></span><br><span class="line"><span class="keyword">var</span> wc io.WriteCloser = <span class="built_in">new</span>(device)</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">wc.Write(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeOnly io.Writer = <span class="built_in">new</span>(device)</span><br><span class="line"></span><br><span class="line">writeOnly.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) io.WriteCloser的实现及调用过程如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ61125141Z.jpg" alt="img"></p><p>2) io.Writer 的实现调用过程如图 2 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6112952232.jpg" alt="img"></p><p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记5-结构体</title>
      <link href="/2019/03/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2019/03/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型<br>Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性</p><p>Go 语言中的类型可以被实例化，使用<code>new</code> 或<code>&amp;</code>构造的类型实例的类型是类型的指针</p><p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p><ul><li>字段拥有自己的类型和值</li><li>字段名必须唯一</li><li>字段的类型也可以是结构体，甚至是字段所在结构体的类型</li></ul><p><strong>关于 Go 语言的类(class)</strong></p><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p><p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的<strong>内嵌</strong>配合<strong>接口</strong>比面向对象具有更高的扩展性和灵活性。</p><p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法</p><h2 id="Go-语言结构体定义"><a href="#Go-语言结构体定义" class="headerlink" title="Go 语言结构体定义"></a>Go 语言结构体定义</h2><p>Go 语言的关键字<strong>type</strong> 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使用结构体更便于使用</p><p>结构体的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">    xx, yy <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言实例化结构体-结构体分配内存并初始化"><a href="#Go语言实例化结构体-结构体分配内存并初始化" class="headerlink" title="Go语言实例化结构体-结构体分配内存并初始化"></a>Go语言实例化结构体-结构体分配内存并初始化</h3><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。因此必须在定义结构体并实例化后才能使用结构体的字段</p><p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的</p><p>Go 语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p><h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整形、字符串等类型一样，以var 的方式声明结构体即可完成实例化</p><p>基本实例化格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ins T</span><br></pre></td></tr></table></figure><p>其中，T 为结构体类型，ins 为结构体的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p point</span><br><span class="line">p.x = <span class="number">10</span></span><br><span class="line">p.y = <span class="number">20</span></span><br><span class="line">fmt.Println(p) <span class="comment">// &#123;10 20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针类型的结构体"><a href="#指针类型的结构体" class="headerlink" title="指针类型的结构体"></a>指针类型的结构体</h3><p>Go 语言中，还可以使用 new 关键字对类型（包括结构体、整形。浮点数。字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体</p><p>使用new 的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 为类型，可以是结构体、整形、字符串等</li><li>ins ：T 类型被实例化后保存到ins 变量中，ins 的类型为 *T，属于指针</li></ul><p>Go 语言让我们可以像访问普通结构体一样使用<code>.</code>访问结构体指针的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">Name        <span class="keyword">string</span></span><br><span class="line">HealthPoint <span class="keyword">int</span></span><br><span class="line">MagicPoint  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">factory := <span class="built_in">new</span>(Player)</span><br><span class="line">factory.Name = <span class="string">"鲁班"</span></span><br><span class="line">factory.HealthPoint = <span class="number">300</span></span><br><span class="line">fmt.Println(factory) <span class="comment">// &amp;&#123;鲁班 300 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p><blockquote><p>在 Go 语言中，访问结构体指针的成员变量时可以继续使用<code>.</code>。这是因为 Go 语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。</p></blockquote><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <strong>&amp;</strong> 取地址操作时，视为对该类型进行一次new 的实例化操作，取地址格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 表示结构体类型</li><li>ins 为结构体的实例，类型为 <strong>*T</strong> ，是指针类型</li></ul><p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等。对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span>    <span class="comment">// 指令名称</span></span><br><span class="line">    Var     *<span class="keyword">int</span>    <span class="comment">// 指令绑定的变量</span></span><br><span class="line">    Comment <span class="keyword">string</span>    <span class="comment">// 指令的注释</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">cmd := &amp;Command&#123;&#125;</span><br><span class="line">cmd.Name = <span class="string">"version"</span></span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = <span class="string">"show version"</span></span><br></pre></td></tr></table></figure><p>取地址实例化是最广泛的一种结构体实例化方式。可以使用函数封装上面的初始化过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCommand</span><span class="params">(name <span class="keyword">string</span>, varref *<span class="keyword">int</span>, comment <span class="keyword">string</span>)</span> *<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Command&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cmd = newCommand(</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Go语言初始化结构体的成员变量"><a href="#Go语言初始化结构体的成员变量" class="headerlink" title="Go语言初始化结构体的成员变量"></a>Go语言初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化。初始化有两种形式：</p><ol><li>字段“键值对”形式</li><li>多个值的列表形式</li></ol><p>键值对形式的初始化适合选择性填充字段较多的结构体；</p><p>多个值的列表形式适合填充字段较少的结构体</p><h3 id="使用键值对初始化结构体"><a href="#使用键值对初始化结构体" class="headerlink" title="使用键值对初始化结构体"></a>使用键值对初始化结构体</h3><p>结构体可以使用<strong>键值对</strong>初始化字段，每个键对应结构体中的一个字段。键的值对应字段需要初始化的值,键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中</p><p>结构体实例化后字段的默认值是字段类型的默认值。例如：数值为 0，字符串为空字符串，布尔为 false，指针为 nil 等</p><h4 id="键值对初始化结构体格式"><a href="#键值对初始化结构体格式" class="headerlink" title="键值对初始化结构体格式"></a>键值对初始化结构体格式</h4><p>如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名&#123;</span><br><span class="line">    字段<span class="number">1</span>: 字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>：字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>结构体类型：定义结构体时的类型名称。</li><li>字段1、字段2：结构体的成员字段名。结构体类型名的字段初始化列表中，字段名只能出现一次。</li><li>字段1的值、字段2的值：结构体成员字段的初始值。</li></ul><blockquote><p>键值之间以<code>:</code>分隔；键值对之间以<code>,</code>分隔。</p></blockquote><h4 id="键值对初始化结构体的例子"><a href="#键值对初始化结构体的例子" class="headerlink" title="键值对初始化结构体的例子"></a>键值对初始化结构体的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    child *People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relation := &amp;People&#123;</span><br><span class="line">    name: <span class="string">"爷爷"</span>,</span><br><span class="line">    child: &amp;People&#123;</span><br><span class="line">        name: <span class="string">"爸爸"</span>,</span><br><span class="line">        child: &amp;People&#123;</span><br><span class="line">            name: <span class="string">"孩子"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</p></blockquote><h3 id="使用多个值得列表初始化结构体"><a href="#使用多个值得列表初始化结构体" class="headerlink" title="使用多个值得列表初始化结构体"></a>使用多个值得列表初始化结构体</h3><p>Go 语言可以在键值对初始化的基础上忽略键，也就是说，可以使用多个值的列表初始化结构体的字段</p><h4 id="多个值列表初始化结构体的书写格式"><a href="#多个值列表初始化结构体的书写格式" class="headerlink" title="多个值列表初始化结构体的书写格式"></a>多个值列表初始化结构体的书写格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体名&#123;</span><br><span class="line">    字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ul><li>必须初始化结构体的所有字段</li><li>每一个初始值得填充顺序必须与结构体中的声明顺序一致</li><li>键值对与值列表的初始化形式不能混用</li></ul><h4 id="多个值列表初始化结构体的实例"><a href="#多个值列表初始化结构体的实例" class="headerlink" title="多个值列表初始化结构体的实例"></a>多个值列表初始化结构体的实例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province    <span class="keyword">string</span></span><br><span class="line">    City        <span class="keyword">string</span></span><br><span class="line">    ZipCode     <span class="keyword">int</span></span><br><span class="line">    PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">addr := Address&#123;</span><br><span class="line">    <span class="string">"四川"</span>,</span><br><span class="line">    <span class="string">"成都"</span>,</span><br><span class="line">    <span class="number">610000</span>,</span><br><span class="line">    <span class="string">"0"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(addr) <span class="comment">// &#123;四川 成都 610000 0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无需通过 <code>type</code>关键字定义就可以直接使用</p><h4 id="匿名结构体定义格式和初始化写法"><a href="#匿名结构体定义格式和初始化写法" class="headerlink" title="匿名结构体定义格式和初始化写法"></a>匿名结构体定义格式和初始化写法</h4><p>匿名结构体的初始化写法由<strong>结构体定义</strong>和<strong>键值对初始化</strong>两部分组成<br>结构体定义时没有结构体类型名，只有字段和字段类型的定义<br>键值对初始化部分由可选的多个键值对组成，如下格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>： 字段<span class="number">1</span>的值,</span><br><span class="line">    初始化字段<span class="number">2</span>： 字段<span class="number">2</span>的值,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用匿名结构体的例子"><a href="#使用匿名结构体的例子" class="headerlink" title="使用匿名结构体的例子"></a>使用匿名结构体的例子</h4><p>在本例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data）。打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 打印消息类型, 传入匿名结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsgType</span><span class="params">(msg *<span class="keyword">struct</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    id   <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用动词%T打印msg的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">    msg := &amp;<span class="keyword">struct</span> &#123;  <span class="comment">// 定义部分</span></span><br><span class="line">        id   <span class="keyword">int</span></span><br><span class="line">        data <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;  <span class="comment">// 值初始化部分</span></span><br><span class="line">        <span class="number">1024</span>,</span><br><span class="line">        <span class="string">"hello"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    printMsgType(msg) <span class="comment">// *struct &#123; id int; data string &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义 printMsgType() 函数，参数为 msg，类型为 *struct{id int data string}。因为类型没有使用 type 定义，所以需要在用到的地方每次进行定义。</li><li>第 11 行，使用字符串格式化中的<code>%T</code>动词，将 msg 的类型名打印出来。</li><li>第 15 行，对匿名结构体进行实例化，同时初始化成员。</li><li>第 16 和 17 行，定义匿名结构体的字段。</li><li>第 19 和 20 行，给匿名结构体字段赋予初始值。</li><li>第 22 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li></ul><blockquote><p>匿名结构体的类型名是结构体包含字段成员的详细描述。匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p></blockquote><h2 id="Go语言的构造函数"><a href="#Go语言的构造函数" class="headerlink" title="Go语言的构造函数"></a>Go语言的构造函数</h2><p>Go 语言的类型或结构体没有构造函数的功能，结构体的初始化过程可以使用函数封装实现</p><h3 id="TODO-没搞懂"><a href="#TODO-没搞懂" class="headerlink" title="TODO 没搞懂"></a>TODO 没搞懂</h3><h2 id="Go语言方法和接收器"><a href="#Go语言方法和接收器" class="headerlink" title="Go语言方法和接收器"></a>Go语言方法和接收器</h2><p>Go语言中的方法是一种作用于特定类型变量的函数。这种特定类型变量叫做<strong>接收器(Receiver)</strong></p><p>如果将特定类型理解为结构体或类时，接收器的概念就类似于其他语言中的 this 或者 self</p><p>在Go语言中，接收器的类型可以使任何类型，不仅仅是结构体，任何类型都可以拥有方法</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在 Go 语言中“方法”的概念与其他语言一致，只是 Go 语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</p><h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><h4 id="面向过程实现方法"><a href="#面向过程实现方法" class="headerlink" title="面向过程实现方法"></a>面向过程实现方法</h4><p>面向过程中没有方法 的概念，只能通过结构体和函数，有使用者使用函数参数和调用关系来形成接近方法的概念：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个物品放入背包的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(b *Bag, itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bag := <span class="built_in">new</span>(Bag)</span><br><span class="line">    Insert(bag, <span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert() 函数将 <em>Bag 参数放在第一位，强调 Insert 会操作 </em>Bag 结构体。但实际使用中，并不是每个人都会习惯将操作对象放在首位。一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念。随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p><h3 id="Go语言的结构体方法"><a href="#Go语言的结构体方法" class="headerlink" title="Go语言的结构体方法"></a>Go语言的结构体方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bag)</span> <span class="title">Insert</span><span class="params">(itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(Bag)</span><br><span class="line">    b.Insert(<span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法只能有一个接收器，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180815/1-1PQ5135I3337.jpg" alt=""></p><h3 id="接收器-方法作用的目标"><a href="#接收器-方法作用的目标" class="headerlink" title="接收器-方法作用的目标"></a>接收器-方法作用的目标</h3><p>接收器的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收器变量 接收器类型)</span> 方法名<span class="params">(参数列表)</span><span class="params">(返回参数)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各部分的说明：</p><ul><li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li><li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：格式与函数定义一致。</li></ul><p>接收器根据接收器的类型可以分为指针接收器、非指针接收器。两种接收器在使用时会产生不同的效果。根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p><h4 id="指针类型接收器"><a href="#指针类型接收器" class="headerlink" title="指针类型接收器"></a>指针类型接收器</h4><p>指针类型的接收器由一个结构体的指针组成，更接近与面向对象中的this 或者 self<br>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 定义属性结构</span></span><br><span class="line"><span class="keyword">type</span> Property <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span>  <span class="comment">// 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">SetValue</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改p的成员变量</span></span><br><span class="line">    p.value = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化属性</span></span><br><span class="line">    p := <span class="built_in">new</span>(Property)</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    p.SetValue(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 打印值</span></span><br><span class="line">    fmt.Println(p.Value()) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非指针类型接收器"><a href="#非指针类型接收器" class="headerlink" title="非指针类型接收器"></a>非指针类型接收器</h4><p>当方法作用于非指针接收器时，Go 语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义点结构</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非指针接收器的加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(other Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="comment">// 成员值与参数相加后返回新的结构</span></span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X + other.X, p.Y + other.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化点</span></span><br><span class="line">    p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// 与另外一个点相加</span></span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Println(result) <span class="comment">// &#123;3 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改</p><h4 id="指针和非指针接收器的使用"><a href="#指针和非指针接收器的使用" class="headerlink" title="指针和非指针接收器的使用"></a>指针和非指针接收器的使用</h4><p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器。大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p><h2 id="Go语言为任意类型添加方法"><a href="#Go语言为任意类型添加方法" class="headerlink" title="Go语言为任意类型添加方法"></a>Go语言为任意类型添加方法</h2><p>Go语言可以对任何类型添加方法。给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型</p><h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型。之后就可以为自定义类型添加各种方法。我们习惯于使用面向过程的方法判断一个值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 v 比作整型对象，那么判断 v 值就可以增加一个IsZero() 方法，通过这个方法就可以判断v 值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v.IsZero()&#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为基本类型添加方法的详细流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将int定义为MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 为MyInt添加IsZero()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为MyInt添加Add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">Add</span><span class="params">(other <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> other + <span class="keyword">int</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b MyInt = <span class="number">2</span></span><br><span class="line">    fmt.Println(b.IsZero()) <span class="comment">// false</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    fmt.Println(b.Add(<span class="number">2</span>)) <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言类型内嵌和结构体内嵌"><a href="#Go语言类型内嵌和结构体内嵌" class="headerlink" title="Go语言类型内嵌和结构体内嵌"></a>Go语言类型内嵌和结构体内嵌</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为<strong>类型内嵌</strong>或<strong>匿名字段类型内嵌</strong>，写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">ins := &amp;Data &#123;</span><br><span class="line">    <span class="keyword">int</span>: <span class="number">10</span>，</span><br><span class="line">    <span class="keyword">float32</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="keyword">bool</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型内嵌其实仍然拥有自己的字段名，只是字段名就是其类型本身而已，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个</p><p>结构体实例化后，如果匿名的字段类型为结构体，那么可以直接访问匿名结构体里的所有成员，这种方式被称为结<strong>构体内嵌</strong></p><h3 id="声明结构体内嵌"><a href="#声明结构体内嵌" class="headerlink" title="声明结构体内嵌"></a>声明结构体内嵌</h3><p>结构体类型内嵌比普通类型内嵌的概念复杂一些，下面通过一个实例来理解。</p><p>计算机图形学中的颜色有两种类型，一种是包含红、绿、蓝三原色的基础颜色；另一种是在基础颜色之外增加透明度的颜色。透明度在颜色中叫 Alpha，范围为 0～1 之间。0 表示完全透明，1 表示不透明。使用传统的结构体字段的方法定义基础颜色和带有透明度颜色的过程代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 基础颜色</span></span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 红、绿、蓝三种颜色分量</span></span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整颜色定义</span></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 将基本颜色作为成员</span></span><br><span class="line">    Basic BasicColor</span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    <span class="comment">// 设置基本颜色分量</span></span><br><span class="line">    c.Basic.R = <span class="number">1</span></span><br><span class="line">    c.Basic.G = <span class="number">1</span></span><br><span class="line">    c.Basic.B = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 设置透明度</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 显示整个结构体内容</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c) <span class="comment">// &#123;Basic:&#123;R:1 G:1 B:0&#125; Alpha:1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然合理但是写法很复杂。使用 Go 语言的结构体内嵌写法重新调整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    BasicColor</span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    c.R = <span class="number">1</span></span><br><span class="line">    c.G = <span class="number">1</span></span><br><span class="line">    c.B = <span class="number">0</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第14-16 行，可以直接对 Color 的 R、G、B 成员进行设置，编译器通过 Color 的定义知道 R、G、B 成员来自 BasicColor 内嵌的结构体。</p><h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go 语言的结构体内嵌有如下特性：</p><p><strong>1. 内嵌的结构体可以直接访问其成员变量</strong></p><p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p><p><strong>2. 内嵌结构体的字段名是它的类型名</strong></p><p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Color</span><br><span class="line">c.BasicColor.R = <span class="number">1</span></span><br><span class="line">c.BasicColor.G = <span class="number">1</span></span><br><span class="line">c.BasicColor.B = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p><h2 id="Go语言结构体内嵌模拟类的继承"><a href="#Go语言结构体内嵌模拟类的继承" class="headerlink" title="Go语言结构体内嵌模拟类的继承"></a>Go语言结构体内嵌模拟类的继承</h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p><p>Go 语言 的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p><p>下面的代码使用 Go 语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p><p>人和鸟的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 可飞行的</span></span><br><span class="line"><span class="keyword">type</span> Flying <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Flying)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can fly"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可行走的</span></span><br><span class="line"><span class="keyword">type</span> Walkable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Walkable)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can calk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 人类能行走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 鸟类能行走</span></span><br><span class="line">    Flying   <span class="comment">// 鸟类能飞行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化鸟类</span></span><br><span class="line">    b := <span class="built_in">new</span>(Bird)</span><br><span class="line">    fmt.Println(<span class="string">"Bird: "</span>)</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line">    <span class="comment">// 实例化人类</span></span><br><span class="line">    h := <span class="built_in">new</span>(Human)</span><br><span class="line">    fmt.Println(<span class="string">"Human: "</span>)</span><br><span class="line">    h.Walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></table></figure><p>使用 Go 语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go 语言会在编译时检查能否使用这些特性。</p><h2 id="Go语言初始化内嵌结构体"><a href="#Go语言初始化内嵌结构体" class="headerlink" title="Go语言初始化内嵌结构体"></a>Go语言初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p><p>车辆结构的组装和初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引擎</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    Power <span class="keyword">int</span>    <span class="comment">// 功率</span></span><br><span class="line">    Type  <span class="keyword">string</span> <span class="comment">// 类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Car&#123;</span><br><span class="line">        <span class="comment">// 初始化轮子</span></span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: <span class="number">18</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 初始化引擎</span></span><br><span class="line">        Engine: Engine&#123;</span><br><span class="line">            Type:  <span class="string">"1.4T"</span>,</span><br><span class="line">            Power: <span class="number">143</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化内嵌匿名结构体</strong></p><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要<strong>再次声明结构</strong>才能赋予数据。具体请参考下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct &#123;</span><br><span class="line">    Size int</span><br><span class="line">&#125;</span><br><span class="line">// 车</span><br><span class="line">type Car struct &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    // 引擎</span><br><span class="line">    Engine struct &#123;</span><br><span class="line">        Power int    // 功率</span><br><span class="line">        Type  string // 类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    c := Car&#123;</span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: 18,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: struct &#123;</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        &#125;&#123;</span><br><span class="line">            Type:  &quot;1.4T&quot;,</span><br><span class="line">            Power: 143,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记4-函数</title>
      <link href="/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p><p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul><li>函数本身可以作为值进行传递。</li><li>支持匿名函数和闭包（closure）。</li><li>函数可以满足接口。</li></ul><h2 id="Go语言函数声明-函数定义"><a href="#Go语言函数声明-函数定义" class="headerlink" title="Go语言函数声明(函数定义)"></a>Go语言函数声明(函数定义)</h2><p>普通函数需要先声明才能调用，一个函数的声明包含参数和函数名等，编译器通过声明才能了解函数应该怎样在调用代码和函数体之间传递参数和返回值</p><h3 id="普通函数的声明形式"><a href="#普通函数的声明形式" class="headerlink" title="普通函数的声明形式"></a>普通函数的声明形式</h3><p>Go语言的函数声明以<code>func</code>标识，后面紧接着函数名、参数列表、返回参数列表及函数体，具体形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对各个部分进行说明：</p><ul><li><p>函数名：由字母、数字、下划线组成。其中，函数名的第一个字母不能为数字，在同一个包内，函数名称不能重复</p><blockquote><p>包(package) 是Go源码的一种组织方式，一个包可以认为是一个文件夹</p></blockquote></li><li><p>参数列表：一个参数由参数变量和参数类型组成，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中，参数列表中的变量作为函数的局部变量而存在。</p></li><li><p>返回参数列表：可以是返回值类型列表，也可以是类似参数列表中变量名和类型名的组合。函数在声明有返回值时，必须在函数体中使用return 语句提供返回值列表</p></li><li><p>函数体：能够被重复调用的代码片段</p></li></ul><h3 id="参数类型的缩写"><a href="#参数类型的缩写" class="headerlink" title="参数类型的缩写"></a>参数类型的缩写</h3><p>在参数列表中，如果有多个参数变量，则以逗号<code>,</code>分隔；如果相邻变量时同类型，则可以将类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，a 和 b 的参数类型均是 int 类型，则可以省略 a 的类型，在 b 后面有类型说明，这个类型也是 a 的类型</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地取得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数中可能发生的错误。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToMysql()</span><br></pre></td></tr></table></figure><p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误。</p><p><strong>Go 语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</strong></p><h4 id="同一类型返回值"><a href="#同一类型返回值" class="headerlink" title="同一类型返回值"></a>同一类型返回值</h4><p>如果返回值是同一类型，则用括号将多个返回值类型括起来，用逗号分割每个返回值的类型</p><p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go 语言支持对返回值进行命名，这样返回值就可以和参数一样拥有参数变量名和类型</p><p>命名的返回值变量的默认值为类型的默认值，即数值为 0 ，字符串为空字符串，布尔值为false，指针为 nil 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p><p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p><p>Go语言的函数调用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>函数名：需要调用的函数名。</li><li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li><li>返回值变量列表：多个返回值使用逗号分隔。</li></ul><h3 id="函数示例-将秒转为具体时间"><a href="#函数示例-将秒转为具体时间" class="headerlink" title="函数示例-将秒转为具体时间"></a>函数示例-将秒转为具体时间</h3><p>在本例中，使用一个数值表示时间中的“秒”值，然后使用<code>resolveTime()</code>函数将传入的秒数转换为天、小时和分钟等时间单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SecondsPerMinute = <span class="number">60</span></span><br><span class="line"><span class="keyword">var</span> SecondsPerHour = <span class="number">60</span> * SecondsPerMinute</span><br><span class="line"><span class="keyword">var</span> SecondsPerDay = <span class="number">24</span> * SecondsPerHour</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(resolveTime(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">_, hour, minute := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">day, _, _ := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveTime</span><span class="params">(seconds <span class="keyword">int</span>)</span> <span class="params">(day, hour, minutes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">day = seconds / SecondsPerDay</span><br><span class="line">hour = seconds / SecondsPerHour</span><br><span class="line">minutes = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中传入参数和返回参数 在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用</p><h2 id="函数变量-把函数作为值保存到变量中"><a href="#函数变量-把函数作为值保存到变量中" class="headerlink" title="函数变量-把函数作为值保存到变量中"></a>函数变量-把函数作为值保存到变量中</h2><p>在Go语言中，函数也是一种类型，可以和其他类型一样被保存在变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span> = <span class="title">foo</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"foo func"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言匿名函数"><a href="#Go语言匿名函数" class="headerlink" title="Go语言匿名函数"></a>Go语言匿名函数</h2><p>Go 语言支持匿名函数，即在需要使用函数时在定义函数，匿名函数没有函数名，只有函数体，函数可以被作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式被传递</p><p>匿名函数经常被用于实现回调函数、闭包等</p><h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的定义就是没有名字的普通函数定义</p><h3 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h3><p>匿名函数可以在声明后调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Prinln(data) </span><br><span class="line">&#125;(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h3><p>匿名函数体可以被赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的用途非常广泛，匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p><h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现。用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line"></span><br><span class="line">    for _, v := range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数作为回调函数的设计在 Go 语言的系统包中也比较常见，strings 包中就有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string &#123;</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言函数类型实现接口"><a href="#Go语言函数类型实现接口" class="headerlink" title="Go语言函数类型实现接口"></a>Go语言函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将分别对比<strong>结构体</strong>与<strong>函数</strong>实现<code>接口</code>的过程。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h2 id="Go语言闭包"><a href="#Go语言闭包" class="headerlink" title="Go语言闭包"></a>Go语言闭包</h2><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此简单的说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></table></figure><p>一个函数类型就像结构体一样，可以被实例化。函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期静态的概念，而闭包是运行期动态的概念。</p><h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上的变量的引用可以进行修改，修改引用的变量就会对变量进行实际的修改。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">fmt.Println(str); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个累加器，初始值1</span></span><br><span class="line">value := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(value()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(value()) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span> , value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个累加器，初始值为1</span></span><br><span class="line">otherValue := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(otherValue()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>value 与 otherValue的函数地址不同，因此它们是两个不同的闭包实例</p></blockquote><p>闭包的记忆效应进程被用于实现类似于设计模式中工厂模式的生成器。</p><h2 id="Go语言可变参数-变参函数"><a href="#Go语言可变参数-变参函数" class="headerlink" title="Go语言可变参数(变参函数)"></a>Go语言可变参数(变参函数)</h2><p>所谓可变参数，是指参数数量不固定的函数形式。<br>Go语言支持可变参数特性，函数声明和调用时没有固定数量的参数，同时也提供了一套方法进行可变参数的多级传参</p><p>Go语音的可变参数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(固定参数列表，v ... T)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数一般被放置在函数列表的末尾，前面是固定参数列表，当没有固定参数时，所有变量将是可变参数</li><li>v 为可变参数变量，类型为<code>[]T</code>,也就是拥有多个T 元素的 T 类型的切片v 和 T 之前由<code>...</code>组成</li><li>T 为可变参数的类型，当T 为<code>interface{}</code>时，传入的可以使任意类型</li></ul><h3 id="fmt包中的例子"><a href="#fmt包中的例子" class="headerlink" title="fmt包中的例子"></a>fmt包中的例子</h3><p>可变参数有两种类型：所有参数都是可变参数的形式，如<code>fmt.Println</code>,以及部分是可变参数的形式，如 <code>fmt.Printf</code>，可变参数只能出现在参数的后半部分，因此不可变的参数只能放在参数的前半部分。</p><h4 id="所有参数都是可变参数：fmt-Println"><a href="#所有参数都是可变参数：fmt-Println" class="headerlink" title="所有参数都是可变参数：fmt.Println"></a>所有参数都是可变参数：fmt.Println</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Println</code> 在使用时，传入的值类型不收限制，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"string"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="部分参数是可变参数：-fmt-Printf"><a href="#部分参数是可变参数：-fmt-Printf" class="headerlink" title="部分参数是可变参数： fmt.Printf"></a>部分参数是可变参数： fmt.Printf</h4><p><code>fmt.Printf</code> 的第一个参数为参数列表， 后面的参数是可变参数，<code>fmt.Printf</code>函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Printf()</code> 函数在调用时，第一个函数始终必须传入字符串，对应参数是 format，后面的参数数量可以变化</p><h2 id="Go语音defer-延迟执行语句"><a href="#Go语音defer-延迟执行语句" class="headerlink" title="Go语音defer(延迟执行语句)"></a>Go语音defer(延迟执行语句)</h2><p>Go语音的defer 语句会将其后面跟随的语句进行延迟处理。<br>在defer 归属的函数即将返回时，将延迟处理的语句按defer 的逆序进行执行，也就是说，先被defer 的语句最后执行，最后defer 的语句，最后被执行</p><h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"第一行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第二行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第三行"</span>)</span><br><span class="line">fmt.Println(<span class="string">"最后一行"</span>)</span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 最后一行</span></span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure><ul><li>代码的延迟顺序与最终执行顺序是反向的</li><li>延迟调用是在 defer 所在函数结束时执行，函数结束可以是正常返回，也可以是出错时返回</li></ul><h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较繁琐的事情，比如打开和关闭文件、和解锁接受请求和回复请求、加锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p><p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理释放资源的问题</p><h4 id="使用-defer-延迟释放资源"><a href="#使用-defer-延迟释放资源" class="headerlink" title="使用 defer 延迟释放资源"></a>使用 defer 延迟释放资源</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟调用close ，此时close 不会被调用</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">info , err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">size := info.Size()</span><br><span class="line"><span class="comment">// defer 机制触发，调用close关闭文件</span></span><br><span class="line"><span class="keyword">return</span>  size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源</p></blockquote><h2 id="Go语言处理运行时错误"><a href="#Go语言处理运行时错误" class="headerlink" title="Go语言处理运行时错误"></a>Go语言处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p><ul><li><p>一个可能造成错误的函数，需要返回值中返回一个错误接口(error) 。如果调用是成功的，错误接口将返回<code>nil</code> , 否则返回错误</p></li><li><p>在函数调用后需要检查错误，如果发生错误，需要进行必要的错误处理</p></li></ul><p>Go 语言没有类似 Java或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做。Go 语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源。同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p><p>Go 语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数。同时，Go 语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p><h2 id="Go语言宕机-panic-，程序终止执行"><a href="#Go语言宕机-panic-，程序终止执行" class="headerlink" title="Go语言宕机(panic)，程序终止执行"></a>Go语言宕机(panic)，程序终止执行</h2><h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go 语言中可以在程序中手动触发宕机，让程序崩溃，这样使开发者可以及时的发现错误，同时减少可能的损失</p><p>Go 语言宕机时，会将堆栈和goroutine 信息输出到控制台，所以宕机也可以方便的知晓发生错误的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crash"</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:4 +0x39</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>panic() 的参数可以是任意类型，后文将提到的 <code>recover</code> 参数会接收从 panic() 中发出的内容。</p><h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当<code>panic()</code> 触发的宕机发生时， <code>panic()</code> 后面的代码将不会被运行，但是在 <code>panic()</code> 函数前面已经运行的<code>defer</code>语句依然会在宕机时发生作用，例如下面的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后执行的事情1"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crash"</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">宕机后执行的事情1</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:8 +0xf1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宕机时，defer 语句会优先被执行</p><p><u><strong>测试了下，结果好像不一定，有时候先panic,有时候先defer，以后了解了再来补充吧</strong></u></p><h2 id="Go语言恢复-recover-宕机-防止程序崩溃"><a href="#Go语言恢复-recover-宕机-防止程序崩溃" class="headerlink" title="Go语言恢复(recover)宕机,防止程序崩溃"></a>Go语言恢复(recover)宕机,防止程序崩溃</h2><p>无论是代码运行错误，还是由<strong>Runtime</strong>层抛出的 panic 奔溃，还是主动出发的 panic 奔溃，都可以配合<strong>defer</strong> 和 <strong>recover</strong> 实现错误捕捉和恢复，让代码在发生奔溃后允许继续运行</p><p>在其他语言中，宕机往往以异常的形式存在。底层抛出异常，上层逻辑通过 <strong>try/catch</strong> 机制捕获异常，没有被捕获的严重异常会导致宕机，不活的异常可以被忽略，让代码继续运行</p><p>Go 语言没有异常系统，其使用 panic 触发宕机类似其他语言的抛出异常，那么 <strong>recover</strong>  的宕机恢复机制就是对应的 <strong>try/catch</strong> 机制</p><h3 id="让程序崩溃时继续执行"><a href="#让程序崩溃时继续执行" class="headerlink" title="让程序崩溃时继续执行"></a>让程序崩溃时继续执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> panicContext <span class="keyword">struct</span> &#123;</span><br><span class="line">function <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"开始运行"</span>)</span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"手动宕机前-----"</span>)</span><br><span class="line"><span class="built_in">panic</span>((&amp;panicContext&#123;</span><br><span class="line"><span class="string">"手动触发panic"</span>,</span><br><span class="line">&#125;))</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"手动宕机后"</span>)</span><br><span class="line"></span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"赋值宕机前"</span>)</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"赋值宕机后"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"结束宕机"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverDemo</span><span class="params">(entry <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 发生宕机时，获取panic传递的上下文并打印</span></span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> runtime.Error: <span class="comment">// 运行时错误</span></span><br><span class="line">fmt.Println(<span class="string">"runtime error"</span>, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"error"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">entry()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始运行</span><br><span class="line">手动宕机前-----</span><br><span class="line">error &amp;&#123;手动触发panic&#125;</span><br><span class="line">手动宕机后</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">结束宕机</span><br></pre></td></tr></table></figure><h3 id="panic和recover的关系"><a href="#panic和recover的关系" class="headerlink" title="panic和recover的关系"></a>panic和recover的关系</h3><p>panic 和 defer 的组合有如下特性：</p><ul><li>有 panic 没 recover，程序宕机。</li><li>有 panic 也有 recover 捕获，程序不会宕机。执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li></ul><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>虽然 panic/recover 能模拟其他语言的异常机制，但并不建议代表编写普通函数也经常性使用这种特性。</p><p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛直到程序整体崩溃。</p><p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记3-流程控制</title>
      <link href="/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p> Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else (分支结构)"></a>if else (分支结构)</h2><p>在Go语言中可以通过 if 关键字进行条件判断，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p></blockquote><h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connect 是一个带有返回值的函数，<code>err:=Connect()</code> 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p><p><code>err！=nil</code>才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Go语言中所有的循环类型均可以使用for 关键字来完成</p><p>基于语句和表达式的基本for 循环格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束表达式&#123;</span><br><span class="line">    循环体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环体不停地进行循环，直到条件表达式返回 false 时自动退出循环，执行 for 的<code>}</code>之后的语句</p></blockquote><p>for 循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code> 语句强制退出循环。for 的初始语句、条件表达式、结束语句的详细介绍如下。</p><h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其<strong><u>作用域</u></strong>将被局限在这个for 的范畴内</p><p>注意：初始语句可以被忽略，但是初始语句之后的分号必须填写，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; step &gt; <span class="number">0</span>; step-- &#123;</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p><h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>对每次循环开始前计算的表达式，如果表达式为true ,则循环继续，否则结束循环，条件表达式可以被忽略，被忽律条件的条件表达式默认形成无限循环</p><h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无线循环"><a href="#无线循环" class="headerlink" title="无线循环"></a>无线循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p><h3 id="Demo-九九乘法表"><a href="#Demo-九九乘法表" class="headerlink" title="Demo 九九乘法表"></a>Demo 九九乘法表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">1</span>; y &lt;= x; y++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*%d=%d "</span>, x, y, x*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1 </span><br><span class="line">2*1=2 2*2=4 </span><br><span class="line">3*1=3 3*2=6 3*3=9 </span><br><span class="line">4*1=4 4*2=8 4*3=12 4*4=16 </span><br><span class="line">5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 </span><br><span class="line">6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 </span><br><span class="line">7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 </span><br><span class="line">8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 </span><br><span class="line">9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81</span><br></pre></td></tr></table></figure><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>Go 语言可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong> 及<strong>通道（channel）</strong>。通过 <code>for range</code>遍历的返回值有一定的规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map 返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><h3 id="遍历数组、切片——获得索引和元素"><a href="#遍历数组、切片——获得索引和元素" class="headerlink" title="遍历数组、切片——获得索引和元素"></a>遍历数组、切片——获得索引和元素</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值。下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">fmt.Println(key, <span class="string">"=&gt;"</span>, value)</span><br><span class="line"><span class="comment">// 0 =&gt; 1</span></span><br><span class="line"><span class="comment">// 1 =&gt; 2</span></span><br><span class="line"><span class="comment">// 2 =&gt; 3</span></span><br><span class="line"><span class="comment">// 3 =&gt; 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历字符串——获得索引和元素"><a href="#遍历字符串——获得索引和元素" class="headerlink" title="遍历字符串——获得索引和元素"></a>遍历字符串——获得索引和元素</h3><p>Go 语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引（base0）和字符串中的每一个字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好，zhimma"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"key:%d value:0x%x\n"</span>, key, value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">key:0 value:0x4f60 type:int32</span></span><br><span class="line"><span class="comment">            key:3 value:0x597d type:int32</span></span><br><span class="line"><span class="comment">            key:6 value:0xff0c type:int32</span></span><br><span class="line"><span class="comment">            key:9 value:0x7a type:int32</span></span><br><span class="line"><span class="comment">            key:10 value:0x68 type:int32</span></span><br><span class="line"><span class="comment">            key:11 value:0x69 type:int32</span></span><br><span class="line"><span class="comment">            key:12 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:13 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:14 value:0x61 type:int32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 变量，实际类型是 rune，实际上就是 int32，以十六进制打印出来就是字符的编码。</p><h3 id="遍历map——获得map的键和值"><a href="#遍历map——获得map的键和值" class="headerlink" title="遍历map——获得map的键和值"></a>遍历map——获得map的键和值</h3><p>对于 map 类型来说，<code>for range</code> 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们总是一对一对的出现。下面的代码演示了如何遍历 map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> family &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, key, value)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</p></blockquote><h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p><code>for range</code>可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h2><p>分支选择可以理解为一种批量的if语句，使用 switch 语句可方便地对大量的值进行判断。</p><p>在 Go 语言中的 switch，不仅可以基于常量进行判断，还可以基于表达式进行判断。</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go 语言改进了 switch 的语法设计，避免人为造成失误。Go 语言的 switch 中的每一个 case 与 case 间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"other"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"other"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，每个case 均是字符串格式，且使用了default 分支，Go语言规定每个 switch 只能有一个default 分支</p><h5 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h5><p>当出现多个 case 要放在一起的时候，可以像下面代码这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"mum"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mum"</span> , <span class="string">"dad"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"family"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不通的 case 表达式使用逗号分隔</p></blockquote><h5 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h5><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num &lt; <span class="number">20</span> || num &gt; <span class="number">20</span>:</span><br><span class="line">fmt.Println(<span class="string">"num value is "</span>, num)</span><br><span class="line"><span class="comment">// num value is  10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况的 switch 后面不再跟判断变量，连判断的目标都没有了。</p></blockquote><h2 id="goto-语句——跳转到指定的标签"><a href="#goto-语句——跳转到指定的标签" class="headerlink" title="goto 语句——跳转到指定的标签"></a>goto 语句——跳转到指定的标签</h2><p>goto 语句通过标签进行代码间的无条件跳转。goto 语句可以在快速跳出循环、避免重复退出上有一定帮助，使用 goto 语句能简化一些代码的实现过程。</p><h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>多层循环中，传统方式退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breakAgain <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 外循环</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="comment">// 内循环</span></span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="comment">// 满足某个条件时, 退出循环</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 设置退出标记</span></span><br><span class="line">                breakAgain = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 退出本次循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记, 还需要退出一次循环</span></span><br><span class="line">        <span class="keyword">if</span> breakAgain &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 goto方式优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到标签</span></span><br><span class="line">                <span class="keyword">goto</span> breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动返回, 避免执行进入标签</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第13行 ：标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 16 行代码。</p><p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p><h3 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><p>使用 goto 语句实现上面同样的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break (跳出循环)"></a>break (跳出循环)</h2><p>break 语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>代码块。break 语句还可以在语句后面添加标签，表示退出摸个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和<code>select</code>的代码块上</p><p>下面看下跳出指定循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">fmt.Println(i , j)</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 1 行，外层循环的标签。</li><li>第 2 行和第 3 行，双层循环。</li><li>第 5 行，使用 switch 进行数值分支判断。</li><li>第 8 和第 11 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 1 行。</li></ul><h2 id="continue-中断本次循环，继续下一次循环"><a href="#continue-中断本次循环，继续下一次循环" class="headerlink" title="continue(中断本次循环，继续下一次循环)"></a>continue(中断本次循环，继续下一次循环)</h2><p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用</p><p>在 continue 语句后添加标签时，表示开始标签对应的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OuterLoops:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">continue</span> OuterLoops</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>第 7 行将结束当前循环，开启下一次的外层循环，而不是第 3 行的循环。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记2-容器</title>
      <link href="/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array) 是一段固定长度的连续内存区域<br>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>Go 的数组和切片都是从C语言延续过来的设计。</p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>数组变量名：数组声明及使用时的变量名</li><li>元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整形数值</li><li>T 可以是任意基本类型，包括 T 为数组本身。但类型为数组本身时，可以实现多维数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>] <span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">"JD"</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">"TaoBao"</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">"Wechat"</span></span><br><span class="line">fmt.Println(team) <span class="comment">// [JD TaoBao Wechat]</span></span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组可以在声明时使用初始化列表进行元素设置，参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式编写时，需要保证大括号后面的元素数量与数组的大小一致</p></blockquote><p>但一般情况下，这个过程可以交给编译器，让编译器在编译时，根据元素个数确定数组大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span> , <span class="string">"TaoBao"</span> , <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>...</code>表示让编译器确定数组大小。上面例子中，编译器会自动为这个数组设置元素个数为 3</p></blockquote><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组也和遍历切片类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> team &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0 JD</span></span><br><span class="line"><span class="comment">1 TaoBao</span></span><br><span class="line"><span class="comment">2 Wechat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个拥有相同类型元素的<strong>可变</strong>长度的序列，Go语言切片的内部包含<strong>地址</strong>、<strong>大小</strong>、<strong>容量</strong>，切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始(这个就是切片的地址)及切多大(这个就是切片的大小)。容量可以理解为装切片的口袋大小</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3154340Y9.jpg" alt=""></p><h3 id="生成切片-从数组或切片生成新的切片"><a href="#生成切片-从数组或切片生成新的切片" class="headerlink" title="生成切片(从数组或切片生成新的切片)"></a>生成切片(从数组或切片生成新的切片)</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身</p><p>从连续内存区域生成切片是常见的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice[开始位置:结束位置]</span><br></pre></td></tr></table></figure><ul><li>slice表示目标切片对象</li><li>开始位置对应目标切片对象的索引</li><li>结束位置对应目标切片的结束索引</li></ul><h4 id="从数组生成切片："><a href="#从数组生成切片：" class="headerlink" title="从数组生成切片："></a>从数组生成切片：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr , arr[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">// [1 2 3] [2]</span></span><br></pre></td></tr></table></figure><p><code>[2]</code>就是<code>arr[1:2]</code>切片操作的结果</p><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置-开始位置。</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。</li><li>当缺省开始位置时，表示从连续区域开头到结束位置。</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾。</li><li>两者同时缺省时，与数组本身等效。</li><li>两者同时为0时，等效于空切片，一般用于切片复位。</li></ul><p>根据索引位置取切片 slice 元素值时，取值范围是<strong>（0～len(slice)-1）</strong>，超界会报运行时错误</p><p>生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>具体，下面使用一些实例演示：</p><h5 id="指定范围生成切片"><a href="#指定范围生成切片" class="headerlink" title="指定范围生成切片"></a>指定范围生成切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个array</span></span><br><span class="line">build := [<span class="number">30</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++ &#123;</span><br><span class="line">build[i] = i +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间取值</span></span><br><span class="line">fmt.Println(build[<span class="number">10</span>:<span class="number">15</span>]) <span class="comment">// [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">// 中间部分到结尾所有元素</span></span><br><span class="line">fmt.Println(build[<span class="number">20</span>:]) <span class="comment">// [21 22 23 24 25 26 27 28 29 30]</span></span><br><span class="line"><span class="comment">// 开始到中间所有元素</span></span><br><span class="line">fmt.Println(build[:<span class="number">8</span>]) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p><h5 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h5><p>生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[:]) <span class="comment">// [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重置切片，清空所有元素"><a href="#重置切片，清空所有元素" class="headerlink" title="重置切片，清空所有元素"></a>重置切片，清空所有元素</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[<span class="number">0</span>:<span class="number">0</span>]) <span class="comment">// []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明新的切片"><a href="#声明新的切片" class="headerlink" title="声明新的切片"></a>声明新的切片</h4><p>除了可以从原有的数组或者切片中生成切片，你也可以声明一个新的切片<br>每一种类型都可以拥有其切片类型，表示多个类型元素的连续集合。因此切片类型也可以被声明。切片类型声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><ul><li>Name 表示切片的变量名</li><li>T 表示切片对应的元素类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明字符串切片</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 声明整形切片</span></span><br><span class="line"><span class="keyword">var</span> intSlice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 声明一个空切片</span></span><br><span class="line"><span class="keyword">var</span> emptySlice = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strSlice, intSlice, emptySlice) <span class="comment">// [] [] []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出3个切片大小</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(strSlice), <span class="built_in">len</span>(intSlice), <span class="built_in">len</span>(emptySlice)) <span class="comment">// 0 0 0</span></span><br><span class="line"><span class="comment">// 切片判定空的结果</span></span><br><span class="line">fmt.Println(strSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(intSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>) <span class="comment">// true true false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是动态结构，只能与nil判定相等，不能互相判等时。</p><p>声明新的切片后，可以使用<code>append()</code>函数来添加元素。</p><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><p>如果需要动态的创建一个切片，可以使用make()内建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,size,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><ul><li>T : 切片的元素类型</li><li>size : 就是为这个类型分配多少个元素</li><li>cap : 预分配元素数量，这个值设定不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题。</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b) <span class="comment">// [0 0] [0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)) <span class="comment">// 2 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">cap</span>(b)) <span class="comment">// 2 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。<br>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p></blockquote><p>使用 make() 函数生成的切片一定发生了内存分配操作。但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p><p>切片不一定必须经过 make() 函数才能使用。生成切片、声明后使用 append() 函数均可以正常使用切片</p><h3 id="使用append-为切片添加元素"><a href="#使用append-为切片添加元素" class="headerlink" title="使用append()为切片添加元素"></a>使用append()为切片添加元素</h3><ul><li>Go语言的内建函数 append() 可以为切片动态添加元素</li><li>每个切片会指向一片内存空间，这片空间能容纳一定数量的元素</li><li>当空间不能容纳足够多的元素时，切片就会进行“扩容”。“扩容”操作往往发生在 append() 函数调用时</li><li>切片在扩容时，容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">fmt.Printf(<span class="string">"len: %d,cap: %d,pointer: %p\n"</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line"><span class="comment">// len : 1,cap:1,pointer:0xc000014080</span></span><br><span class="line"><span class="comment">// len : 2,cap:2,pointer:0xc0000140b0</span></span><br><span class="line"><span class="comment">// len : 3,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 4,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 5,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 6,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 7,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 8,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 9,cap:16,pointer:0xc00008a000</span></span><br><span class="line"><span class="comment">// len : 10,cap:16,pointer:0xc00008a000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append() 函数除了添加一个元素外，也可以一次性添加很多元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> company []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加一个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"JD"</span>)</span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"taobao"</span> , <span class="string">"t.tt"</span>)</span><br><span class="line"><span class="comment">// 添加切片</span></span><br><span class="line">newCompany := []<span class="keyword">string</span>&#123;<span class="string">"mi"</span> , <span class="string">"坚果"</span>&#125;</span><br><span class="line">company = <span class="built_in">append</span>(company , newCompany...)</span><br><span class="line"></span><br><span class="line">fmt.Println(company) <span class="comment">// [JD taobao t.tt mi 坚果]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第 13 行，在newCompany后面加上了<code>...</code>，表示将 newCompany 整个添加到 car 的后面。</p></blockquote><h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>使用内建的 copy() 函数，可以迅速地将一个切片的数据复制到另外一个切片空间中，copy() 函数的使用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(originSlice,srcSlice []T)<span class="keyword">int</span></span><br></pre></td></tr></table></figure><ul><li>originSlice 为数据来源切片</li><li>srcSlice为复制的目标。目标切片必须分配过空间且足够承载复制的元素个数，来源和目标的类型一致，copy 的返回值表示实际发生复制的元素个数。</li></ul><h3 id="删除切片元素"><a href="#删除切片元素" class="headerlink" title="删除切片元素"></a>删除切片元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>&#125;</span><br><span class="line"><span class="comment">// 指定删除位置       </span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line"><span class="comment">// 查看删除位置之前的元素和之后的元素</span></span><br><span class="line">fmt.Println(seq[:index], seq[index+<span class="number">1</span>:])<span class="comment">// [a b] [d e]</span></span><br><span class="line"><span class="comment">// 将删除点前后的元素连接起来 </span></span><br><span class="line">seq = <span class="built_in">append</span>(seq[:index], seq[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(seq) <span class="comment">// [a b d e]</span></span><br></pre></td></tr></table></figure><p>代码的删除过程可以使用下图来描述。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3164544530.jpg" alt=""></p><p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p><blockquote><p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。</p></blockquote><h2 id="map-Go语言映射"><a href="#map-Go语言映射" class="headerlink" title="map(Go语言映射)"></a>map(Go语言映射)</h2><p>在业务和算法中需要使用任意类型的关联关系时，就需要使用到映射，如学号和学生的对应、名字与档案的对应等。</p><p>Go语言提供的映射关系容器为 map，map使用散列表（hash）实现。</p><h3 id="添加数据到map"><a href="#添加数据到map" class="headerlink" title="添加数据到map"></a>添加数据到map</h3><p>Go语言中 map 的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]vluesType</span><br></pre></td></tr></table></figure><ul><li>keyTyp 表示键类型</li><li>valueType 表示键对应值类型</li></ul><p>一个map 里，符合keyType和valueType 的映射总是成对出现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scene := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//  这里的map是内部实现的类型</span></span><br><span class="line">scene[<span class="string">"route"</span>] = <span class="number">666</span></span><br><span class="line">fmt.Println(scene[<span class="string">"route"</span>]) <span class="comment">// 666</span></span><br><span class="line"></span><br><span class="line">v := scene[<span class="string">"route2"</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尝试查找一个不存在的键，那么返回的将是 ValueType 的默认值</p></blockquote><p>某些情况下，需要明确知道查询中某个键是否在 map 中存在，可以使用一种特殊的写法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := scene[<span class="string">"route"</span>]</span><br></pre></td></tr></table></figure><p>在默认获取键值的基础上，多取了一个变量 ok，可以判断键 route 是否存在于 map 中。</p><p>map 还可以在声明时填充内容，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"W"</span> : <span class="string">"forward"</span>,</span><br><span class="line"><span class="string">"A"</span>: <span class="string">"left"</span>,</span><br><span class="line"><span class="string">"D"</span>: <span class="string">"right"</span>,</span><br><span class="line"><span class="string">"S"</span>: <span class="string">"backward"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[W:forward A:left D:right S:backward]</span></span><br></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><h4 id="遍历key-和-value"><a href="#遍历key-和-value" class="headerlink" title="遍历key 和 value"></a>遍历key 和 value</h4><p>map 的遍历过程使用 <code>for range</code>循环完成，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span>  family&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span> , key ,value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><p>遍历时，可以同时获得键和值。如只遍历值，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>将不需要的键改为匿名变量形式。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><p>只遍历键时，使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>无须将值改为匿名变量形式，忽略值即可</p><h3 id="map-元素删除和清空"><a href="#map-元素删除和清空" class="headerlink" title="map 元素删除和清空"></a>map 元素删除和清空</h3><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对 ，<code>delete()</code>函数的格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span> , 键)</span><br></pre></td></tr></table></figure><ul><li>map 为要删除的map实例</li><li>键为要删除的 map 键值对中的键</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">numMap := make(map[string]int)</span><br><span class="line"></span><br><span class="line">numMap[&quot;aroute&quot;] = 66</span><br><span class="line">numMap[&quot;brazil&quot;] = 4</span><br><span class="line">numMap[&quot;china&quot;] = 960</span><br><span class="line">delete(numMap , &quot;brazil&quot;)</span><br><span class="line">for k, v := range numMap &#123;</span><br><span class="line">fmt.Println(k , v)</span><br><span class="line">/**</span><br><span class="line">aroute 66</span><br><span class="line">china 960</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h4><p>有意思的是,Go语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是<strong>重新 make 一个新的 map</strong>。不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数高效多了。</p><h2 id="sync-Map-在并发环境中使用的map"><a href="#sync-Map-在并发环境中使用的map" class="headerlink" title="sync.Map(在并发环境中使用的map)"></a>sync.Map(在并发环境中使用的map)</h2><p>Go 语言中的 map 在并发情况下，只读是线程安全的，同时读写线程不安全。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个int到int的映射</span></span><br><span class="line">n := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 不停地对map进行写入</span></span><br><span class="line">n[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = n[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码会报错，输出如下：<br><code>fatal error: concurrent map read and map write</code></p><p>运行时输出提示：并发的 map 读写。也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题。map 内部会对这种并发操作进行检查并提前发现</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高。Go 语言在 1.9 版本中提供了一种效率较高的并发安全的 <code>sync.Map</code>。<code>sync.Map</code> 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p><code>sync.Map</code>有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。Range 参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scenes sync.Map</span><br><span class="line"><span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">scenes.Store(<span class="string">"greece"</span>, <span class="number">97</span>)</span><br><span class="line">scenes.Store(<span class="string">"london"</span>, <span class="number">100</span>)</span><br><span class="line">scenes.Store(<span class="string">"egypt"</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">fmt.Println(scenes.Load(<span class="string">"london"</span>))</span><br><span class="line"><span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">scenes.Delete(<span class="string">"london"</span>)</span><br><span class="line"><span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">scenes.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"iterate:"</span>, k, v)</span><br><span class="line"><span class="comment">// iterate: greece 97</span></span><br><span class="line"><span class="comment">//i terate: egypt 200</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>sync.Map 没有提供获取 map 数量的方法，替代方法是获取时遍历自行计算数量。sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之前的关系。列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示：</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31I54a30.jpg" alt=""></p><p>如果在这个基础上，再从 C 开始将自己的号码给自己知道号码的人，这样就形成了双链表结构，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31IJRI.jpg" alt=""></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环。这个过程就是列表遍历。<br>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除。这个过程就是列表元素的删除操作，如下图所示</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31J0524T.jpg" alt=""></p><p>在Go语言中，将列表使用 container/list 包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><code>list</code> 的初始化有两种方法：New 和声明。两种方法的初始化效果都是一致的。</p><h4 id="通过container-list-包的-New-方法初始化-list"><a href="#通过container-list-包的-New-方法初始化-list" class="headerlink" title="通过container/list 包的 New 方法初始化 list"></a>通过container/list 包的 New 方法初始化 list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure><h4 id="通过声明初始化list"><a href="#通过声明初始化list" class="headerlink" title="通过声明初始化list"></a>通过声明初始化list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure><p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制。因此，列表的元素可以是任意类型。这既带来便利，也会引来一些问题。给一个列表放入了非期望类型的值，在取出值后，将 interface{} 转换为期望类型时将会发生宕机。</p><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 <code>PushFront</code>和 <code>PushBack</code>。</p><p>这两个方法都会返回一个 <code>*list.Element</code> 结构。如果在以后的使用中需要删除插入的元素，则只能通过 <code>*list.Element</code> 配合<code>Remove()</code>方法进行删除，这种方法可以让删除更加效率化，也是双链表特性之一</p><p>下面代码展示给list添加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br></pre></td></tr></table></figure><p>列表插入元素的方法如下表所示。</p><table><thead><tr><th>方  法</th><th>功  能</th></tr></thead><tbody><tr><td>InsertAfter(v interface {}, mark <em> Element) </em> Element</td><td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td></tr><tr><td>InsertBefore(v interface {}, mark <em> Element) </em>Element</td><td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td></tr><tr><td>PushBackList(other *List)</td><td>添加 other 列表元素到尾部</td></tr><tr><td>PushFrontList(other *List)</td><td>添加 other 列表元素到头部</td></tr></tbody></table><h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表的插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值及和其他节点之间的关系等信息。从列表中删除元素时，需要用到这个结构进行快速删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入age</span></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line"><span class="comment">// 头部插入18+</span></span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"><span class="comment">// 在fist之后添加high</span></span><br><span class="line">l.InsertAfter(<span class="string">"high"</span>, element)</span><br><span class="line"><span class="comment">// 在fist之前添加noon</span></span><br><span class="line">l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">l.Remove(element)</span><br></pre></td></tr></table></figure><p>下表中展示了每次操作后列表的实际元素情况。</p><table><thead><tr><th>操作内容</th><th>列表元素</th></tr></thead><tbody><tr><td>l.PushBack(“age”)</td><td>age</td></tr><tr><td>l.PushFront(“18+”)</td><td>18+, age</td></tr><tr><td>element := l.PushBack(“fist”)</td><td>18+, age, fist</td></tr><tr><td>l.InsertAfter(“high”, element)</td><td>18+, age, fist, high</td></tr><tr><td>l.InsertBefore(“noon”, element)</td><td>18+, age, noon, fist, high</td></tr><tr><td>l.Remove(element)</td><td>18+, age, noon, high</td></tr></tbody></table><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>遍历双链表需要配合 <code>Front()</code>函数获取头元素，遍历时只要元素不为空就可以继续进行。每一次遍历调用元素的 <code>Next</code>，如代码中第 6 行所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">    <span class="comment">// 67</span></span><br><span class="line">    <span class="comment">// canon</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次；每次循环会进行一次 i!=nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i=i.Next()。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记1-基本语法</title>
      <link href="/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="变量声明-使用var关键字"><a href="#变量声明-使用var关键字" class="headerlink" title="变量声明(使用var关键字)"></a>变量声明(使用var关键字)</h2><blockquote><p>变量（Variable）的功能是存储用户的数据,不同的逻辑有不同的对象类型，也就有不同的变量类型</p></blockquote><p>Go语言使用<strong>var</strong>关键字进行变量的声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">e</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行，声明一个整形类型的变量，用来保存整数数值</li><li>第二行，声明一个字符串类型的变量</li><li>第三行，声明一个32位浮点切片类型的变量，浮点切片表示由多个浮点类型组成的数据结构</li><li>第四行，声明一个返回值为bool类型的函数变量，这种形式一般用于回调函数，即将函数以变量的形式保存下来，在需要的时候重新调用这个函数</li><li>声明一个结构体类型的变量，这个结构体拥有一个整形的x字段</li></ul><h3 id="标准格式声明"><a href="#标准格式声明" class="headerlink" title="标准格式声明"></a>标准格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量的声明是以var关键字开头，要声明的变量名放中间，将其类型放在后面，行尾无需分号</p><h3 id="批量格式声明"><a href="#批量格式声明" class="headerlink" title="批量格式声明"></a>批量格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c []<span class="keyword">float32</span></span><br><span class="line">d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用var和括号，可以将一组变量定义放在一起</p><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p><ul><li>整型和浮点型变量的默认值为 0</li><li>字符串变量的默认值为空字符串</li><li>布尔型变量默认为 bool</li><li>切片、函数、指针变量的默认为 nil</li></ul><p>在声明变量的时候也可以进行赋初始值</p><h3 id="变量初始化标准格式"><a href="#变量初始化标准格式" class="headerlink" title="变量初始化标准格式"></a>变量初始化标准格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><h3 id="编译器推导类型"><a href="#编译器推导类型" class="headerlink" title="编译器推导类型"></a>编译器推导类型</h3><p>在标准格式的基础上，可以省略部分变量类型，编译器会尝试根据等号右边的表达式推导变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><p>等号右边的部分在编译原理里被称做右值（rvalue）</p><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p>var 的变量声明还有一种精简写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><blockquote><p> 左值变量必须是没有定义过的变量</p></blockquote><p>在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><p>多重赋值时，变量的左值和右值按从左到右的顺序赋值<br>多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。</p><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在使用多重赋值时，如果不需要在左值中接收变量，可以使用匿名变量（anonymous variable）</p><p>匿名变量的表现是一个下划线<code>_</code>,使用匿名变量时，只需要在变量声明的地方使用下画线替换即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line">fmt.Println(a, b)<span class="comment">// 100 200</span></span><br></pre></td></tr></table></figure><p><strong>匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</strong></p><p>匿名变量：</p><ul><li>可以理解为一种占位符。</li><li>本身这种变量不会进行空间分配，也不会占用一个变量的名字。</li><li>在<code>for range</code> 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li></ul><h2 id="Go语言类型"><a href="#Go语言类型" class="headerlink" title="Go语言类型"></a>Go语言类型</h2><p>Go语言 中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异，切片类型有着指针的便利性，但比指针更为安全，很多高级语言都配有切片进行安全和高效率的内存操作。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整型分为以下两个大类：</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>还有对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。</p><h3 id="浮点类型（小数类型）"><a href="#浮点类型（小数类型）" class="headerlink" title="浮点类型（小数类型）"></a>浮点类型（小数类型）</h3><p>Go语言</p><p>支持两种浮点型数：float32 和 float64。这两种浮点型数据格式遵循 IEEE 754 标准：</p><ul><li>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。</li><li>float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</li></ul><p>打印浮点数时，可以使用 fmt 包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi) <span class="comment">//按默认宽度和精度输出整型</span></span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)<span class="comment">//按默认宽度，2 位精度输出（小数点后的位数）。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.141593</span></span><br><span class="line"><span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>布尔型数据只有 true（真）和 false（假）两个值，布尔型无法参与数值运算，也无法与其他类型进行转换</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在Go语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。</p><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转移符</th><th>含  义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr></tbody></table><h4 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h4><p>在源码中，将字符串的值以双引号书写的方式是字符串的常见表达方式，被称为字符串字面量（string literal）<br>这种双引号字面量不能跨行。如果需要在源码中嵌入一个多行字符串时，就必须使用<strong>`</strong>字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><blockquote><p>在<strong>`</strong>间的所有代码均不会被编译器识别，而只是作为字符串的一部分</p></blockquote><h3 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h3><p>字符串中的每一个元素叫做<strong>“字符”</strong>，在遍历或者单个获取字符串元素时可以获得字符</p><p>Go语言的字符有以下两种：</p><ol><li><strong>uint8</strong>类型，也叫<strong>byte</strong>型，代表了<strong>ASCLL</strong>码中的一个字符</li><li><strong>rune</strong>类型，代表一个<strong>UTF-8</strong>字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32。</li></ol><p>使用<code>fmt.Printf</code>中的<code>%T</code>动词可以输出、变量的实际类型，使用这个方法可以查看 byte 和 rune 的本来类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, a, a) <span class="comment">// 97 uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">rune</span> = <span class="string">'你'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, b, b) <span class="comment">// 20320 int32</span></span><br></pre></td></tr></table></figure><blockquote><p>可以发现，byte 类型的 a 变量，实际类型是 uint8，其值为 ‘a’，对应的 ASCII 编码为 97<br>rune 类型的 b 变量的实际类型是 int32，对应的 Unicode 码就是 20320<br>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p></blockquote><h2 id="Go数据类型转换"><a href="#Go数据类型转换" class="headerlink" title="Go数据类型转换"></a>Go数据类型转换</h2><p>Go语言使用类型前置加括号的方式进行数据类型转换，一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><blockquote><p>T代表要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><p>类型转换时，需要考虑两种类型的关系和范围，是否会发生数值截断等</p></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，例如圆周率。<br>可以在编译时，对常量表达式进行计算求值，并在运行期使用该计算结果，计算结果无法被修改。常量表示起来非常简单，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">4.14159</span></span><br></pre></td></tr></table></figure><p>常量的声明和变量声明非常类似，只是把 var 换成了 const。</p><p>多个变量可以一起声明，类似的，常量也是可以多个一起声明的，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.141592</span></span><br><span class="line">    e = <span class="number">2.718281</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量因为在编译期确定，所以可以用于数组声明，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> arr [size]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="模拟枚举-const和iota模拟枚举"><a href="#模拟枚举-const和iota模拟枚举" class="headerlink" title="模拟枚举(const和iota模拟枚举)"></a>模拟枚举(const和iota模拟枚举)</h2><p>Go语言现阶段没有枚举，可以使用 const 常量配合 iota 模拟枚举，请看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weapon <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower) <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="comment">// 使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>枚举类型其实本质是一个 int 一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。</p><h2 id="Go语言type关键字-类型别名"><a href="#Go语言type关键字-类型别名" class="headerlink" title="Go语言type关键字(类型别名)"></a>Go语言type关键字(类型别名)</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名的写法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a NewInt</span><br><span class="line">fmt.Printf(&quot;a type : %T\n&quot;, a) // a type : main.NewInt</span><br><span class="line"></span><br><span class="line">var b IntAlias</span><br><span class="line">fmt.Printf(&quot;b type %T\n&quot;, b) // b type int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 8 行，将 NewInt 定义为 int 类型，这是常见定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</li><li>第 11 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。</li><li>第 15 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。</li><li>第 16 行，使用<code>%T</code>格式化参数，显示 a 变量本身的类型。</li><li>第 18 行，将 b 声明为 IntAlias 类型，此时打印 b 的值为 0。</li><li>第 19 行，显示 b 变量的类型。</li></ul><p>结果显示a的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型。b 类型是 int。IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。</p><h2 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h2><p>指针（pointer）概念在Go语言中被拆分为两个核心概念：</p><ol><li>类型指针，运行对这个指针类型的数据进行修改，传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算</li><li>切片，由指向起始元素的原始指针、元素数量和容量组成</li></ol><p>受益于这样的约束和拆分，Go 语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p>要明白指针，需要知道几个概念：<strong>指针地址</strong>、<strong>指针类型</strong>和<strong>指针取值</strong>，下面将展开细说。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置</p><p>Go 语言中使用<code>&amp;</code>作符放在变量前面对变量进行“取地址”操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中v代表被取地址的变量，被取地址的v使用ptr变量进行接收，ptr的类型就为<code>*T</code>,称做 T 的指针类型，<code>*</code>代表指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cat <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"banana"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p %p"</span>, &amp;cat, &amp;str) <span class="comment">// 0xc042052088 0xc0420461b0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>第 8 行，声明整型 cat 变量。</li><li>第 9 行，声明字符串 str 变量。</li><li>第 10 行，使用 fmt.Printf 的动词<code>%p</code>输出 cat 和 str 变量取地址后的指针值，指针值带有<code>0x</code>的十六进制前缀。</li></ul><p>输出值在每次运行是不同的，代表 cat 和 str 两个变量在运行时的地址。</p><p><strong>提示：变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址</strong></p><h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用<code>&amp;</code>操作符获取地址获得这个变量的指针后，可以对指针使用<code>*</code>操作，也就是指针取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 声明一个字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">"陕西西安"</span></span><br><span class="line"><span class="comment">// 对字符串取地址，ptr类型为*string</span></span><br><span class="line">ptr := &amp;house</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出ptr类型</span></span><br><span class="line">fmt.Printf(<span class="string">"ptr type: %T\n"</span> , ptr) <span class="comment">// ptr type: *string</span></span><br><span class="line"><span class="comment">// 输出ptr指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">"address: %p\n"</span> , ptr) <span class="comment">// address: 0xc00000e1e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针进行取值操作</span></span><br><span class="line">value := *ptr</span><br><span class="line"><span class="comment">// 取值后类型</span></span><br><span class="line">fmt.Printf(<span class="string">"value type: %T\n"</span> , value) <span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// 指针去之后就是指向变量的值</span></span><br><span class="line">fmt.Printf(<span class="string">"value: %s\n"</span> , value) <span class="comment">//value: 陕西西安</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</strong></p><h3 id="变量、指针地址、指针变量、取地址、取值的相互关系和特性"><a href="#变量、指针地址、指针变量、取地址、取值的相互关系和特性" class="headerlink" title="变量、指针地址、指针变量、取地址、取值的相互关系和特性"></a>变量、指针地址、指针变量、取地址、取值的相互关系和特性</h3><p>如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 交换变量值</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line"><span class="comment">// 输出变量值</span></span><br><span class="line">fmt.Println(x, y) <span class="comment">// 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">t := *a</span><br><span class="line"><span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">*a = *b</span><br><span class="line"><span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">*b = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量</p><p><code>*</code>操作符的根本意义就是操作指针指向的变量，当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p></blockquote><h3 id="创建指针的另一种方法——new-函数"><a href="#创建指针的另一种方法——new-函数" class="headerlink" title="创建指针的另一种方法——new() 函数"></a>创建指针的另一种方法——new() 函数</h3><p>Go 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(T) <span class="comment">// T代表类型</span></span><br></pre></td></tr></table></figure><p>一般这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">"zhimma"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str) <span class="comment">// zhimma</span></span><br></pre></td></tr></table></figure><blockquote><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx单域名配置多Vue工程和多PHP接口</title>
      <link href="/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>先简单说下需求吧：</p><p>前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即<code>小程序端</code>，<code>boss后台管理端</code>，<code>console客户端</code>，按照最简单的业务来解析域名，则需要6个域名。</p><p>由于种种原因吧，只能提供一个域名，所以就要借助Nginx的重定向或者rewrite功能；</p><p>大致流程和这里基本保持一致，<a href="https://blog.zhimma.com/2019/02/01/Nginx单域名配置多Vue工程和PHP接口/">点击查看Nginx单域名配置多Vue工程和PHP接口</a></p><p>先贴一下代码吧：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> btg.ma;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="comment">##----boss api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/b &#123;</span><br><span class="line">       // 目录重定向</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/boss-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@bossBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@bossBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            // 兼容路由模式-个人猜想</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/b/(.*)$</span> /boss/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /boss/b/(.*)$ /boss/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----boss web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/boss/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/f/(.*)</span> /boss/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----console api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/console-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@consoleBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@consoleBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/b/(.*)$</span> /console/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /console/b/(.*)$ /console/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----console web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/console/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/f/(.*)</span> /console/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----crs api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/crs-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@crsBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@crsBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/b/(.*)$</span> /crs/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /crs/b/(.*)$ /crs/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----crs-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/crs/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/f/(.*)</span> /crs/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#location /favicon.ico &#123;</span></span><br><span class="line">    <span class="comment">#    root /data/wwwroot/mk.vchangyi.com/web_test/backend;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/btg.ma.access.log main;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/btg.ma.<span class="literal">error</span>.log <span class="literal">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果就成为这样子：</p><p><code>domain/origin/type</code></p><p>域名+管理端+前后端，<strong>f</strong>代表<code>frontend</code>,<strong>b</strong>代表<code>backend</code></p><p><strong>boss:</strong></p><p>前台页面：<code>btg.ma/boss/f</code></p><p>后台接口地址：<code>btg.ma/boss/b</code></p><p><strong>console:</strong></p><p>前台页面：<code>btg.ma/console/f</code></p><p>后台接口地址：<code>btg.ma/console/b</code></p><p><strong>crs:</strong></p><p>前台页面：<code>btg.ma/crs/f</code></p><p>后台接口地址：<code>btg.ma/crs/b</code></p><p><strong><em>done</em></strong>;</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx目录路径重定向</title>
      <link href="/2019/03/01/Nginx%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2019/03/01/Nginx%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>如果希望域名后边跟随的路径指向本地磁盘的其他目录,而不是默认的web目录时,需要设置nginx目录访问重定向</p><p>应用场景:<code>domain.com/image</code>自动跳转到<code>domain.com/folderName/image</code>目录。</p><h2 id="Nginx目录路径重定向的几种实现方式"><a href="#Nginx目录路径重定向的几种实现方式" class="headerlink" title="Nginx目录路径重定向的几种实现方式:"></a>Nginx目录路径重定向的几种实现方式:</h2><h3 id="Nginx修改root映射"><a href="#Nginx修改root映射" class="headerlink" title="Nginx修改root映射"></a>Nginx修改root映射</h3><p>修改root映射实现nginx目录访问重定向是最简单的方式, 推荐采用这一种.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image &#123;</span><br><span class="line">    <span class="attribute">root</span>   /folderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Nginx-rewrite内部跳转实现访问重定向"><a href="#通过Nginx-rewrite内部跳转实现访问重定向" class="headerlink" title="通过Nginx rewrite内部跳转实现访问重定向"></a>通过Nginx rewrite内部跳转实现访问重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>     /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx设置别名alias映射实现"><a href="#Nginx设置别名alias映射实现" class="headerlink" title="Nginx设置别名alias映射实现"></a>Nginx设置别名alias映射实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image  &#123;</span><br><span class="line">    <span class="attribute">alias</span>  /folderName/image;  <span class="comment">#这里写绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过nginx的permanent-301绝对跳转实现"><a href="#通过nginx的permanent-301绝对跳转实现" class="headerlink" title="通过nginx的permanent 301绝对跳转实现"></a>通过nginx的permanent 301绝对跳转实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>   http://dashidan.com/folderName/image/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过判断uri实现页面跳转"><a href="#通过判断uri实现页面跳转" class="headerlink" title="通过判断uri实现页面跳转"></a>通过判断uri实现页面跳转</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~* ^(/image))</span>&#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span> /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上转自<code>https://dashidan.com/article/webserver/nginx/4.html</code></p><p>具体实例，<a href="https://dashidan.com/article/webserver/nginx/4.html" target="_blank" rel="noopener">请参考这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins-基础方法Basic Steps</title>
      <link href="/2019/02/20/Jenkins-%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95Basic-Steps/"/>
      <url>/2019/02/20/Jenkins-%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95Basic-Steps/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>这篇开始来学习一个最基础的pipeline组件，这个也是一个独立的插件，在安装pipeline的时候默认会自动安装，插件的名称是<a href="https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Basic+Steps+Plugin" target="_blank" rel="noopener">Pipeline: Basic Steps</a>,你可以去你自己jenkins环境，插件管理下的installed下面找到这个插件</p><p>下面具体介绍下该插件包含的各个方法    </p><h3 id="deleteDir-方法"><a href="#deleteDir-方法" class="headerlink" title="deleteDir()方法"></a>deleteDir()方法</h3><p>默认递归删除WORKSPACE下的文件和文件夹,这个方法是没有参数，也不需要参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">deleteDir()  <span class="comment">// clean up current work directory</span></span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/deleteDir.png" alt=""></p><h3 id="dir-方法"><a href="#dir-方法" class="headerlink" title="dir()方法"></a>dir()方法</h3><p>如果使用了dir语句块，这个方法就是改变当前的工作目录</p><p>在dir语句块里执行的其他路径或者相对路径，都是和dir里面设置的文件路径相关，这个和WORKSPACE相对文件路径已经没有关系了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    println env.WORKSPACE</span><br><span class="line">    dir(<span class="string">"$&#123;env.WORKSPACE&#125;/testdata"</span>)&#123;</span><br><span class="line">    sh <span class="string">"pwd"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/dir.png" alt=""></p><h3 id="echo-和-error-方法"><a href="#echo-和-error-方法" class="headerlink" title="echo() 和 error()方法"></a>echo() 和 error()方法</h3><p>echo就是和groovy中的println没有任何区别,如果看打印的效果。一般来说使用echo就是打印info debug级别的日志输出用</p><p>如果遇到错误，就可以使用error(‘error message’)    ，如果出现执行到error方法，jenkins job会退出并显示失败效果。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    echo(<span class="string">"this is echo info"</span>)</span><br><span class="line">    error(<span class="string">"this is error info"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/error.png" alt=""></p><h3 id="fileExists-方法"><a href="#fileExists-方法" class="headerlink" title="fileExists()方法"></a>fileExists()方法</h3><p>这是判断一个文件是否存在，返回值是布尔类型，true就表示文件存在，false表示文件不存在</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">json_file = <span class="string">"$&#123;env.WORKSPACE&#125;/testdata/test_json.json"</span></span><br><span class="line"><span class="keyword">if</span>(fileExists(json_file) == <span class="literal">true</span>) &#123;</span><br><span class="line">echo(<span class="string">"json file is exists"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">"here haven't find json file"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/fileExists.png" alt=""></p><h3 id="pwd-方法"><a href="#pwd-方法" class="headerlink" title="pwd()方法"></a>pwd()方法</h3><p>其实这个方法和linux下的shell命令pwd是一样的。由于jenkins支持windows和linux，但是linux是pwd，windows上是dir,所以这个插件就干脆支持一个方法，统称为pwd()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">sh(<span class="string">"pwd"</span>)</span><br><span class="line">println <span class="string">"==========="</span></span><br><span class="line">println pwd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/pwd.png" alt=""></p><h3 id="isUnix-方法"><a href="#isUnix-方法" class="headerlink" title="isUnix()方法"></a>isUnix()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(&quot;Demo&quot;) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">if(isUnix() == true) &#123;</span><br><span class="line">echo(&quot;this jenkins job running on a linux-like system&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">error(&quot;the jenkins job running on a windows system&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/isUnix.png" alt=""></p><h3 id="mail指令"><a href="#mail指令" class="headerlink" title="mail指令"></a>mail指令</h3><h4 id="Jenkins服务器上配置smtp服务"><a href="#Jenkins服务器上配置smtp服务" class="headerlink" title="Jenkins服务器上配置smtp服务"></a>Jenkins服务器上配置smtp服务</h4><p><strong>subject</strong></p><p>必填，邮件标题主题，Type: <code>String</code></p><p><strong>body</strong></p><p>必填，邮件正文，Type: <code>String</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">script &#123;</span><br><span class="line">mail <span class="string">to:</span> <span class="string">'admin@163.com'</span>,</span><br><span class="line"><span class="symbol">                    subject:</span> <span class="string">"Running Pipeline: $&#123;currentBuild.fullDisplayName&#125;"</span>,</span><br><span class="line"><span class="symbol">                    body:</span> <span class="string">"Something is wrong with $&#123;env.BUILD_URL&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins-Pipeline语法入门</title>
      <link href="/2019/02/18/Jenkins-Pipeline%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/18/Jenkins-Pipeline%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>流水线最基础的部分是 “step”。基本上, step告诉 Jenkins 要做什么，以及作为声明式(Declarative)和脚本化(Scripted)流水线语法的基本构建块。</p><h2 id="Declarative-Pipeline-声明管道"><a href="#Declarative-Pipeline-声明管道" class="headerlink" title="Declarative Pipeline-声明管道"></a>Declarative Pipeline-声明管道</h2><p>有效的Declarative Pipeline必须包含在一个pipeline块内，例如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    <span class="comment">/* insert Declarative Pipeline here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Declarative Pipeline中有效的基本语句和表达式遵循与Groovy语法相同的规则 ，但有以下例外：</p><ul><li>Pipeline的顶层必须是块(block)，其实就是<code>pipeline { }</code></li><li>没有分号作为语句分隔符。每个声明必须在自己的一行</li><li>块只能包含章节， 指令，步骤<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或赋值语句</li><li>属性引用语句被视为无参数方法调用。所以例如，input被视为input（）</li></ul><blockquote><p>第一点：    就是声明指定的代码块</p><p>第二点：分号写了也是多余的。Groovy代码还可以写分号，Jenkins Pipeline代码就不需要，每行只写一个声明语句块或者调用方法语句</p><p>第三点：只能包含<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或者赋值语句</p><p>第四点：没懂，懂了再回来补充</p></blockquote><h3 id="Sections-章节-节段"><a href="#Sections-章节-节段" class="headerlink" title="Sections-章节/节段"></a>Sections-章节/节段</h3><p>Declarative Pipeline 代码中的Sections指的是必须包含一个或者多个指令或者步骤的<strong>代码区域块</strong>。Sections不是一个关键字或者指令，只是一个<strong>逻辑概念</strong>。</p><h3 id="agent指令-代理"><a href="#agent指令-代理" class="headerlink" title="agent指令-代理"></a><a href="https://blog.csdn.net/u011541946/article/details/83278214" target="_blank" rel="noopener">agent指令-代理</a></h3><p>agent部分指定整个Pipeline或特    定阶段将在Jenkins环境中执行的位置，具体取决于该agent 部分的放置位置。该部分必须在pipeline块内的顶层定义 ，但阶段级使用是可选的</p><blockquote><p>简单来说，agent部分主要作用就是告诉Jenkins，选择那台节点机器去执行Pipeline代码；这个指令是必须要有的，也就在你顶层pipeline {…}的下一层，必须要有一个agent{…}</p><p>agent这个指令对应的多个可选参数。</p><p>这里注意一点，在具体某一个stage {…}里面也可以使用agent指令。这种用法不多，一般我们在顶层使用agent，这样，接下来的全部stage都在一个agent机器下执行代码。</p><p>为了支持Pipeline作者可能拥有的各种用例，该agent部分支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p></blockquote><h4 id="参数1：any"><a href="#参数1：any" class="headerlink" title="参数1：any"></a>参数1：any</h4><p>作用：在任何可用的代理上执行Pipeline或stage</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种是最简单的，如果你Jenkins平台环境只有一个master，那么这种写法就最省事情</p><h4 id="参数2：none"><a href="#参数2：none" class="headerlink" title="参数2：none"></a>参数2：none</h4><p>作用：当在<code>pipeline</code>块的顶层应用时，将不会为整个Pipeline运行分配全局代理，并且每个<code>stage</code>部分将需要包含其自己的<code>agent</code>部分,就像上面说的在具体某一个stage {…}里面也可以使用agent指令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>)&#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">               label <span class="string">'具体的节点名称'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数3：label"><a href="#参数3：label" class="headerlink" title="参数3：label"></a>参数3：label</h4><p>作用：使用提供的标签在Jenkins环境中可用的代理机器上执行Pipeline或stage内执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">       label <span class="string">'具体一个节点label名称'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="参数4：node"><a href="#参数4：node" class="headerlink" title="参数4：node"></a>参数4：node</h4><p>作用：和上面label功能类似，但是node运行其他选项，例如customWorkspace</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post指令"><a href="#post指令" class="headerlink" title="post指令"></a><a href="https://blog.csdn.net/u011541946/article/details/83278531" target="_blank" rel="noopener">post指令</a></h3><p><code>post</code>部分定义将在Pipeline运行或阶段结束时运行的操作</p><p><code>post</code>部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a>,这些阶段根Pipeline或stage的完成情况而运行,<code>post</code> 支持以下 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#post-conditions" target="_blank" rel="noopener">post-condition</a> 块中的其中之一: <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code></p><blockquote><p>简单来说，post可以放在顶层，也就是和agent{…}同级，也可以放在stage里面。一般放顶层的比较多。而且pipeline代码中post代码块不是必须的，使用post的场景基本上执行完一个构建，进行发送消息通知，例如构建失败会发邮件通知</p></blockquote><p>简单示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">        stages &#123;</span><br><span class="line">            stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">          <span class="comment">//写相关post部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post条件的基本用法"><a href="#post条件的基本用法" class="headerlink" title="post条件的基本用法"></a>post条件的基本用法</h4><p>在post代码块区域，支持多种条件指令，这些指令有always，changed，failure，success，unstable，和aborted。下面分别来介绍这些条件的基本用法。</p><h5 id="条件1：always"><a href="#条件1：always" class="headerlink" title="条件1：always"></a>条件1：always</h5><p>作用：无论Pipeline运行的完成状态如何都会执行这段代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">//写相关清除/恢复环境等操作代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个always场景，很容易想到的场景就是，事后清理环境。例如测试完了，对数据库进行恢复操作，恢复到测试之前的环境。</p><h5 id="条件2：changed"><a href="#条件2：changed" class="headerlink" title="条件2：changed"></a>条件2：changed</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        changed &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个场景，大部分是写发邮件状态。例如，你最近几次构建都是成功，突然变成不是成功状态，里面就触发发邮件通知。当然，使用changed这个指令没success和failure要频率高</p><h5 id="条件3：failure"><a href="#条件3：failure" class="headerlink" title="条件3：failure"></a>条件3：failure</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        failure &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个failure条件一般来说，百分百会写到Pipeline代码中，内容无非就是发邮件通知，或者发微信群，钉钉机器人，还有国外的slack聊天群组等。</p><h3 id="stages和steps指令"><a href="#stages和steps指令" class="headerlink" title="stages和steps指令"></a>stages和steps指令</h3><ol><li><p><strong>stages</strong>被外层的<code>pipeline { }</code>包裹，内部包含多个<strong>stage</strong></p></li><li><p>每个<strong>stage</strong>代码块内包含多个<strong>steps { }</strong>，一个<strong>stage</strong>下至少有一个<strong>steps { }</strong>，一般也就是一个<strong>steps { }</strong></p></li><li><p>我们可以在一个steps下写调用一个或者几个方法，也就是两三行代码。具体的代码实现，可以放在别的包里面</p></li><li><p>stages下可以包含多个stage, 在一个Declarative Pipeline脚本中，只允许出现一次stages</p><p>以后我们大部分的pipeline代码都在每一个stage里面的steps下,如下示例</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Build"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Build"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Test"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Test"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Deploy"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Deploy"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面println是Groovy的语法，就是一个打印语句。不管以后pipeline代码有多么复杂，都是以这个为基础骨架，例如添加一些try catch语句还有其他的指令。</p></blockquote><h3 id="stage指令"><a href="#stage指令" class="headerlink" title="stage指令"></a>stage指令</h3><p>该stage指令在该stages部分中，应包含步骤部分，可选agent部分或其他特定于阶段的指令。实际上，Pipeline完成的所有实际工作都将包含在一个或多个stage指令中。</p><blockquote><p>stage一定是在stages{…}里面，一个pipeline{…}中至少有一个stages{…}和一个stage{…}.这里多说一句，一个stage{…}中至少有一个steps{…}。stage{…}还有一个特点就是，里面有一个强制的字符串参数，例如下面的”Example”，这个字符串参数就是描述这个stage是干嘛的，这个字符串参数是不支持变量的，只能你自己取名一个描述字段。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="environment指令"><a href="#environment指令" class="headerlink" title="environment指令"></a>environment指令</h3><p><strong>environment</strong>指令定义一个键-值，该键-值对将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>解释一下什么意思，environment{…}, 大括号里面写一些键值对，也就是定义一些变量并赋值，这些变量就是<strong>环境变量</strong>。环境变量的作用范围，取决你environment{…}所写的位置，你可以写在顶层环境变量，让所有的stage下的step共享这些变量，也可以单独定义在某一个stage下，只能供这个stage去调用变量，其他的stage不能共享这些变量。</p><p>一般来说，我们基本上上定义全局环境变量，如果是局部环境变量，我们直接用def关键字声明就可以，没必要放environment{…}里面</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        boolStatus = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Demo'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(boolStatus == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// Todo</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="options指令"><a href="#options指令" class="headerlink" title="options指令"></a>options指令</h3><p>该options指令允许在Pipeline本身内配置Pipeline专用选项，Pipeline提供了许多这些选项，例如buildDiscarder，但它们也可能由插件提供，例如 timestamps。</p><p>一个pipeline{…}内只运行出现<strong>一次<code>options{…}</code></strong>, 下面看一个下这个retry的使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    option &#123;</span><br><span class="line">        retry(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Demo"</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">//Tode</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的整个pipeline{…}, 如果在<a href="https://www.baidu.com/s?wd=jenkins&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">jenkins</a>上job执行失败，会继续执行，如果再遇到失败，继续执行一次，总共执行三次</p><p>把options{…}放在顶层里，也可以放在具体的某一个stage下，意味这这个stage下所有代码，如果遇到失败，最多执行三次。    </p></blockquote><h3 id="parameters指令"><a href="#parameters指令" class="headerlink" title="parameters指令"></a>parameters指令</h3><p><strong>parameters</strong>是参数的意思，parameters指令提供用户在触发Pipeline时应提供的参数列表，这些用户指定的参数的值通过该params对象可用于Pipeline步骤。</p><p>我们很多人听过<strong>参数化构建(Build with Parameters)</strong>，也可能知道如何在一个jenkins job上，通过UI创建不同的参数，例如有<strong>字符串参数</strong>，<strong>布尔选择参数</strong>，<strong>下拉多选参数</strong>等。这些参数即可以通过UI点击创建，也可以通过pipeline代码去写出来。我们先来看看了解有那些具体参数类型，然后挑选几个，分别用UI和代码方式去实现创建这些参数。</p><h4 id="字符串参数"><a href="#字符串参数" class="headerlink" title="字符串参数"></a>字符串参数</h4><p>就是定义一个字符串参数，用户可以在Jenkins UI上输入字符串，常见使用这个参数的场景有，用户名，收件人邮箱，文件网络路径，主机名称的或者url等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any   </span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'DEPLOY_ENV'</span>, <span class="string">defaultValue:</span> <span class="string">'staging'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔值参数"><a href="#布尔值参数" class="headerlink" title="布尔值参数"></a>布尔值参数</h4><p>就是定义一个布尔类型参数，用户可以在Jenkins UI上选择是还是否，选择是表示代码会执行这部分，如果选择否，会跳过这部分。一般需要使用布尔值的场景有，执行一些特定集成的脚本或则工作，或者事后清除环境，例如清楚Jenkins的workspace这样的动作。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        booleanParam(<span class="string">name:</span> <span class="string">'DEBUG_BUILD'</span>, <span class="string">defaultValue:</span> <span class="literal">true</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本参数"><a href="#文本参数" class="headerlink" title="文本参数"></a>文本参数</h4><p>文本（text）的参数就是支持写很多行的字符串，这个变量我好像没有使用过，例如想给发送一段欢迎的消息，你可以采用text的参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        text(<span class="string">name:</span> <span class="string">'Welcome_text'</span>, <span class="string">defaultValue:</span> <span class="string">'One\nTwo\nThree\n'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的\n表示换行，上面写了三行的text</p></blockquote><h4 id="选择参数"><a href="#选择参数" class="headerlink" title="选择参数"></a>选择参数</h4><p>选择（choice）的参数就是支持用户从多个选择项中，选择一个值用来表示这个变量的值。工作中常用的场景，有选择服务器类型，选择版本号等。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(<span class="string">name:</span> <span class="string">'ENV_TYPE'</span>, <span class="string">choices:</span> [<span class="string">'test'</span>, <span class="string">'dev'</span>, <span class="string">'product'</span>], <span class="string">description:</span> <span class="string">'test means test env,….'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件参数"><a href="#文件参数" class="headerlink" title="文件参数"></a>文件参数</h4><p>文件（file）参数就是在Jenkins 参数化构建UI上提供一个文件路径的输入框，Jenkins会自动去你提供的网络路径去查找并下载。一般伴随着还有你需要在Pipleline代码中写解析文件。也有这样场景，这个构建job就是把一个war包部署到服务器上特定位置，你可以使用这个文件参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line"><span class="symbol">        name:</span> <span class="string">'FILE'</span>, <span class="string">description:</span> <span class="string">'Some file to upload'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="密码参数"><a href="#密码参数" class="headerlink" title="密码参数"></a>密码参数</h4><p>密码（password）参数就是在Jenkins 参数化构建UI提供一个密文密码输入框，例如，我需要在一些linux机器上做自动化操作，需要提供机器的用户名和密码，由于密码涉及安全问题，一般都采用暗文显示，这个时候你就不能用string类型参数，就需要使用password参数类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        password(<span class="string">name:</span> <span class="string">'PASSWORD'</span>, <span class="string">defaultValue:</span> <span class="string">'SECRET'</span>, <span class="string">description:</span> <span class="string">'A secret password'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="web-ui方式"><a href="#web-ui方式" class="headerlink" title="web ui方式"></a>web ui方式</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/paramsFlow.gif" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                println <span class="string">"stringValue = $&#123;stringValue&#125;"</span></span><br><span class="line">                println <span class="string">"passwordValue = $&#123;passwordValue&#125;"</span></span><br><span class="line">                println <span class="string">"boolValue = $&#123;boolValue&#125;"</span></span><br><span class="line">                println <span class="string">"choseValue = $&#123;choseValue&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="triggers指令"><a href="#triggers指令" class="headerlink" title="triggers指令"></a>triggers指令</h3><ol><li>该triggers指令定义了Pipeline应重新触发的自动化方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成可能已经存在</li><li>目前有三个可用的触发器是cron和pollSCM 和 upstream    </li><li>在一个pipeline{…}代码中，只运行出现一次triggers{…},而且这个指令不是必须存在的。</li><li>triggers是触发器的意思，所以这块是设置什么条件下触发pipeline代码执行，以及触发的频率</li></ol><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>接受一个cron风格的字符串来定义Pipeline应重新触发的常规间隔，例如： triggers { cron(‘H 4/* 0 0 1-5’) }</p><p>####pollSCM</p><p> 接受一个cron风格的字符串来定义Jenkins应该检查新的源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers { pollSCM(‘H 4/* 0 0 1-5’) }</p><h4 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h4><p>接受逗号分隔的作业字符串和阈值。 当字符串中的任何作业以最小阈值结束时，将重新触发pipeline。例如：triggers { upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p><p>举例一个可能利用scm的场景，如果一个公司做到了很好的代码覆盖测试，一般都会，如果监控到有人提交代码，就会自动化触发启动相关的单元测试。这个场景就是适合在pipeline代码里使用triggers指令，下面代码举例一个pollSCM的基本使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        pollSCM (‘H H(<span class="number">9</span><span class="number">-16</span>)/<span class="number">2</span> * * <span class="number">1</span><span class="number">-5</span>)’)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释下“H H(9-16)/2 <em> </em> 1-5)”的含义，这个你可以在上面截图这个页面点击右侧这个问号，出来具体含义。第一步，先根据空格，把字符串切割成5段</p></blockquote><p>所以，H H(9-16)/2 <em> </em> 1-5) 的含义就是：</p><blockquote><p>第一部分“H” 表示hash，记住不是表示hour，是一个散列值，含义就是在一个小时之内，会执行一次，但是这次是一个散列值，而且不会并发执行。</p><p>第二部分“H(9-16)/2”，表示白天在早上9点到下午5点，每间隔2小时执行一次。</p><p>第三部分“*“，每天执行</p><p>第四部分“*“表示每月执行</p><p>第五部分“1-5“ 表示周一到周五执行</p><p>所以上面这个表达式“H H(9-16)/2 <em> </em> 1-5) “的含义就是，在每个月的周一到周五的白天，从早上9点到下午5点，每间隔两个小时去触发一次自动化构建。 这个就比较适合，我们每天上班，间隔两个小时去跑一次单元自动化测试。间隔时间长短，取决服务器压力和业务具体场景</p></blockquote><h3 id="input指令"><a href="#input指令" class="headerlink" title="input指令"></a>input指令</h3><p>该input指令允许在一个stage{…}显示提示输入等待。在inpt{…}写一些条件，然后用户触发构建这个job，但是这个时候没有接收到有效的input, job会一直在等待中；</p><p>下面解释input{…}里面支持写那些option。</p><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>必选，这个message会在用户提交构建的页面显示，提示用户提交相关的input条件</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>可选，可以作为这个input的标记符，默认的标记符是这个stage的名称</p><h4 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h4><p>可选， 主要是在ok按钮上显示一些文本，在input表单里</p><h4 id="submitter"><a href="#submitter" class="headerlink" title="submitter"></a>submitter</h4><p>可选，里面可以写多个用户名称或者组名称，用逗号隔开。意思就是，只有这写名称的对应用户登陆jenkins，才能提交这个input动作，如果不写，默认是任何人都可以提交input。</p><h4 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h4><p>可选，我们前面学的parameters没有区别，就是定义一些参数的地方    </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/inputFlow.gif" alt=""></p><p>代码示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            input &#123;</span><br><span class="line">                message <span class="string">"是否继续执发布操作?"</span></span><br><span class="line">                ok <span class="string">"是的,继续执行"</span></span><br><span class="line">                <span class="comment">// 用户,好像设置了没什么用</span></span><br><span class="line">                submitter <span class="string">"admin"</span></span><br><span class="line">                parameters &#123;</span><br><span class="line">                    string(<span class="string">name:</span> <span class="string">'NAME'</span>, <span class="string">defaultValue:</span> <span class="string">'zhimma'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello, $&#123;NAME&#125;, nice to meet you."</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when指令"><a href="#when指令" class="headerlink" title="when指令"></a>when指令</h3><p><strong>when</strong>指令允许流水线根据给定的条件决定是否应该执行阶段</p><p> <strong>when</strong>指令必须包含至少一个条件。</p><p><strong>when</strong> 指令包含多个条件, 所有的子条件必须返回True，阶段才能执行</p><p>下面详细解释下<strong>when</strong>可以使用的内置条件</p><h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h4><p>当正在构建的分支与模式给定的分支匹配时，执行这个阶段;例如：<code>when { branch &#39;master&#39; }</code>。请注意，这仅适用于多分支Pipeline。</p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>当指定的环境变量是给定的值时，执行这个步骤, 例如: <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></p><h4 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h4><p>当指定的Groovy表达式评估为true时，执行这个阶段, 例如: <code>when { expression { return params.DEBUG_BUILD } }</code></p><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>当嵌套条件是错误时，执行这个阶段,必须包含一个条件，例如: <code>when { not { branch &#39;master&#39; } }</code></p><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p>当所有的嵌套条件都正确时，执行这个阶段,必须包含至少一个条件，例如: <code>when { allOf { branch &#39;master&#39;; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; } }</code></p><h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>当至少有一个嵌套条件为真时，执行这个阶段,必须包含至少一个条件，例如: <code>when { anyOf { branch &#39;master&#39;; branch &#39;staging&#39; } }</code></p><h4 id="在进入-stage的-agent前测试执行when"><a href="#在进入-stage的-agent前测试执行when" class="headerlink" title="在进入 stage的 agent前测试执行when"></a>在进入 <code>stage</code>的 <code>agent</code>前测试执行<code>when</code></h4><p>默认情况下, 如果定义了某个阶段的agent，在进入该<code>stage</code>的<code>agent</code>后该 <code>stage</code>的<code>when</code> 条件将会被执行。但是, 可以通过在 <code>when</code>块中指定<code>beforeAgent</code> 选项来更改此选项。如果<code>beforeAgent</code> 被设置为 <code>true</code>, 那么就会首先对<code>when</code>条件进行评估 , 并且只有在<code>when</code>条件验证为真时才会进入<code>agent</code> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        quick_test = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    echo <span class="string">'Hello World'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Example Deploy'</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; </span><br><span class="line">                   <span class="keyword">return</span>  (quick_test == <span class="string">"true"</span>)  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://testerhome.com/topics/9977" target="_blank" rel="noopener">https://testerhome.com/topics/9977</a></p><p><a href="https://testerhome.com/topics/17251" target="_blank" rel="noopener">https://testerhome.com/topics/17251</a></p>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Jenkins的Pipeline发布代码至远程服务器</title>
      <link href="/2019/02/16/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84Pipeline%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/02/16/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84Pipeline%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>通常我们软件开发流程大概是下面所示：</p><p>本地开发-&gt;本地自测-&gt;提交代码-&gt;编译发布-&gt;测试人员测试-&gt;提交至生产</p><p>在发布阶段，</p><ol><li>有的项目是采用版本控制工具在Linux服务器上拉取对应分支的最新代码</li><li>有的是在本地对比Git版本的差异，生成差异的文件，打包上传至服务器，进行覆盖原来的代码文件完成发布</li></ol><p>上面2种方法是我工作中遇到的，下面我们来学习一种新的发布方式：<strong>Jenkins</strong></p><blockquote><p><strong>Jenkins可以帮你在写完代码后，一键完成开发过程中的一系列工作</strong></p></blockquote><p>特别是在开发阶段，配合<strong>WebHook</strong>可以非常省心的完成代码发布工作，开发者只需要提交代码，就会触发Jenkins发布任务的执行，从而将最新代码部署到服务器上</p><h2 id="什么是Jenkins？"><a href="#什么是Jenkins？" class="headerlink" title="什么是Jenkins？"></a>什么是Jenkins？</h2><p><strong>Jenkins</strong>是一个Java开放的开源程序，所以，需要提前安装Java JDK环境，能支持安装到windows,mac,linux平台，主要是一个管理工具</p><h2 id="为什么要使用Jenkins"><a href="#为什么要使用Jenkins" class="headerlink" title="为什么要使用Jenkins?"></a>为什么要使用Jenkins?</h2><p>我们用它，主要是项目上的持续集成和持续交付。持续集成对应英文（Continuous Integration），有时候简称CI，持续交付对应英文（Continuous Delivery），简称CD，以后，听到了CI和CD，就明白了什么意思。下面这张图，是Jenkins在实际项目运用上的一个经典的流程图</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/jenkinsFlow.png" alt=""></p><p>##安装Jenkins</p><p>安装的方式很多，我这里学习Jenkins采用的是Docker创建容器的方式运行</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><code>docker pull jenkins</code></p><p>下载完成，查看下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls</span><br><span class="line">REPOSITORY                                 TAG                 IMAGE ID     </span><br><span class="line">jenkins/jenkins                            latest              9b74eda1c268</span><br></pre></td></tr></table></figure><h3 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h3><p>这个目录根据个人需求，可以进行重新指定，我指定的是：<code>/Users/zhimma/jenkins</code></p><p><code>mkdir /Users/zhimma/jenkins</code></p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><code>docker run -d -p 49001:8080 -v $PWD/jenkins:/var/jenkins_home -t jenkins/jenkins</code></p><blockquote><p>我映射了容器的端口8080到主机上的端口49001， 第一个数字代表主机上的端口，而最后一个代表容器的端口</p></blockquote><p>运行后，Docker会帮我们创建一个Jenkins的运行环境的容器，使用<code>docker ps</code> 查看容器启动情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES</span><br><span class="line">782c2fb5ef74        jenkins/jenkins     &quot;/sbin/tini -- /usr/…&quot;   3 days ago          Up 3 days           50000/tcp, 0.0.0.0:49001-&gt;8080/tcp   trusting_burnell</span><br></pre></td></tr></table></figure><p>到这，我们的Jenkins环境搭建完成，下面我们做一些初始化工作</p><h3 id="初始化Jenkins"><a href="#初始化Jenkins" class="headerlink" title="初始化Jenkins"></a>初始化Jenkins</h3><h4 id="解锁Jenkins"><a href="#解锁Jenkins" class="headerlink" title="解锁Jenkins"></a>解锁Jenkins</h4><p>在浏览器中输入<code>localhost:49001</code>，进入web页面，第一次需要先解锁Jenkins</p><p>进入<code>/Users/zhimma/jenkins/secrets</code>目录，制<code>initialAdminPassword</code>文件的内容就是首次解锁的密码</p><h4 id="安装推荐插件"><a href="#安装推荐插件" class="headerlink" title="安装推荐插件"></a>安装推荐插件</h4><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/init.gif" alt="初始化"></p><h4 id="设置管理员"><a href="#设置管理员" class="headerlink" title="设置管理员"></a>设置管理员</h4><h3 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h3><p>我们目前使用GitLab管理代码，所以我们先安装下面几个插件</p><ul><li>GitLab Plugin</li><li>Gitlab Hook Plugin</li><li>AnsiColor（可选）这个插件可以让Jenkins的控制台输出的log带有颜色（就和linux控制台那样）</li></ul><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/installPlugin.gif" alt="安装插件"></p><p>###配置SSH</p><p>本机生成SSH：<code>ssh-keygen -t rsa -C &quot;Your email&quot;</code>，最终生成id_rsa和id_rsa.pub(公钥)</p><p>Gitlab上添加公钥：复制id_rsa.pub里面的公钥添加到Gitlab</p><p>Jenkins上配置密钥到SSH：复制id_rsa里面的公钥添加到Jenkins（private key选项）</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/ssh.gif" alt=""></p><p>##开始Pipeline</p><p>在Jenkins中，把每一段管道比作是不同的Job，我们提到Jenkins的工作流程，build-deploy-test-release，每个流程之间我们都可以用Pipeline来连接，大致如下效果图。</p><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/flow.png" alt=""></p><blockquote><p>SCM:软件配置管理工具</p></blockquote><p>###创建Pipeline风格的项目</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/createProject.gif" alt=""></p><p>###实现Pipeline-Web UI方式</p><p>如下图所示：</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/webuiway.gif" alt=""></p><p>###实现Pipeline-Jenkinsfile方式</p><p>上面通过Web UI方式只适用于非常简单的任务，而大型复杂的任务最好采用<code>Jenkinsfile</code>方式并纳入SCM管理。 这次我选择从SCM中的<code>Jenkinsfile</code>来定义管道。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/scm.gif" alt=""></p><p>我们需要在自己的项目根目录创建<code>Jenkinsfile</code>文件，在里面编写具体的发布流程代码。</p><h3 id="使用Jenkinsfile"><a href="#使用Jenkinsfile" class="headerlink" title="使用Jenkinsfile"></a>使用Jenkinsfile</h3><p>接下来详细介绍一下怎样编写<code>Jenkinsfile</code>来完成各种复杂的任务。</p><p>Pipeline支持两种形式，一种是<code>Declarative</code>管道，一个是<code>Scripted</code>管道。</p><p>一个<code>Jenkinsfile</code>就是一个文本文件，里面定义了<code>Jenkins Pipeline</code>。 将这个文本文件放到项目的根目录下面，纳入版本系统。</p><p>####Declarative风格类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个Declarative类型的Pipeline，目前实际开发基本采用这种方式；</p><ul><li>第一行是小写的pipeline，然后一对大括{}，大括号里面就是代码块，用来和别的代码块隔离出来，pipeline是一个语法标识符,也叫关键字，如果是Declarative类型，一定是pipeline {}这样起头的；如果是脚本文件，pipeline不要求一定是第一行代码。也就是说pipeline前面可以有其他代码，例如导入语句，和其他功能代码。pipeline是一个执行pipeline代码的入口，jenkins可以根据这个入门开始执行里面不同stage</li><li>第二行agent any，agent是一个语法关键字，any是一个option类型，agent是代理的意思，这个和选择用jenkins平台上那一台机器去执行任务构建有关</li><li>第三行stages{}, stages是多个stage的意思，也就是说一个stages可以包含多个stage，从上面代码结果你也可以看出来。上面写了三个stage，根据你任务需要，你可以写十多个都可以</li><li>第四行stage(‘Build’) {}, 这个就是具体定义一个stage,一般一个stage就是指完成一个业务场景。<strong>Build</strong>是认为给这个任务取一个名字。</li><li>第五行steps{},字面意思就是很多个步骤的意思。这里提一下，看到了steps，当然还有step这个指令。一般来说，一个steps{}里面就写几行代码，或者一个try catch语句。</li></ul><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><p><code>post</code> section 定义了管道执行结束后要进行的操作。支持在里面定义很多<code>Conditions</code>块： <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code> 和 <code>unstable</code>。 这些条件块会根据不同的返回结果来执行不同的逻辑。</p><ul><li>always：不管返回什么状态都会执行</li><li>changed：如果当前管道返回值和上一次已经完成的管道返回值不同时候执行</li><li>failure：当前管道返回状态值为”failed”时候执行，在Web UI界面上面是红色的标志</li><li>success：当前管道返回状态值为”success”时候执行，在Web UI界面上面是绿色的标志</li><li>unstable：当前管道返回状态值为”unstable”时候执行，通常因为测试失败，代码不合法引起的。在Web UI界面上面是黄色的标志</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">'I will always say Hello again!'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h5><p>由一个或多个<code>stage</code>指令组成，stages块也是核心逻辑的部分。 我们建议对于每个独立的交付部分（比如<code>Build</code>,<code>Test</code>,<code>Deploy</code>）都应该至少定义一个<code>stage</code>指令。比如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            echo <span class="string">'Hello World'</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h5><p>在<code>stage</code>中定义一系列的<code>step</code>来执行命令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123; ①</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h5><p><code>agent</code>指令指定整个管道或某个特定的<code>stage</code>的执行环境。它的参数可用使用：</p><ol><li>any - 任意一个可用的agent</li><li>none - 如果放在pipeline顶层，那么每一个<code>stage</code>都需要定义自己的<code>agent</code>指令</li><li>label - 在jenkins环境中指定标签的agent上面执行，比如<code>agent { label &#39;my-defined-label&#39; }</code></li><li>node - <code>agent { node { label &#39;labelName&#39; } }</code> 和 label一样，但是可用定义更多可选项</li><li>docker - 指定在docker容器中运行</li><li>dockerfile - 使用源码根目录下面的<code>Dockerfile</code>构建容器来运行</li></ol><h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h5><p><code>environment</code>定义键值对的环境变量</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">'clang'</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">'my-prefined-secret-text'</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'printenv'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p>还能定义一些管道特定的选项，介绍几个常用的：</p><ul><li>skipDefaultCheckout - 在<code>agent</code>指令中忽略源码<code>checkout</code>这一步骤。</li><li>timeout - 超时设置<code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></li><li>retry - 直到成功的重试次数<code>options { retry(3) }</code></li><li>timestamps - 控制台输出前面加时间戳<code>options { timestamps() }</code></li></ul><h5 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h5><p>参数指令，触发这个管道需要用户指定的参数，然后在<code>step</code>中通过<code>params</code>对象访问这些参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'PERSON'</span>, <span class="string">defaultValue:</span> <span class="string">'Mr Jenkins'</span>, <span class="string">description:</span> <span class="string">'Who should I say hello to?'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello $&#123;params.PERSON&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="triggers"><a href="#triggers" class="headerlink" title="triggers"></a>triggers</h5><p>触发器指令定义了这个管道何时该执行，一般我们会将管道和GitHub、GitLab、BitBucket关联， 然后使用它们的webhooks来触发，就不需要这个指令了。如果不适用<code>webhooks</code>，就可以定义两种<code>cron</code>和<code>pollSCM</code></p><ul><li>cron - linux的cron格式<code>triggers { cron(&#39;H 4/* 0 0 1-5&#39;) }</code></li><li>pollSCM - jenkins的<code>poll scm</code>语法，比如<code>triggers { pollSCM(&#39;H 4/* 0 0 1-5&#39;) }</code></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">'H 4/* 0 0 1-5'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h5><p><code>stage</code>指令定义在<code>stages</code>块中，里面必须至少包含一个<code>steps</code>指令，一个可选的<code>agent</code>指令，以及其他stage相关指令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h5><p>定义自动安装并自动放入<code>PATH</code>里面的工具集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">'apache-maven-3.0.1'</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'mvn --version'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：① 工具名称必须预先在Jenkins中配置好了 → Global Tool Configuration.</p><h5 id="内置条件"><a href="#内置条件" class="headerlink" title="内置条件"></a>内置条件</h5><ul><li>branch - 分支匹配才执行 <code>when { branch &#39;master&#39; }</code></li><li>environment - 环境变量匹配才执行 <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></li><li>expression - groovy表达式为真才执行 <code>expression { return params.DEBUG_BUILD } }</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Declarative //</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;Example Build&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &apos;Hello World&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Example Deploy&apos;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &apos;production&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &apos;Deploying&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h5><p>这里就是实实在在的执行步骤了，每个步骤step都具体干些什么东西， 前面的<code>Sections</code>、<code>Directives</code>算控制逻辑和环境准备，这里的就是真实执行步骤。</p><p>这部分内容最多不可能全部讲完，<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="noopener">官方Step指南</a> 包含所有的东西。</p><p><code>Declared Pipeline</code>和<code>Scripted Pipeline</code>都能使用这些step，除了下面这个特殊的<code>script</code>。</p><p>一个特殊的step就是<code>script</code>，它可以让你在声明管道中执行脚本，使用groovy语法，这个非常有用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">'chrome'</span>, <span class="string">'firefox'</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">"Testing the $&#123;browsers[i]&#125; browser"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 一个优雅的退出pipeline的方法，这里可执行任意逻辑</span></span><br><span class="line">                    <span class="keyword">if</span>( $VALUE1 == $VALUE2 ) &#123;</span><br><span class="line">                       currentBuild.result = <span class="string">'SUCCESS'</span></span><br><span class="line">                       <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scripted风格类型"><a href="#Scripted风格类型" class="headerlink" title="Scripted风格类型"></a>Scripted风格类型</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node &#123;  </span><br><span class="line">    stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 这个代码，有两点和上面不同。</p><p>第一个是Scripted模式是node{}开头，并没有pipeline{}直观。</p><p>第二个要指出的是，scripted模式下没有stages这个关键字或者指令，只有stage。上面其实可以node(‘Node name’) {}来开头，Node name就是从节点或master节点的名称。</p></blockquote><p><code>Scripted Pipeline</code>没那么多东西，就是定义一个<code>node</code>， 里面多个<code>stage</code>，里面就是使用Groovy语法执行各个<code>step</code>了，非常简单和清晰，也非常灵活。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Jenkins定了很多内置的环境变量，可在文档<code>localhost:49001/pipeline-syntax/globals#env</code>找到， 通过<code>env</code>直接使用它们：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 测试环境变量</span></span><br><span class="line">            echo <span class="string">"Running $&#123;env.BUILD_ID&#125; on $&#123;env.JENKINS_URL&#125;"</span></span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录修改Jenkinsfile后，提交到服务器，点击立即构建，查看<code>Console Output</code>输出系统的环境变量</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/envParams.png" alt=""></p><h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><p><a href="https://blog.csdn.net/u011541946/article/details/83152494" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/details/83152494</a></p><p><a href="https://blog.csdn.net/u011541946/article/category/8223796/2" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/category/8223796/2</a>?</p><p><a href="https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html" target="_blank" rel="noopener">https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx单域名配置多Vue工程和PHP接口</title>
      <link href="/2019/02/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8CPHP%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/02/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8CPHP%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/">点击查看<strong>单域名配置多Vue工程和多PHP接口</strong></a></p><p>项目中遇到了一个问题，需要一个域名完成整个项目的部署，之前是使用的多个域名进行解析的，例如：</p><p>后台页面：<code>backend.domain.com</code>,后台接口：<code>backend-api.domain.com</code></p><p>前台页面：<code>fontend.domain.com</code>,前台接口：<code>fontend-api.domain.com</code></p><p>现在的需求是：<code>domain.com</code>就可以访问到前后台所有页面的接口</p><p>解决思路：<code>Nginx</code>和<code>Vue路由配置</code></p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p><code>vue-cli3.x</code><br>在vue.config.js的文件中加入（此处为了打包后的JS,CSS等文件的路径引向）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  baseUrl:&apos;/frontend/&apos;  //根据www.xxx.com/后面的路径写入（比如www.domain.com/frontend）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/config/#baseurl" target="_blank" rel="noopener">baseUrl官方文档</a></p><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配含有backend的</span></span><br><span class="line"><span class="attribute">location</span> /backend &#123;</span><br><span class="line">    <span class="comment"># 重新定义root目录</span></span><br><span class="line">    <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web;</span><br><span class="line">    <span class="comment"># 或者</span></span><br><span class="line">    <span class="comment"># alias /Users/zhimma/Data/www/MK_Project/public/web/backend;</span></span><br><span class="line">    <span class="comment"># 解决刷新页面404错误</span></span><br><span class="line">    <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 尝试t尝试列出的文件并设置内部文件指向。</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-配置"><a href="#PHP-配置" class="headerlink" title="PHP 配置"></a>PHP 配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrite</span>; </span><br><span class="line"><span class="attribute">location</span> <span class="variable">@rewrite</span> &#123; </span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /index.php?_url=/<span class="variable">$1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php</span> &#123; </span><br><span class="line"><span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line"><span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line"></span><br><span class="line"><span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> PATH_INFO <span class="variable">$fastcgi_path_info</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_path_info</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>; </span><br><span class="line"><span class="attribute">include</span> fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> mk.ma;</span><br><span class="line">    <span class="attribute">index</span>       index.php index.html index default;</span><br><span class="line">    <span class="attribute">root</span>        /Users/zhimma/Data/www/MK_Project/public;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrite</span>; </span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@rewrite</span> &#123; </span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /index.php?_url=/<span class="variable">$1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php</span> &#123; </span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">        <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">         </span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_INFO <span class="variable">$fastcgi_path_info</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_path_info</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>; </span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment"># 匹配含有backend的</span></span><br><span class="line">    <span class="attribute">location</span> /backend &#123;</span><br><span class="line">        <span class="comment"># 重新定义root目录</span></span><br><span class="line">        <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web;</span><br><span class="line">        <span class="comment"># 或者</span></span><br><span class="line">        <span class="comment"># alias /Users/zhimma/Data/www/MK_Project/public/web/backend;</span></span><br><span class="line">        <span class="comment"># 解决刷新页面404错误</span></span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 尝试t尝试列出的文件并设置内部文件指向。</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /frontend &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/MK_Project/public/web/frontend;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /frontend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /favicon.ico &#123;</span><br><span class="line">        <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web/backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后解析域名，访问地址就只需要一个</p><p>后台：<code>domain.com/backend</code></p><p>前台：<code>domain.com/frontend</code></p><p>接口地址统一调用：<code>domain.com</code></p><p>总结一下：</p><p>Nginx功能很强大，下一步需要彻底弄懂<strong>Nginx</strong>的一些配置项，方便项目的一些需求</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker相关知识再整理(1)</title>
      <link href="/2019/01/28/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%86%8D%E6%95%B4%E7%90%86(1)/"/>
      <url>/2019/01/28/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%86%8D%E6%95%B4%E7%90%86(1)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>个人理解为是创建容器的基础，类似于安装系统是所需的ISO文件，镜像就是生成容器所需的ISO。</p><h3 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><h5 id="列出镜像-不显示中间层镜像"><a href="#列出镜像-不显示中间层镜像" class="headerlink" title="列出镜像-不显示中间层镜像"></a>列出镜像-不显示中间层镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls</span><br><span class="line">REPOSITORY           TAG          IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                latest       42b4762643dc        5 days ago          109MB</span><br></pre></td></tr></table></figure><blockquote><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>    </p></blockquote><blockquote><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong></p></blockquote><h5 id="所有镜像："><a href="#所有镜像：" class="headerlink" title="所有镜像："></a>所有镜像：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls -a</span><br></pre></td></tr></table></figure><h5 id="特定格式显示镜像列表"><a href="#特定格式显示镜像列表" class="headerlink" title="特定格式显示镜像列表"></a>特定格式显示镜像列表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls -q</span><br><span class="line">42b4762643dc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br><span class="line">5f515359c7f8: redis</span><br></pre></td></tr></table></figure><h4 id="查看镜像、容器、数据卷所占用的空间"><a href="#查看镜像、容器、数据卷所占用的空间" class="headerlink" title="查看镜像、容器、数据卷所占用的空间"></a>查看镜像、容器、数据卷所占用的空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE           RECLAIMABLE</span><br><span class="line">Images              14                  13                  1.347GB        211.8MB (15%)</span><br><span class="line">Containers          23                  22                  4.962kB        0B (0%)</span><br><span class="line">Local Volumes       0                   0                   0B             0B</span><br><span class="line">Build Cache         0                   0                   0B             0B</span><br></pre></td></tr></table></figure><h4 id="悬浮镜像清理"><a href="#悬浮镜像清理" class="headerlink" title="悬浮镜像清理"></a>悬浮镜像清理</h4><p>无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Total reclaimed space: 0B</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有镜像</span></span><br><span class="line">docker image rm $(docker image ls -q)</span><br></pre></td></tr></table></figure><h4 id="保存容器为镜像"><a href="#保存容器为镜像" class="headerlink" title="保存容器为镜像"></a>保存容器为镜像</h4><p>运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker commit \</span><br><span class="line">    --author <span class="string">"Nanme &lt;Email&gt;"</span> \</span><br><span class="line">    --message <span class="string">"Description"</span> \</span><br><span class="line">        webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容、</p></blockquote><p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样</p><blockquote><p>镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></blockquote><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>一个集中的存储、分发镜像的服务，<a href="https://docker_practice.gitee.io/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像</p><blockquote><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p></blockquote><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p>###FROM</p><p><code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一，</p><p>其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p></li><li><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li></ul><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p><p>​    </p><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="bash">COPY hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等</p></blockquote><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在 Docker 官方的 <a href="https://docker_practice.gitee.io/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要<strong>自动解压缩</strong>的场合。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br></pre></td></tr></table></figure><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，用法如下面的格式<code>$KEY</code></p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Mac-Docker-Kubernetes-Rancher-环境初始化</title>
      <link href="/2019/01/25/1-Mac-Docker-Kubernetes-Rancher-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/01/25/1-Mac-Docker-Kubernetes-Rancher-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>composer install --ignore-platform-reqs</code></p>]]></content>
      
      
      <categories>
          
          <category> 容器化服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> k8s </tag>
            
            <tag> Rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX解决跨域问题（Access-Control-Allow-Origin）</title>
      <link href="/2018/11/30/AJAX%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88Access-Control-Allow-Origin%EF%BC%89/"/>
      <url>/2018/11/30/AJAX%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88Access-Control-Allow-Origin%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前遇到过跨域的问题,一直觉得很神秘,也没有多关注,就过去了,今天又看到几篇文章说跨域,闲来无事于是将其整理记录下来；</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>先来阐述下几个概念:</p><p><strong>跨域</strong>:是指浏览器对于JavaScript的同源策略限制,只要协议、域名、端口有任何一个不同,都被当作是不同的域,都不能执行或获取其他网站的资源；</p><p>姑且这么定义吧,举个简单例子,就是<a href="http://www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误" target="_blank" rel="noopener">www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误</a></p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/JavaScript/error1.png" alt="image"></p><a id="more"></a><p>有没有跨域,判断是不是属于跨域,可以参考下面:</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js</a> 调用 <a href="http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/script/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名,不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="https://www.a.com/b.js" target="_blank" rel="noopener">https://www.a.com/b.js</a></td><td>同一域名,不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://70.32.92.74/b.js" target="_blank" rel="noopener">http://70.32.92.74/b.js</a></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://script.a.com/b.js" target="_blank" rel="noopener">http://script.a.com/b.js</a></td><td>主域相同,子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://a.com/b.js" target="_blank" rel="noopener">http://a.com/b.js</a> 同一域名,不同二级域名（同上）</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><p><strong>CORS</strong>:<strong>CORS（Cross-Origin Resource Sharing）跨域资源共享</strong>,定义了必须在访问跨域资源时,浏览器与服务器应该如何沟通.CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是失败.</p><p>服务器端对于<strong>CORS</strong>的支持,主要就是通过设置<strong>Access-Control-Allow-Origin</strong>来进行的.如果浏览器检测到相应的设置,就可以允许Ajax进行跨域的访问.</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Solution-1-服务端程序解决"><a href="#Solution-1-服务端程序解决" class="headerlink" title="Solution 1:服务端程序解决"></a>Solution 1:服务端程序解决</h3><p>如果是双方预定沟通好请求允许数据,可以在服务端添加header头来解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header( &quot;Access-Control-Allow-Origin:*&quot; );</span><br><span class="line"></span><br><span class="line">header( &quot;Access-Control-Allow-Methods:POST,GET&quot; );</span><br></pre></td></tr></table></figure><p>看下面的例子:</p><p>客户端 <a href="http://www.client.com/cliend.html" target="_blank" rel="noopener">www.client.com/cliend.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt; 跨域测试 &lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button style=&quot;width:100px&quot;&gt;click client&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(&quot;button&quot;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://www.server.com/server.php&quot;,</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            data: &#123;&apos;text&apos;: &apos;hello world&apos;&#125;,</span><br><span class="line">            success: function (msg) &#123;</span><br><span class="line">                $(&quot;button&quot;).html(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//允许所有域名获取数据</span><br><span class="line">&lt;?php</span><br><span class="line">$text = $_POST[&apos;text&apos;];</span><br><span class="line">//允许所有的域名</span><br><span class="line">header(&apos;content-type:application:json;charset=utf8&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);</span><br><span class="line">echo json_encode($text);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//允许制定域名获取数据</span><br><span class="line">&lt;?php</span><br><span class="line">$text = $_POST[&apos;text&apos;];</span><br><span class="line">header(&apos;content-type:application:json;charset=utf8&apos;);</span><br><span class="line">$origin = isset($_SERVER[&apos;HTTP_ORIGIN&apos;]) ? $_SERVER[&apos;HTTP_ORIGIN&apos;] : &apos;&apos;;</span><br><span class="line">//允许指定域名</span><br><span class="line">$allow_origin = [</span><br><span class="line">    &apos;http://www.client.com&apos;,</span><br><span class="line">    &apos;http://www.client2.com&apos;</span><br><span class="line">];</span><br><span class="line">if (in_array($origin, $allow_origin)) &#123;</span><br><span class="line">    header(&apos;Access-Control-Allow-Origin:&apos; . $origin);</span><br><span class="line">    header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);</span><br><span class="line">    header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);</span><br><span class="line">&#125;</span><br><span class="line">echo json_encode($text);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这样,理论上就可以解决跨域问题:</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/JavaScript/success%60.png" alt="image"></p><h3 id="Solution-2-代理模式"><a href="#Solution-2-代理模式" class="headerlink" title="Solution 2:代理模式"></a>Solution 2:代理模式</h3><p>解决思路:<br>例如 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a> 需要调用 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a> ,可以写一个接口 <a href="http://www.client.com/server.php" target="_blank" rel="noopener">www.client.com/server.php</a> ,由这个接口在后端去调用 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a> 并拿到返回值,然后再返回给index.html,这就是一个代理的模式.相当于绕过了浏览器端,自然就不存在跨域问题.</p><h3 id="Solution-3-使用JSONP"><a href="#Solution-3-使用JSONP" class="headerlink" title="Solution 3:使用JSONP"></a>Solution 3:使用JSONP</h3><p>使用之前,建议去看下我的另一篇文章<a href="https://blog.bytesclub.com/2017/06/12/JSON%E5%92%8CJSONP/" target="_blank" rel="noopener">Json和JsonP</a>,然后再过来实践；</p><p>还是直接上代码:</p><p>客户端 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt; 跨域测试 &lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;clickMe&quot; style=&quot;width:100px&quot;&gt;click get jsonP&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(&quot;#clickMe&quot;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://www.server.com/jsonP.json&quot;,</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            dataType: &quot;jsonP&quot;,</span><br><span class="line">            data: &#123;&apos;text&apos;: &apos;hello world&apos;&#125;,</span><br><span class="line">            jsonpCallback: &apos;returnData&apos;,  //可自定义 函数名</span><br><span class="line">            success: function (msg) &#123;</span><br><span class="line">                alert(msg.text);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (XMLHttpRequest, textStatus, errorThrown) &#123;</span><br><span class="line">                alert(XMLHttpRequest.status);</span><br><span class="line">                alert(XMLHttpRequest.readyState);</span><br><span class="line">                alert(textStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/jsonP.json" target="_blank" rel="noopener">www.server.com/jsonP.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnData(&#123;&quot;text&quot;:&quot;hello jsonP&quot;&#125;);</span><br></pre></td></tr></table></figure><p>同样的也可以跨域获取数据</p><h2 id="Solution-4-使用html5-API-postMessage-转自这里"><a href="#Solution-4-使用html5-API-postMessage-转自这里" class="headerlink" title="Solution 4:使用html5 API postMessage(转自这里)"></a>Solution 4:<a href="http://blog.xieliqun.com/2016/08/25/postMessage-cross-domain/" target="_blank" rel="noopener">使用html5 API postMessage(转自这里)</a></h2><p>客户端 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;iframe style=&quot;display: none&quot; src=&quot;http://www.server.com/server.html&quot; name=&quot;postIframe&quot; onload=&quot;messageLoad()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function messageLoad() &#123;</span><br><span class="line">        var url = &quot;http://www.server.com&quot;;</span><br><span class="line">        window.postIframe.postMessage(&quot;给我tsort的信息&quot;, url); //发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    window.onmessage = function (e) &#123;</span><br><span class="line">        e = e || event;</span><br><span class="line">        console.log(e.data); //接收b返回的数据,在控制台有两次输出</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/server.html" target="_blank" rel="noopener">www.server.com/server.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onmessage = function(e)&#123;</span><br><span class="line">        e = e || event;</span><br><span class="line">        alert(e.data); //立即弹出a发送过来的数据</span><br><span class="line">        e.source.postMessage(&quot;好的,请稍等三秒！&quot;,e.origin); //立即回复a</span><br><span class="line"></span><br><span class="line">        var postData = &#123;name:&quot;tsrot&quot;,age:24&#125;;</span><br><span class="line">        var strData = JSON.stringify(postData); //json对象转化为字符串</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            e.source.postMessage(strData,e.origin);</span><br><span class="line">        &#125;,3000); //3秒后向a发送数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7☞lnmp环境搭建</title>
      <link href="/2018/11/30/CentOS7%E2%98%9Elnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/30/CentOS7%E2%98%9Elnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>本文转自<a href="https://mos.meituan.com/library/18/how-to-install-lnmp-on-centos7/" target="_blank" rel="noopener">这里</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。</p><p>本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。</p><p>本教程适用于CentOS 7.x版本。<br><a id="more"></a></p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><hr><p><code>yum install nginx</code></p><blockquote><p>如果报没有可用的软件包nginx错误，解决方法这<a href="https://blog.zhimma.com/2018/11/30/%E6%B2%A1%E6%9C%89%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85nginx/">这里</a></p></blockquote><p>按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx：<br><code>systemctl start nginx</code></p><p>检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。<br><code>systemctl status firewalld</code></p><p>如果显示active (running)，则需要调整防火墙规则的配置。</p><p>修改/etc/firewalld/zones/public.xml文件，在zone一节中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;zone&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;service name=&quot;nginx&quot;/&gt;</span><br><span class="line">&lt;zone&gt;</span><br></pre></td></tr></table></figure></p><p>保存后重新加载firewalld服务：<code>systemctl reload firewalld</code></p><p>可以通过浏览器访问 http://&lt;外网IP地址&gt; 来确定Nginx是否已经启动。</p><p>最后将Nginx设置为开机启动：<code>systemctl enable nginx.service</code></p><blockquote><p>测试环境的话，为了方便也可以先禁用掉防火墙</p></blockquote><h2 id="安装MySQL-MariaDB"><a href="#安装MySQL-MariaDB" class="headerlink" title="安装MySQL(MariaDB)"></a>安装MySQL(MariaDB)</h2><p><a href="https://my.oschina.net/Laily/blog/713023" target="_blank" rel="noopener">https://my.oschina.net/Laily/blog/713023</a></p><hr><p>MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。</p><p>我们可以使用yum直接安装MariaDB：<br><code>yum install mariadb-server</code></p><p>安装完成之后，执行以下命令重启MariaDB服务： <code>systemctl start mariadb</code></p><p>MariaDB默认root密码为空，我们需要设置一下，执行脚本：<code>/usr/bin/mysql_secure_installation</code></p><p>首先提示输入当前的root密码：<br><code>Enter current password for root (enter for none):</code></p><p>初始root密码为空，我们直接敲回车进行下一步<br><code>Set root password? [Y/n]</code></p><p>设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码<br><code>Remove anonymous users? [Y/n]</code></p><p>是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续<br><code>Disallow root login remotely? [Y/n]</code></p><p>是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续<br><code>Remove test database and access to it? [Y/n]</code></p><p>是否删除测试用的数据库和权限？ 建议按照默认设置，回车继续<br><code>Reload privilege tables now? [Y/n]</code></p><p>是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。</p><p>完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB：<code>mysql -uroot -p</code></p><p>按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。</p><p>最后我们将MariaDB设置为开机启动<code>systemctl enable mariadb</code></p><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><hr><p><a href="https://www.yaosansi.com/post/install-php-yum-on-centos/" target="_blank" rel="noopener">https://www.yaosansi.com/post/install-php-yum-on-centos/</a><br>我们可以直接使用yum安装PHP：<code>yum install php-fpm php-mysql</code></p><p>安装完成后我们将php-fpm启动：<code>systemctl start php-fpm</code></p><p>将php-fpm设置为开机启动: <code>systemctl enable php-fpm</code></p><p>php安装完成之后，需要设置一下php session的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/lib/php/session/</span><br><span class="line">sudo chown -R apache:apache /var/lib/php/session/</span><br></pre></td></tr></table></figure></p><p>这时php-fpm已经安装完毕，但是现在需要配置一下Nginx，在/etc/nginx/conf.d目录中新建一个名为php.conf的文件，其内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root           /usr/share/php;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行以下命令使我们的配置生效：<code>systemctl reload nginx</code></p><p>以上我们配置了Nginx的8000端口用来测试，如果您在美团云控制台创建机器时选择了绑定防火墙，需要检查该防火墙是否允许80端口，如果不允许的话，可以在防火墙设置中新增防火墙，并关联到该主机。</p><p>我们在/usr/share/php目录下新建一个名为phpinfo.php的文件用来展示phpinfo信息，文件内容为：</p><p><code>&lt;?php echo phpinfo(); ?&gt;</code></p><p>我们从浏览器打开 http://&lt;外网IP地址&gt;:80/phpinfo.php，您就能看到phpinfo信息了，说明我们php环境已经部署成功;</p><h2 id="升级PHP版本"><a href="#升级PHP版本" class="headerlink" title="升级PHP版本"></a>升级PHP版本</h2><hr><p>yum 默认安装的版本是5.4，现在升级PHP版本至5.6</p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span><br><span class="line"></span><br><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面的命令删除php<br><code>yum remove php-common</code><br>然后像安装那样问你是否继续的，输入yes即可</p><p>安装php5.6</p><p><code>yum install -y php56w php56w-opcache php56w-xml php56w-fpm php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring</code></p><p>查看php版本<code>php-fpm --version</code></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl restart mariadb</span><br><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> LNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS中PHP7的安装</title>
      <link href="/2018/11/30/CentOS%E4%B8%ADPHP7%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2018/11/30/CentOS%E4%B8%ADPHP7%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本文安装参考<a href="https://webtatic.com/packages/php70/" target="_blank" rel="noopener">这里</a>，并且全程墙外网;</p><hr><h2 id="查看Linux版本"><a href="#查看Linux版本" class="headerlink" title="查看Linux版本"></a>查看Linux版本</h2><pre><code>cat /etc/centos-releaseCentOS Linux release 7.3.1611 (Core)</code></pre><a id="more"></a><h2 id="删除之前的-PHP-版本"><a href="#删除之前的-PHP-版本" class="headerlink" title="删除之前的 PHP 版本"></a>删除之前的 PHP 版本</h2><pre><code>yum remove php* php-common //如果存在其他版本删除原来的版本  </code></pre><h2 id="rpm-安装-Php7-相应的-yum源"><a href="#rpm-安装-Php7-相应的-yum源" class="headerlink" title="rpm 安装 Php7 相应的 yum源"></a>rpm 安装 Php7 相应的 yum源</h2><pre><code>rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</code></pre><h2 id="yum安装PHP7"><a href="#yum安装PHP7" class="headerlink" title="yum安装PHP7"></a>yum安装PHP7</h2><pre><code>yum install php70w-fpm php70w-opcache</code></pre><h2 id="查看PHP版本"><a href="#查看PHP版本" class="headerlink" title="查看PHP版本"></a>查看PHP版本</h2><pre><code>php -v / php-fpm -v</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Provides</th></tr></thead><tbody><tr><td style="text-align:center">Package</td><td style="text-align:center">Provides</td></tr><tr><td style="text-align:center">php70w</td><td style="text-align:center">mod_php, php70w-zts</td></tr><tr><td style="text-align:center">php70w-bcmath</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-cli</td><td style="text-align:center">php-cgi, php-pcntl, php-readline</td></tr><tr><td style="text-align:center">php70w-common</td><td style="text-align:center">php-api, php-bz2, php-calendar, php-ctype, php-curl, php-date, php-exif, php-fileinfo,php-filter,php-ftp,php-gettext,php-gmp, php-hash, php-iconv, php-json, php-libxml, php-openssl,php-pcre,php-spl,php-tokenizer, php-zend-abi, php-zip, php-zlib</td></tr><tr><td style="text-align:center">php70w-dba</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-devel</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-embedded</td><td style="text-align:center">php-embedded-devel</td></tr><tr><td style="text-align:center">php70w-enchant</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-fpm</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-gd</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-imap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-interbase</td><td style="text-align:center">php_database, php-firebird</td></tr><tr><td style="text-align:center">php70w-intl</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-ldap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mbstring</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mcrypt</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mysql</td><td style="text-align:center">php-mysqli, php_database</td></tr><tr><td style="text-align:center">php70w-mysqlnd</td><td style="text-align:center">php-mysqli, php_database</td></tr><tr><td style="text-align:center">php70w-odbc</td><td style="text-align:center">php-pdo_odbc, php_database</td></tr><tr><td style="text-align:center">php70w-opcache</td><td style="text-align:center">php70w-pecl-zendopcache</td></tr><tr><td style="text-align:center">php70w-pdo</td><td style="text-align:center">php70w-pdo_sqlite, php70w-sqlite3</td></tr><tr><td style="text-align:center">php70w-pdo_dblib</td><td style="text-align:center">php70w-mssql</td></tr><tr><td style="text-align:center">php70w-pear</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-apcu</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-imagick</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-redis</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-xdebug</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pgsql</td><td style="text-align:center">php-pdo_pgsql, php_database</td></tr><tr><td style="text-align:center">php70w-phpdbg</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-process</td><td style="text-align:center">php-posix, php-sysvmsg, php-sysvsem, php-sysvshm</td></tr><tr><td style="text-align:center">php70w-pspell</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-recode</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-snmp</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-soap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-tidy</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-xml</td><td style="text-align:center">php-dom, php-domxml, php-wddx, php-xsl</td></tr><tr><td style="text-align:center">php70w-xmlrpc</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7中，PHP7下，扩展的安装</title>
      <link href="/2018/11/30/Centos7%E4%B8%AD%EF%BC%8CPHP7%E4%B8%8B%EF%BC%8C%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2018/11/30/Centos7%E4%B8%AD%EF%BC%8CPHP7%E4%B8%8B%EF%BC%8C%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CentOS 下，PHP有多种方式来安装拓展， 主要有 包管理式的 yum 安装、pecl 安装， 以及源码编译安装。<br>包管理式的安装卸载尤为方便，而源码编译式的安装则方便参数调优。<br>一般搭建本机开发环境推荐包管理式的安装，节约时间。而线上部署环境则推荐编译安装， 方便调优。 </p></blockquote><h2 id="环境和准备"><a href="#环境和准备" class="headerlink" title="环境和准备"></a>环境和准备</h2><hr><ul><li>环境 ： windows10</li><li>PHP版本：7.0.13</li><li>Nginx: 1.10.3</li><li>Centos: docker 创建的CentOS容器[CentOS Linux release 7.3.1611 (Core) ]</li><li>全程墙外网<h2 id="方式1：-yum-安装扩展（mongodb）"><a href="#方式1：-yum-安装扩展（mongodb）" class="headerlink" title="方式1： yum 安装扩展（mongodb）"></a>方式1： yum 安装扩展（mongodb）</h2></li></ul><hr><a id="more"></a><p>yum方式安装能自动安装扩展的.so动态库，并配置好php.ini</p><p><code>yum search mongodb|grep php  //搜索到拓展名为 php70w-pecl-mongodb</code></p><p>等待自动安装完成后，查看phpinfo</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/QQ%E6%88%AA%E5%9B%BE20170408234049.png" alt="mongodb"></p><p>到此 yum 安装扩展方法介绍完毕</p><h2 id="pecl-安装（redis）"><a href="#pecl-安装（redis）" class="headerlink" title="pecl 安装（redis）"></a>pecl 安装（redis）</h2><hr><p>pecl 安装需要准备2个文件：phpize ，php-config</p><h3 id="查找phpize的位置"><a href="#查找phpize的位置" class="headerlink" title="查找phpize的位置"></a><strong>查找phpize的位置</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc conf.d]# whereis phpize</span><br><span class="line">phpize: /usr/bin/phpize</span><br></pre></td></tr></table></figure><h3 id="查找php-config的位置"><a href="#查找php-config的位置" class="headerlink" title="查找php-config的位置"></a><strong>查找php-config的位置</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc conf.d]# whereis php-config</span><br><span class="line">php-config:[root@9e2c60482bdc conf.d]#</span><br></pre></td></tr></table></figure><p>发现没有php-config，先测试运行下phpize  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php-config:[root@9e2c60482bdc conf.d]# phpize</span><br><span class="line">Can t find PHP headers in /usr/include/php</span><br><span class="line">The php-devel package is required for use of this command.</span><br></pre></td></tr></table></figure><p>直接报错，接下来安装php-devel解决上面报错<code>yum install php70w-devel</code><br>​<br>再次运行phpize,没有报找不到的错误，出现了下面的报错：<br>​     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc bin]# phpize</span><br><span class="line">Cannot find config.m4. </span><br><span class="line">Make sure that you run /usr/bin/phpize in the top level source directory of the module</span><br></pre></td></tr></table></figure><p>先不管他，进行下一步的操作</p><h3 id="更新-pear（非必须）"><a href="#更新-pear（非必须）" class="headerlink" title="更新 pear（非必须）"></a><strong>更新 pear（非必须）</strong></h3><p>我们需要先从pear官网下载 go-pear 工具,这个工具将帮我们同时安装 pecl包管理器(管理php的C拓展) pear包管理器(管理php类库)；<br>​<br><code>wget http://pear.php.net/go-pear.phar</code><br>​<br>下载完成后安装工具，运行下面命令：<code>php go-pear.phar</code>，<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/gopear.png" alt="go-pear"></p><p>然后默认回车即可，暂时没搞懂这些参数的意思，估计是配置路经相关吧，先回车再说；</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/gopear.png" alt="go-pear"></p><h3 id="安装扩展（1）"><a href="#安装扩展（1）" class="headerlink" title="安装扩展（1）"></a><strong>安装扩展（1）</strong></h3><p>搜索扩展包：<code>pecl search redis</code></p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl search redis</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Warning: Invalid argument supplied for foreach() in PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line">XML Extension not found</span><br></pre></td></tr></table></figure><p>​<br>刷刷的报错了，查询错误后贴出解决方法：</p><p><a href="http://serverfault.com/questions/589877/pecl-command-produces-long-list-of-errors" target="_blank" rel="noopener">解决方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/pecl  //文件最后一行去掉 -n 参数</span><br></pre></td></tr></table></figure><p>再次搜索，  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl search redis</span><br><span class="line">Retrieving data...0%</span><br><span class="line">Matched packages, channel pecl.php.net:</span><br><span class="line">=======================================</span><br><span class="line">Package Stable/(Latest) Local</span><br><span class="line">redis   3.1.2 (stable)        PHP extension for interfacing with Redis</span><br></pre></td></tr></table></figure><p>安装扩展包<code>pecl install mongodb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl install redis</span><br><span class="line">downloading redis-3.1.2.tgz ...</span><br><span class="line">Starting to download redis-3.1.2.tgz (199,041 bytes)</span><br><span class="line">.................done: 199,041 bytes</span><br><span class="line">20 source files, building</span><br><span class="line">running: phpize</span><br><span class="line">Configuring for:</span><br><span class="line">PHP Api Version:         20151012</span><br><span class="line">Zend Module Api No:      20151012</span><br><span class="line">Zend Extension Api No:   320151012</span><br><span class="line">building in /tmp/pear/install/pear-build-rootLPns3m/redis-3.1.2</span><br><span class="line">running: /tmp/pear/install/redis/configure --with-php-config=/usr/bin/php-config</span><br><span class="line">checking for grep that handles long lines and -e... /usr/bin/grep</span><br><span class="line">checking for egrep... /usr/bin/grep -E</span><br><span class="line">checking for a sed that does not truncate output... /usr/bin/sed</span><br><span class="line">checking for cc... no</span><br><span class="line">checking for gcc... no</span><br><span class="line">configure: error: in /tmp/pear/install/pear-build-rootLPns3m/redis-3.1.2:</span><br><span class="line">configure: error: no acceptable C compiler found in $PATH</span><br><span class="line">See &apos;config.log&apos; for more details</span><br><span class="line">ERROR: &apos;/tmp/pear/install/redis/configure --with-php-config=/usr/bin/php-config&apos; failed</span><br></pre></td></tr></table></figure><p>刷刷的报错了，查询错误后贴出解决方法:<code>yun install gcc gcc+</code></p><h3 id="安装扩展（2）"><a href="#安装扩展（2）" class="headerlink" title="安装扩展（2）"></a><strong>安装扩展（2）</strong></h3><p>执行：<code>pecl install monodb</code> </p><p>等待自动安装完成后，显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Build process completed successfully</span><br><span class="line">Installing &apos;/usr/lib64/php/modules/redis.so&apos;</span><br><span class="line">install ok: channel://pecl.php.net/redis-3.1.2</span><br><span class="line">configuration option &quot;php_ini&quot; is not set to php.ini location</span><br><span class="line">You should add &quot;extension=redis.so&quot; to php.ini</span><br></pre></td></tr></table></figure><p>​<br>然后在php配置文件中稍作修改，将extension=redis.so添加到php.ini中,重启PHP,查看phpinfo</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/redis.png" alt="redis"></p><p>到此 pecl 安装扩展方法介绍完毕</p><h2 id="源码编译安装（Seaslog）"><a href="#源码编译安装（Seaslog）" class="headerlink" title="源码编译安装（Seaslog）"></a>源码编译安装（Seaslog）</h2><hr><p><a href="https://github.com/Neeke/SeasLog/blob/master/README_zh.md" target="_blank" rel="noopener">Seaslog文档</a></p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a><strong>安装git</strong></h3><p>先安装<a href="https://blog.bytesclub.com/2017/02/06/%E5%B8%B8%E7%94%A8%E7%9A%84git/" target="_blank" rel="noopener">git</a>，克隆Seaslog源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# git clone https://github.com/Neeke/SeasLog.git</span><br><span class="line">Cloning into &apos;SeasLog&apos;...</span><br><span class="line">remote: Counting objects: 1094, done.</span><br><span class="line">remote: Total 1094 (delta 0), reused 0 (delta 0), pack-reused 1094</span><br><span class="line">Receiving objects: 100% (1094/1094), 1.04 MiB | 24.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (628/628), done.</span><br></pre></td></tr></table></figure><h3 id="安装Seaslog"><a href="#安装Seaslog" class="headerlink" title="安装Seaslog"></a><strong>安装Seaslog</strong></h3><p>进入Seaslog目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /path/to/phpize  //更换自己对应的目录</span><br><span class="line">$ ./configure --with-php-config=/path/to/php-config</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>完成之后，修改php配置文件，将extension = seaslog.so添加到php.ini中,重启PHP,查看phpinfo<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/seaslog.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此Linux中,给PHP安装扩展的3种方式记录完毕,特此总结</p><ol><li><a href="https://my.oschina.net/u/2400083/blog/518195" target="_blank" rel="noopener">参考1</a></li><li><a href="https://segmentfault.com/a/1190000008993194" target="_blank" rel="noopener">参考2</a></li><li><a href="https://segmentfault.com/a/1190000008993194" target="_blank" rel="noopener">peal官网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git生成多个ssh key</title>
      <link href="/2018/11/30/Git%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2018/11/30/Git%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<p>当使用了多个不同的git版本控制系统，分别有不同账号时，如一个在github上面有项目，一个在coding或者开源中国上面的有项目时，如果2者的邮箱不同时，就会涉及一个问题，生成的ssh key 会相互覆盖，必然有一个无法使用；</p><p>下面记录下解决方法：<br><a id="more"></a></p><h2 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh-key"></a>生成ssh-key</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建github的ssh key</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/user/username/.ssh/github_rsa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">example：</span><br><span class="line">//我的秘钥保存路径C:\Users\MMA\.ssh\test,邮箱使用your_email@example.com</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/Users/MMA/.ssh/test/github_rsa </span><br><span class="line">//运行之后弹出</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/User/MMA/.ssh/test/test/github_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line"></span><br><span class="line">回车默认即可，出现下面提示，则创建成功</span><br><span class="line"></span><br><span class="line">Your identification has been saved in /c/Users/MMA/.ssh/test/github_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/MMA/.ssh/test/github_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:AjEAqCT5VeTZsdHpklyMIVQQWbBVtAufE/P/GzkEw9I your_email@example.com</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|oo..o+OBBBo.     |</span><br><span class="line">|+.  .+.*.+=.o    |</span><br><span class="line">|+. .. +.+++. E   |</span><br><span class="line">|. .  .  +o.*. o  |</span><br><span class="line">|      . S.= .  . |</span><br><span class="line">|       .   . .. .|</span><br><span class="line">|              .+ |</span><br><span class="line">|               .o|</span><br><span class="line">|               .o|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>查看本地目录，GitHub ssh key生成成功<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/github.png" alt="github"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//创建coding的ssh key</span><br><span class="line">ssh-keygen -t rsa -C &quot;my_email@example.com&quot; -f /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line"></span><br><span class="line">和创建github的相似</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;my_email@example.com&quot; -f /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/MMA/.ssh/test/coding_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/MMA/.ssh/test/coding_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:aqcMT/i9ZgXB6aCHus1zdf5JQlrLBYfUnnIBNJ37WIQ my_email@example.com</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|       . o=+ o   |</span><br><span class="line">|      . +. oE .  |</span><br><span class="line">|     o o .o..=   |</span><br><span class="line">|    o . o .o= .  |</span><br><span class="line">|   . .  S.oo.+   |</span><br><span class="line">|  .  . ..=oo. .  |</span><br><span class="line">|   +o +.o++ .    |</span><br><span class="line">|  . +B.+o .o .   |</span><br><span class="line">|     o=oo. .o    |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/all.png" alt="github+coding"></p><h2 id="添加私钥到SSH-agent中"><a href="#添加私钥到SSH-agent中" class="headerlink" title="添加私钥到SSH agent中"></a>添加私钥到SSH agent中</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">ssh-add/c/Users/MMA/.ssh/test/github_rsa</span><br></pre></td></tr></table></figure><p>如果执行ssh-add时提示<code>&quot;Could not open a connection to your authentication agent&quot;</code>，可以现执行命令：<code>ssh-agent bash</code></p><p>重新添加即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add /c/Users/MMA/.ssh/test/github_rsa</span><br><span class="line">Identity added: /c/Users/MMA/.ssh/test/github_rsa (/c/Users/MMA/.ssh/test/github_rsa)</span><br><span class="line"></span><br><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">Identity added: /c/Users/MMA/.ssh/test/coding_rsa (/c/Users/MMA/.ssh/test/coding_rsa)</span><br><span class="line"></span><br><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add -l</span><br><span class="line">2048 SHA256:aqcMT/i9ZgXB6aCHus1zdf5JQlrLBYfUnnIBNJ37WIQ /c/Users/MMA/.ssh/test/coding_rsa (RSA)</span><br><span class="line">2048 SHA256:AjEAqCT5VeTZsdHpklyMIVQQWbBVtAufE/P/GzkEw9I /c/Users/MMA/.ssh/test/github_rsa (RSA)</span><br></pre></td></tr></table></figure><blockquote><p> // 可以通过 ssh-add -l 来确私钥列表</p><p> ssh-add -l</p><p> // 可以通过 ssh-add -D 来清空私钥列表</p><p> ssh-add -D</p></blockquote><h2 id="修改config文件"><a href="#修改config文件" class="headerlink" title="修改config文件"></a>修改config文件</h2><hr><p>在/c/Users/MMA/.ssh/test 目录下新建一个config文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># coding</span><br><span class="line">Host git.coding.net</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile /c/Users/MMA/.ssh/test/github_rsa</span><br></pre></td></tr></table></figure><h2 id="添加公钥到git平台"><a href="#添加公钥到git平台" class="headerlink" title="添加公钥到git平台"></a>添加公钥到git平台</h2><hr><p>[coding教程]<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="noopener">https://coding.net/help/doc/git/ssh-key.html</a>)</p><p>[github教程]<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account" target="_blank" rel="noopener">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2018/11/30/Git/"/>
      <url>/2018/11/30/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h3><p><strong>集中式</strong>版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。<br><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E9%9B%86%E4%B8%AD%E5%BC%8F.jpeg" alt="集中式"></p><p>集中式版本控制系统最大的毛病就是必须联网才能工作</p><p><strong>分布式</strong>版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E5%B8%83%E5%BC%8F.jpeg" alt="分布式"></p><h3 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br><span class="line">$ git config --global color.ui true //Git会适当地显示不同的颜色</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">&amp; git config --global alias.last &apos;log -1&apos;</span><br></pre></td></tr></table></figure><blockquote><p>Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。<br><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></blockquote><h3 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h3><h4 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h4><p>运行<code>git status</code>命令看看仓库状态<br><code>git diff</code>查看文件修改记录</p><h4 id="文件跟踪"><a href="#文件跟踪" class="headerlink" title="文件跟踪"></a>文件跟踪</h4><p><code>git log</code>命令显示从最近到最远的提交日志</p><blockquote><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数<br>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令</p></blockquote><h4 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h4><p>假如提交历史记录为下面所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 latest commit</span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 second commit</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 first commit</span><br></pre></td></tr></table></figure></p><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628164...882e1e0</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。<br>Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code></p><p>我们要把当前版本“latest commit”回退到上一个版本“second commit”，就可以使用<code>git reset</code>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at ea34578 second commit</span><br></pre></td></tr></table></figure></p><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p>工作区（Working Directory）：就是你在电脑里能看到的目录<br>版本库（Repository）：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><blockquote><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>初始化一个Git仓库，使用<code>git init</code>命令。<br>添加文件到Git仓库，分两步：</p><ul><li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>第二步，使用命令<code>git commit</code>，完成。</li></ul></blockquote><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code><br>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。<br>已经提交了不合适的修改到版本库时，想要撤销本次提交，使用命令<code>git reset --hard commit_id</code></p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>rm删除文件后，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了<br>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>，现在，文件就从版本库中被删除了。<br>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本，使用<code>git checkout -- test.txt</code>，<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h4 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h4><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；<br>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；<br>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><h4 id="创建合并删除分支"><a href="#创建合并删除分支" class="headerlink" title="创建合并删除分支"></a>创建合并删除分支</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF.png" alt="分支"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF2.png" alt="分支2"></p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF3.png" alt="分支3"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF4.png" alt="分支4"></p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF5.png" alt="分支5"></p><p>开始实战：<br>我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><blockquote><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号</p></blockquote><p>然后，我们就可以在<code>dev</code>分支上正常提交;<br>如果<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：<br><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF6.png" alt="分支6"></p><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure><blockquote><p>丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p></blockquote><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>总结：</p><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Git/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5.png" alt="分支策略"></p><h4 id="Bug分支-暂存文件"><a href="#Bug分支-暂存文件" class="headerlink" title="Bug分支-暂存文件"></a>Bug分支-暂存文件</h4><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class="line">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。<br>等到bug修复完毕，继续在dev分支开发时，工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</span><br></pre></td></tr></table></figure></p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><p>多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</p></li></ol><p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。 </p><p>小结：</p><ul><li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><blockquote><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 </p></blockquote><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p><p>可以用命令<code>git tag</code>查看所有标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>给之前的提交打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag_name commit_id</span><br></pre></td></tr></table></figure></p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &apos;v0.1&apos; (was e078af9)</span><br></pre></td></tr></table></figure></p><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure></p><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 554 bytes, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.2 -&gt; v0.2</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was 6224937)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p></li><li><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p></li><li><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p></li><li><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON和JSONP</title>
      <link href="/2018/11/30/JSON%E5%92%8CJSONP/"/>
      <url>/2018/11/30/JSON%E5%92%8CJSONP/</url>
      
        <content type="html"><![CDATA[<p><a href="http://note.youdao.com/" target="_blank" rel="noopener">有一篇文章</a>介绍了跨域问题的几种解决方法,其中有一种是使用jsonP方式解决,那么今天来详细说说Json和JsonP</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到AJAX就会不可避免的面临两个问题,<strong>第一个是AJAX以何种格式来交换数据?第二个是跨域的需求如何解决?</strong>,目前为止最被推崇或者说首选的方案还是用<strong>JSON来传数据</strong>,靠<strong>JSONP来跨域</strong>.而这就是本文将要讲述的内容</p><p>JSON和JSONP虽然只有一个字母的差别,但其实他们根本不是一回事儿:</p><p>JSON是一种数据交换格式</p><p>JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议.</p><p>我们拿最近比较火的谍战片来打个比方,JSON是地下党们用来书写和交换情报的“暗号”,而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式.看到没?一个是描述信息的格式,一个是信息传递双方约定的方法.</p><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p>JSON是一种基于文本的数据交换方式,或者叫做数据描述格式,你是否该选用他首先肯定要关注它所拥有的优点.</p><h3 id="JSON的优点"><a href="#JSON的优点" class="headerlink" title="JSON的优点:"></a>JSON的优点:</h3><ol><li><p>基于纯文本,跨平台传递极其简单;</p></li><li><p>Javascript原生支持,后台语言几乎全部支持;</p></li><li><p>轻量级数据格式,占用字符数量极少,特别适合互联网传递;</p></li><li><p>可读性较强,虽然比不上XML那么一目了然,但在合理的依次缩进之后还是很容易识别的;</p></li><li><p>容易编写和解析,当然前提是你要知道数据结构;</p></li></ol><h3 id="JSON的格式或者叫规则"><a href="#JSON的格式或者叫规则" class="headerlink" title="JSON的格式或者叫规则"></a>JSON的格式或者叫规则</h3><p>JSON能够以非常简单的方式来描述数据结构,XML能做的它都能做,因此在跨平台方面两者完全不分伯仲.</p><ol><li><p>JSON只有两种数据类型描述符,大括号{}和方括号[],其余英文冒号:是映射符,英文逗号,是分隔符,英文双引号””是定义符.</p></li><li><p>大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述）,方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）.</p></li><li><p>上述两种集合中若有多个子项,则通过英文逗号,进行分隔.</p></li><li><p>键值对以英文冒号:进行分隔,并且建议键名都加上英文双引号””,以便于不同语言的解析.</p></li><li><p>JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个,字符串必须用双引号引起来,其余的都不用,日期类型比较特殊,这里就不展开讲述了,只是建议如果客户端没有按日期排序功能需求的话,那么把日期时间直接作为字符串传递就好,可以省去很多麻烦.</p></li></ol><h3 id="JSON实例"><a href="#JSON实例" class="headerlink" title="JSON实例:"></a>JSON实例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 描述一个人</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">&quot;Name&quot;: &quot;Bob&quot;,</span><br><span class="line">&quot;Age&quot;: 32,</span><br><span class="line">&quot;Company&quot;: &quot;IBM&quot;,</span><br><span class="line">&quot;Engineer&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取这个人的信息</span><br><span class="line"></span><br><span class="line">var personAge = person.Age;</span><br><span class="line"></span><br><span class="line">// 描述几个人</span><br><span class="line"></span><br><span class="line">var members = [</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;Bob&quot;,</span><br><span class="line">&quot;Age&quot;: 32,</span><br><span class="line">&quot;Company&quot;: &quot;IBM&quot;,</span><br><span class="line">&quot;Engineer&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;John&quot;,</span><br><span class="line">&quot;Age&quot;: 20,</span><br><span class="line">&quot;Company&quot;: &quot;Oracle&quot;,</span><br><span class="line">&quot;Engineer&quot;: false</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;Henry&quot;,</span><br><span class="line">&quot;Age&quot;: 45,</span><br><span class="line">&quot;Company&quot;: &quot;Microsoft&quot;,</span><br><span class="line">&quot;Engineer&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 读取其中John的公司名称</span><br><span class="line"></span><br><span class="line">var johnsCompany = members[1].Company;</span><br><span class="line"></span><br><span class="line">// 描述一次会议</span><br><span class="line"></span><br><span class="line">var conference = &#123;</span><br><span class="line">&quot;Conference&quot;: &quot;Future Marketing&quot;,</span><br><span class="line">&quot;Date&quot;: &quot;2012-6-1&quot;,</span><br><span class="line">&quot;Address&quot;: &quot;Beijing&quot;,</span><br><span class="line">&quot;Members&quot;:</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;Bob&quot;,</span><br><span class="line">&quot;Age&quot;: 32,</span><br><span class="line">&quot;Company&quot;: &quot;IBM&quot;,</span><br><span class="line">&quot;Engineer&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;John&quot;,</span><br><span class="line">&quot;Age&quot;: 20,</span><br><span class="line">&quot;Company&quot;: &quot;Oracle&quot;,</span><br><span class="line">&quot;Engineer&quot;: false</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;Henry&quot;,</span><br><span class="line">&quot;Age&quot;: 45,</span><br><span class="line">&quot;Company&quot;: &quot;Microsoft&quot;,</span><br><span class="line">&quot;Engineer&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取参会者Henry是否工程师</span><br><span class="line"></span><br><span class="line">var henryIsAnEngineer = conference.Members[2].Engineer;</span><br></pre></td></tr></table></figure><h2 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h2><h3 id="JSONP的产生"><a href="#JSONP的产生" class="headerlink" title="JSONP的产生"></a>JSONP的产生</h3><ol><li><p>一个众所周知的问题,Ajax直接请求普通文件存在跨域无权限访问的问题,甭管你是静态页面、动态网页、web服务、WCF,只要是跨域请求,一律不准;</p></li><li><p>不过我们又发现,Web页面上调用js文件时则不受是否跨域的影响（不仅如此,我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力,比如<script>、<img>、<iframe>）;</p></li><li><p>于是可以判断,当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能,那就是在远程服务器上设法把数据装进js格式的文件里,供客户端调用和进一步处理;</p></li><li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据,更妙的是JSON还被js原生支持,所以在客户端几乎可以随心所欲的处理这种格式的数据;</p></li><li><p>这样子解决方案就呼之欲出了,web客户端通过与调用脚本一模一样的方式,来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀）,显而易见,服务器之所以要动态生成JSON文件,目的就在于把客户端需要的数据装入进去.</p></li><li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需的数据,剩下的就是按照自己需求进行处理和展现了,这种获取远程数据的方式看起来非常像AJAX,但其实并不一样.</p></li><li><p>为了便于客户端使用数据,逐渐形成了一种非正式传输协议,人们把它称作JSONP,该协议的一个要点就是允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据,这样客户端就可以随意定制自己的函数来自动处理返回数据了.</p></li></ol><h3 id="JSONP的客户端具体实现"><a href="#JSONP的客户端具体实现" class="headerlink" title="JSONP的客户端具体实现"></a>JSONP的客户端具体实现</h3><ol><li>我们知道,哪怕跨域js文件中的代码（当然指符合web脚本安全策略的）,web页面也是可以无条件执行的.</li></ol><p>远程服务器remoteserver.com根目录下有个remote.js文件代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;我是远程文件&apos;);</span><br></pre></td></tr></table></figure><p>本地服务器localserver.com下有个jsonp.html页面代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>结果是弹出一个alert框,则跨域调用成功！</p><ol start="2"><li>现在我们在jsonp.html页面定义一个函数,然后在远程remote.js中传入数据进行调用.</li></ol><p>jsonp.html页面代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var localHandler = function(data)&#123;</span><br><span class="line">            alert(&apos;我是本地函数,可以被跨域的remote.js文件调用,远程js带来的数据是:&apos; + data.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>remote.js文件代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;);</span><br></pre></td></tr></table></figure><p>运行之后查看结果,页面成功弹出提示窗口,显示本地函数被跨域的远程js调用成功,并且还接收到了远程js带来的数据.</p><p>很欣喜,跨域远程获取数据的目的基本实现了,但是又一个问题出现了,我怎么让远程js知道它应该调用的本地函数叫什么名字呢?毕竟是jsonp的服务者都要面对很多服务对象,而这些服务对象各自的本地函数都不相同啊?我们接着往下看</p><ol start="3"><li>聪明的开发者很容易想到,只要服务端提供的js脚本是动态生成的就行了呗,这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码,请你返回给我”,于是服务器就可以按照客户端的需求来生成js脚本并响应了.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        // 得到航班信息查询结果后的回调函数</span><br><span class="line">        var flightHandler = function(data)&#123;</span><br><span class="line">            alert(&apos;你查询的航班结果是:票价 &apos; + data.price + &apos; 元,&apos; + &apos;余票 &apos; + data.tickets + &apos; 张.&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">        // 提供jsonp服务的url地址（不管是什么类型的地址,最终生成的返回值都是一段javascript代码）</span><br><span class="line">        var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;</span><br><span class="line">        // 创建script标签,设置其属性</span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">        // 把script标签加入head,此时调用开始</span><br><span class="line">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这次的代码变化比较大,不再直接把远程js文件写死,而是编码实现动态查询,而这也正是jsonp客户端实现的核心部分,本例中的重点也就在于如何完成jsonp调用的全过程.</p><p>我们看到调用的url中传递了一个code参数,告诉服务器我要查的是CA1998次航班的信息,而callback参数则告诉服务器,我的本地回调函数叫做flightHandler,所以请把查询结果传入这个函数中进行调用.</p><p>OK,服务器很聪明,这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了,与你选用的语言无关,说到底就是拼接字符串）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flightHandler(&#123;</span><br><span class="line">&quot;code&quot;: &quot;CA1998&quot;,</span><br><span class="line">&quot;price&quot;: 1780,</span><br><span class="line">&quot;tickets&quot;: 5</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们看到,传递给flightHandler函数的是一个json,它描述了航班的基本信息.运行一下页面,成功弹出提示窗口,jsonp的执行全过程顺利完成！</p><ol start="4"><li>到这里为止的话,相信你已经能够理解jsonp的客户端实现原理了吧?剩下的就是如何把代码封装一下,以便于与用户界面交互,从而实现多次和重复调用.</li></ol><p>想知道jQuery如何实现jsonp调用?请看下文（我们依然沿用上面那个航班信息查询的例子,假定返回jsonp结果不变）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Untitled Page&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        jQuery(document).ready(function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &quot;get&quot;,</span><br><span class="line">                async: false,</span><br><span class="line">                url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,</span><br><span class="line">                dataType: &quot;jsonp&quot;,</span><br><span class="line">                jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的,用以获得jsonp回调函数名的参数名(一般默认为:callback)</span><br><span class="line">                jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称,默认为jQuery自动生成的随机函数名,也可以写&quot;?&quot;,jQuery会自动为你处理数据</span><br><span class="line">                success: function(json)&#123;</span><br><span class="line">                    alert(&apos;您查询到航班信息:票价: &apos; + json.price + &apos; 元,余票: &apos; + json.tickets + &apos; 张.&apos;);</span><br><span class="line">                &#125;,</span><br><span class="line">                error: function()&#123;</span><br><span class="line">                    alert(&apos;fail&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>是不是有点奇怪?</p><p>为什么我这次没有写flightHandler这个函数呢?</p><p>而且竟然也运行成功了！哈哈,这就是jQuery的功劳了,jquery在处理jsonp类型的ajax时（还是忍不住吐槽,虽然jquery也把jsonp归入了ajax,但其实它们真的不是一回事儿）,自动帮你生成回调函数并把数据取出来供success属性方法来调用,是不是很爽呀?</p><h2 id="作者补充"><a href="#作者补充" class="headerlink" title="作者补充"></a>作者补充</h2><ol><li><p>ajax和jsonp这两种技术在调用方式上“看起来”很像,目的也一样,都是请求一个url,然后把服务器返回的数据进行处理,因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装;</p></li><li><p>但ajax和jsonp其实本质上是不同的东西.ajax的核心是通过XmlHttpRequest获取非本页内容,而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本.</p></li><li><p>所以说,其实ajax与jsonp的区别不在于是否跨域,ajax通过服务端代理一样可以实现跨域,jsonp本身也不排斥同域的数据的获取.</p></li><li><p>还有就是,jsonp是一种方式或者说非强制性协议,如同ajax一样,它也不一定非要用json格式来传递数据,如果你愿意,字符串都行,只不过这样不利于用jsonp提供公开服务.</p></li></ol><p>总而言之,jsonp不是ajax的一个特例,哪怕jquery等巨头把jsonp封装进了ajax,也不能改变着一点</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html">本文属于原创</a>,我只是个搬运工,在此记录下,已备不时之需;</p></script></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Cors </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel开发前期准备</title>
      <link href="/2018/11/30/Laravel%E5%BC%80%E5%8F%91-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2018/11/30/Laravel%E5%BC%80%E5%8F%91-%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>环境 ： windows10</p><p>本地开发环境 ：<a href="https://github.com/salamander-mh/SalamanderWnmp" target="_blank" rel="noopener">SalamanderWnmp</a></p><p>Phpstrom版本：Phpstrom 2017.1 </p><p>Laravel版本：Laravel5.4</p><a id="more"></a><h1 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h1><h2 id="Laravel-Plugin"><a href="#Laravel-Plugin" class="headerlink" title="Laravel Plugin"></a>Laravel Plugin</h2><hr><p>ctrl+alt+s打开PHPStrom设置页面，按如下操作</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/laravel/laravel_plugin.png" alt="image"></p><p>安装完成后，启用插件，如下图所示</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/laravel/laravel_enable_plugins.png" alt="image"></p><p>然后再去写代码的时候就会提供controllers,views, routes, configuration, translations等的代码提示功能。</p><h2 id="Laravel-IDE-Helper"><a href="#Laravel-IDE-Helper" class="headerlink" title="Laravel IDE Helper"></a>Laravel IDE Helper</h2><hr><p>有时候你会发现Route::之类的没有代码提示或者自动补全，这时候我们需要安装 Laravel IDE Helper</p><p>项目地址<a href="https://github.com/barryvdh/laravel-ide-helper" target="_blank" rel="noopener">：GitHub</a></p><p>使用composer命令安装:<figure class="highlight plain"><figcaption><span>require barryvdh/laravel-ide-helper```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装之后你需要把Laravel IDE Helper以服务的形式注册到应用中。</span><br><span class="line"></span><br><span class="line">修改**app/config/app.php**,添加```Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class```, 到**providers**元素下。</span><br><span class="line"></span><br><span class="line">执行下面的命令</span><br></pre></td></tr></table></figure></p><pre><code>php artisan clear-compiledphp artisan ide-helper:generatephp artisan optimize</code></pre><p><code>`</code></p><p>[参考资料]：<br><a href="https://confluence.jetbrains.com/display/PhpStorm/Laravel+Development+using+PhpStorm" target="_blank" rel="noopener">https://confluence.jetbrains.com/display/PhpStorm/Laravel+Development+using+PhpStorm</a></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac环境ELK搭建</title>
      <link href="/2018/11/30/Mac%E7%8E%AF%E5%A2%83ELK%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/11/30/Mac%E7%8E%AF%E5%A2%83ELK%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><p>略。。。</p><p><del>这里我使用<code>brew install java</code>命令安装</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  java -version</span><br><span class="line">java version &quot;11&quot; 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure><p>不要使用上述方式安装，有坑</p><p>下载这个文件安装java:<a href="https://edelivery.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-macosx-x64.dmg" target="_blank" rel="noopener">https://edelivery.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-macosx-x64.dmg</a></p><h2 id="Elasticsearch安装配置"><a href="#Elasticsearch安装配置" class="headerlink" title="Elasticsearch安装配置"></a>Elasticsearch安装配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网下载对应平台的安装包</p><p><img src="/Users/zhimma/Pictures/ELK/downloadE.png" alt="下载Elasticsearch"></p><p>放到合适的位置，我放置后解压的目录是<code>/Users/zhimma/Soft/elasticsearch-6.4.1</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置-Elasticsearch"><a href="#配置-Elasticsearch" class="headerlink" title="配置 Elasticsearch"></a>配置 Elasticsearch</h4><p>下面是我的配置文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">☁  config  pwd</span><br><span class="line">/Users/zhimma/Soft/elasticsearch-6.4.1/config</span><br><span class="line">☁  config  grep &apos;^[a-z]&apos; elasticsearch.yml</span><br><span class="line">cluster.name: elk-stack</span><br><span class="line">path.data: /Users/zhimma/Data/elk_stack/data</span><br><span class="line">path.logs: /Users/zhimma/Data/elk_stack/logs</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure><h4 id="配置-Elasticsearch-内存占用"><a href="#配置-Elasticsearch-内存占用" class="headerlink" title="配置 Elasticsearch 内存占用"></a>配置 Elasticsearch 内存占用</h4><p>配置 jvm 最大堆和最小堆，一般为服务器物理内存的一半，最大不超过 32g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">☁  config  pwd</span><br><span class="line">/Users/zhimma/Soft/elasticsearch-6.4.1/config</span><br><span class="line">☁  config  vi jvm.options </span><br><span class="line"></span><br><span class="line">-Xms8g</span><br><span class="line">-Xmx8g</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入<code>bin</code>目录启动<code>Elasticsearch</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  pwd</span><br><span class="line">/Users/zhimma/Soft/elasticsearch-6.4.1/bin</span><br><span class="line">☁  bin  ./elasticsearch</span><br></pre></td></tr></table></figure><h2 id="kibana安装配置"><a href="#kibana安装配置" class="headerlink" title="kibana安装配置"></a>kibana安装配置</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>官网下载对应平台的安装包</p><p><img src="/Users/zhimma/Pictures/ELK/downloadK.png" alt="下载Kibana"></p><p>放到合适的位置，我放置后解压的目录是<code>/Users/zhimma/Soft/kibana-6.4.1-darwin-x86_64</code></p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>凭感觉配置了一些，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☁  config  grep &apos;^[a-z]&apos; kibana.yml</span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://0.0.0.0:9200&quot;</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>进入<code>bin</code>目录启动<code>Kibana</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  pwd</span><br><span class="line">/Users/zhimma/Soft/kibana-6.4.1-darwin-x86_64/bin</span><br><span class="line">☁  bin  ./kibana</span><br></pre></td></tr></table></figure><h2 id="Logstash安装配置"><a href="#Logstash安装配置" class="headerlink" title="Logstash安装配置"></a>Logstash安装配置</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>官网下载对应平台的安装包</p><p><img src="/Users/zhimma/Pictures/ELK/downloadL.png" alt="下载Logstash"></p><p>放到合适的位置，我放置后解压的目录是<code>/Users/zhimma/Soft/logstash-6.4.1</code></p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><h4 id="配置-Logstash"><a href="#配置-Logstash" class="headerlink" title="配置 Logstash"></a>配置 Logstash</h4><p>不是很了解，暂时使用默认配置</p><h4 id="配置-Logstash-内存占用"><a href="#配置-Logstash-内存占用" class="headerlink" title="配置 Logstash 内存占用"></a>配置 Logstash 内存占用</h4><p>配置 jvm 最大堆和最小堆，一般为服务器物理内存的一半，最大不超过 32g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">☁  config  pwd</span><br><span class="line">/Users/zhimma/Soft/logstash-6.4.1/config</span><br><span class="line">☁  config  vi jvm.options </span><br><span class="line"></span><br><span class="line">-Xms8g</span><br><span class="line">-Xmx8g</span><br></pre></td></tr></table></figure><h3 id="添加项目或自定义配置文件"><a href="#添加项目或自定义配置文件" class="headerlink" title="添加项目或自定义配置文件"></a>添加项目或自定义配置文件</h3><p><code>Logstash</code>收集日志时候，可以对日志进行一定的操作和过滤，这里需要自定义不同的配置文件来实现，针对我们目前的项目，我简单的创建了下面的配置文件</p><p>在<code>/Users/zhimma/Soft/logstash-6.4.1/config</code>目录下创建<code>conf.d</code>文件夹，这个文件夹下存放我们所有的自定义配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [ &quot;/data/www/XX_project/trunk/Common/Runtime/Apps/Api/*.log&quot; ]</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    ignore_older =&gt; 0</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">    type =&gt; &quot;Api&quot;</span><br><span class="line">    codec =&gt; multiline &#123;</span><br><span class="line">      pattern =&gt; &quot;^\[&quot;</span><br><span class="line">      negate =&gt; true</span><br><span class="line">      what =&gt; &quot;previous&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [ &quot;/data/www/XX_project/trunk/Common/Runtime/Apps/SDK/*.log&quot; ]</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    ignore_older =&gt; 0</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">    type =&gt; &quot;SDK&quot;</span><br><span class="line">    codec =&gt; multiline &#123;</span><br><span class="line">      pattern =&gt; &quot;^\[&quot;</span><br><span class="line">      negate =&gt; true</span><br><span class="line">      what =&gt; &quot;previous&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123; </span><br><span class="line">  if [type] == &quot;Api&quot; &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [ &quot;127.0.0.1:9200&quot; ] </span><br><span class="line">      index =&gt; &quot;api&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  if [type] == &quot;SDK&quot; &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [ &quot;127.0.0.1:9200&quot; ] </span><br><span class="line">      index =&gt; &quot;sdk&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>进入<code>bin</code>目录启动Llogstash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  pwd</span><br><span class="line">/Users/zhimma/Soft/logstash-6.4.1/bin</span><br><span class="line">☁  bin  ./logstash -f /Users/zhimma/Soft/logstash-6.4.1/config/conf.d/default.conf</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="## 访问"></a>## 访问</h2><p>浏览器访问0.0.0.0:5601即可</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac重启php-fpm失败</title>
      <link href="/2018/11/30/Mac%E9%87%8D%E5%90%AFphp-fpm%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/11/30/Mac%E9%87%8D%E5%90%AFphp-fpm%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="Mac重启php-fpm失败"><a href="#Mac重启php-fpm失败" class="headerlink" title="Mac重启php-fpm失败"></a><a href="https://www.jianshu.com/p/c9306c69e8b4" target="_blank" rel="noopener">Mac重启php-fpm失败</a></h3><p>关闭</p><p><code>killall -HUP php-fpm</code></p><p>重启，这里报错，提示找不到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  php-fpm</span><br><span class="line">[27-May-2018 11:27:47] ERROR: failed to open configuration file &apos;/private/etc/php-fpm.conf&apos;: No such file or directory (2)</span><br><span class="line">[27-May-2018 11:27:47] ERROR: failed to load configuration file &apos;/private/etc/php-fpm.conf&apos;</span><br><span class="line">[27-May-2018 11:27:47] ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>检查了下本机的php-fpm.conf放在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/php/7.1/php-fpm.conf</span><br></pre></td></tr></table></figure><p>于是修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf</span><br></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf</span><br><span class="line">[27-May-2018 11:28:47] ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)</span><br><span class="line">[27-May-2018 11:28:47] ERROR: failed to post process the configuration</span><br><span class="line">[27-May-2018 11:28:47] ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>错误信息显示：不能正确的打开”日志“文件，原因是默认在/usr/var目录下工作，可以修改配置文件指定正确的日志文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf --prefix /usr/local/var</span><br></pre></td></tr></table></figure><p>可以成功运行了，错误文件会放在 <code>/usr/local/var/log/php-fpm.log</code></p><p>[TOC]</p><h3 id="Mac-启动、停止、重启-Nginx-重启-php-fpm"><a href="#Mac-启动、停止、重启-Nginx-重启-php-fpm" class="headerlink" title="Mac 启动、停止、重启 Nginx,重启 php-fpm"></a><a href="https://www.yuanshidai.cc/archives/93" target="_blank" rel="noopener">Mac 启动、停止、重启 Nginx,重启 php-fpm</a></h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><hr><p>启动：<code>sudo nginx</code></p><p>停止：</p><figure class="highlight ps"><figcaption><span>-ef | grep nginxsudo kill -INT [进程号]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">sudo kill -INT [进程号]</span><br></pre></td></tr></table></figure><p>重启：<code>sudo nginx -s reload</code></p><blockquote><p>重启之前一定要 执行<code>nginx -t</code>检查配置文件是否有问题</p></blockquote><h4 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h4><hr><p>关闭</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep php-fpm</span><br><span class="line">sudo killall php-fpm</span><br></pre></td></tr></table></figure><p>重启</p><p><code>/usr/local/Cellar/php71/7.1.12_23/sbin/php71-fpm start</code></p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中binlog文件</title>
      <link href="/2018/11/30/MySQL%E4%B8%ADBinlog%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/30/MySQL%E4%B8%ADBinlog%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>[DCOT]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MySQL Server 有四种类型的日志——Error Log、General Query Log、Binary Log 和 Slow Query Log。</p><p><strong>Error Log</strong>：错误日志，记录 mysqld 的一些错误</p><p><strong>General Query Log</strong>：一般查询日志，记录 mysqld 正在做的事情，比如客户端的连接和断开、来自客户端每条 Sql Statement 记录信息；如果你想准确知道客户端到底传了什么瞎 [哔哔] 玩意儿给服务端，这个日志就非常管用了，不过它非常影响性能。</p><p><strong>Binlog</strong>：Mysql sever层维护的一种二进制日志,Binlog中包含了一些事件，这些事件描述了数据库的改动，如建表、数据改动等，也包括一些潜在改动，比如 <code>DELETE FROM ran WHERE bing = luan</code>，然而一条数据都没被删掉的这种情况。除非使用 Row-based logging，否则会包含所有改动数据的 SQL Statement。</p><p><strong>Slow Query Log</strong>：慢查询日志，记录一些查询比较慢的 SQL 语句——这种日志非常常用，主要是给开发者调优用的。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Binlog的作用主要有：</p><ul><li>Replication（<em>主从数据库）</em>:在master端开启binary log后，log会记录所有数据库的改动，然后slave端获取这个Log文件内容就可以在slave端进行同样的操作。</li><li>备份（<em>数据恢复</em> ）：在某个时间点a做了一次备份，然后利用binary log记录从这个时间点a后的所有数据库的改动，然后下一次还原的时候，利用时间点a的备份文件和这个binary log文件，就可以将数据还原。</li></ul><p>我们执行<strong>SELECT</strong>等不设计数据变更的语句是<strong>不会记录Binlog</strong>的，而涉及到数据更新则会记录。要注意的是，对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录Binlog。Binlog是在事务最终commit前写入的，binlog什么时候刷新到磁盘跟参数sync_binlog相关。如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新，而如果设置为不为0的值则表示每sync_binlog次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响，一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。</p><h2 id="Binlog的用法"><a href="#Binlog的用法" class="headerlink" title="Binlog的用法"></a>Binlog的用法</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>1.开启Binlog</p><p>通过配置/etc/my.cnf配置文件的log-bin选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><p>修改后重启MySql服务；</p><p>可以使用SET SQL_LOG_BIN=0命令停止使用日志文件，然后可以通过SET SQL_LOG_BIN=1命令来启用。</p><p>2.查看Binlog文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;  </span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |      1045 |</span><br><span class="line">| mysql-bin.000002 |       201 |</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       201 |</span><br><span class="line">| mysql-bin.000008 |       201 |</span><br><span class="line">| mysql-bin.000009 |     18949 |</span><br><span class="line">| mysql-bin.000010 |       471 |</span><br><span class="line">| mysql-bin.000011 |      1072 |</span><br><span class="line">| mysql-bin.000012 |       177 |</span><br><span class="line">| mysql-bin.000013 |      1171 |</span><br><span class="line">| mysql-bin.000014 |      3548 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show master logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |      1045 |</span><br><span class="line">| mysql-bin.000002 |       201 |</span><br><span class="line">| mysql-bin.000003 |       201 |</span><br><span class="line">| mysql-bin.000004 |       201 |</span><br><span class="line">| mysql-bin.000005 |       201 |</span><br><span class="line">| mysql-bin.000006 |       201 |</span><br><span class="line">| mysql-bin.000007 |       201 |</span><br><span class="line">| mysql-bin.000008 |       201 |</span><br><span class="line">| mysql-bin.000009 |     18949 |</span><br><span class="line">| mysql-bin.000010 |       471 |</span><br><span class="line">| mysql-bin.000011 |      1072 |</span><br><span class="line">| mysql-bin.000012 |       177 |</span><br><span class="line">| mysql-bin.000013 |      1171 |</span><br><span class="line">| mysql-bin.000014 |      3548 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>3.查看Binlog记录时长,设置时长(过期自动删除)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;expire_logs_days&apos;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| expire_logs_days | 7     |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global expire_logs_days=15;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;expire_logs_days&apos;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| expire_logs_days | 15    |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>4.删除Binlog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush logs;</span><br><span class="line">Query OK, 0 rows affected (0.35 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; reset master;</span><br><span class="line">Query OK, 0 rows affected (0.35 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show master logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">查看Binlog文件目录</span><br><span class="line">[root@b04f945297ac mysql]# ls -alh</span><br><span class="line">. . .</span><br><span class="line">drwxr-x--- 1 mysql mysql 4.0K Apr  8 04:12 mysql</span><br><span class="line">-rw-r----- 1 mysql mysql 1.1K May 22 07:41 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000002</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000003</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000004</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000005</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000006</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000007</span><br><span class="line">-rw-r----- 1 mysql mysql  201 May 22 07:41 mysql-bin.000008</span><br><span class="line">-rw-r----- 1 mysql mysql  19K May 22 10:09 mysql-bin.000009</span><br><span class="line">-rw-r----- 1 mysql mysql  471 May 23 01:28 mysql-bin.000010</span><br><span class="line">-rw-r----- 1 mysql mysql 1.1K May 24 02:28 mysql-bin.000011</span><br><span class="line">-rw-r----- 1 mysql mysql  177 May 24 02:28 mysql-bin.000012</span><br><span class="line">-rw-r----- 1 mysql mysql 1.2K May 25 02:15 mysql-bin.000013</span><br><span class="line">-rw-r----- 1 mysql mysql 2.0K May 25 06:36 mysql-bin.000014</span><br><span class="line">-rw-r----- 1 mysql mysql  266 May 25 02:15 mysql-bin.index</span><br><span class="line">srwxrwxrwx 1 mysql mysql    0 May 25 02:15 mysql.sock</span><br><span class="line">-rw------- 1 mysql mysql    3 May 25 02:15 mysql.sock.lock</span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">删除之后的目录</span><br><span class="line">[root@b04f945297ac mysql]# ls -alh</span><br><span class="line">total 313M</span><br><span class="line">. . .</span><br><span class="line">drwxr-x--- 1 mysql mysql 4.0K Apr  8 12:12 mysql</span><br><span class="line">-rw-r----- 1 mysql mysql  154 May 25 15:03 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql   19 May 25 15:03 mysql-bin.index</span><br><span class="line">srwxrwxrwx 1 mysql mysql    0 May 25 10:15 mysql.sock</span><br><span class="line">-rw------- 1 mysql mysql    3 May 25 10:15 mysql.sock.lock</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><p>5.自动清理Binlog日志</p><p>如果堆积的binlog非常多，不要轻易设置改参数，可以使用purge命令 部分老化binlog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; purge master logs before &apos;2018-05-25 16:25:00&apos;;//删除指定日期前的日志索引中binlog日志文件</span><br><span class="line">mysql&gt; purge master logs to &apos;binlog.000001&apos;;//删除指定日志文件</span><br></pre></td></tr></table></figure><h3 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h3><p>binary log可以通过mysqlbinlog命令来将log的信息打印出来，binlog模式总共可分为以下三种：</p><p><strong>statement</strong> ,<strong>row</strong>,<strong>mixed</strong></p><p><strong>Statement</strong>:基于SQL语句的复制（statement-based replication, SBR）</p><p>每一条会修改数据的sql都会记录在binlog中。</p><p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。</p><p>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行的时候相同的结果。另外mysql的复制，像一些特定函数的功能，slave可与master上要保持一致会有很多相关问题。</p><p><strong>Row</strong>:基于行的复制（row-based replication, RBR）</p><p>5.1.5版本的MySQL才开始支持row level的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><p>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.</p><p>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容</p><blockquote><p>新版本的MySQL中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。</p></blockquote><p><strong>Mixed</strong>:混合模式复制（mixed-based replication, MBR）</p><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。<br>在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h3><ul><li>statement：基于 SQL 语句的模式，binlog 数据量小，但是某些语句和函数在复制过程可能导致数据不一致甚至出错；</li><li>mixed：混合模式，根据语句来选用是 statement 还是 row 模式；</li><li>row：基于行的模式，记录的是行的完整变化。安全，但 binlog 会比其他两种模式大很多；</li></ul><p>查看当前Binlog日志格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;binlog_format&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>设置Binlog日志格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">修改my.cnf</span><br><span class="line">log-bin=mysql-bin  </span><br><span class="line">#binlog_format=STATEMENT  </span><br><span class="line">#binlog_format=ROW  </span><br><span class="line">binlog_format=MIXED  </span><br><span class="line">或者在运行时设置：</span><br><span class="line">mysql&gt; SET SESSION binlog_format = &apos;STATEMENT&apos;;  </span><br><span class="line">mysql&gt; SET SESSION binlog_format = &apos;ROW&apos;;  </span><br><span class="line">mysql&gt; SET SESSION binlog_format = &apos;MIXED&apos;;  </span><br><span class="line">mysql&gt; SET GLOBAL binlog_format = &apos;STATEMENT&apos;;  </span><br><span class="line">mysql&gt; SET GLOBAL binlog_format = &apos;ROW&apos;;  </span><br><span class="line">mysql&gt; SET GLOBAL binlog_format = &apos;MIXED&apos;;</span><br></pre></td></tr></table></figure><h2 id="查看Binlog日志文件内容"><a href="#查看Binlog日志文件内容" class="headerlink" title="查看Binlog日志文件内容"></a>查看Binlog日志文件内容</h2><p>1.查看某个具体binlog文件的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events in &quot;mysql-bin.000001&quot;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000001 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.21-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000001 | 123 | Previous_gtids |         1 |         154 |                                       |</span><br><span class="line">| mysql-bin.000001 | 154 | Anonymous_Gtid |         1 |         219 | SET @@SESSION.GTID_NEXT= &apos;ANONYMOUS&apos;  |</span><br><span class="line">| mysql-bin.000001 | 219 | Query          |         1 |         302 | BEGIN                                 |</span><br><span class="line">| mysql-bin.000001 | 302 | Table_map      |         1 |         378 | table_id: 180 (tourism.user_tags)     |</span><br><span class="line">| mysql-bin.000001 | 378 | Write_rows     |         1 |         445 | table_id: 180 flags: STMT_END_F       |</span><br><span class="line">| mysql-bin.000001 | 445 | Xid            |         1 |         476 | COMMIT /* xid=71618 */                |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2.查看某个具体binlog文件的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac mysql]# pwd</span><br><span class="line">/var/lib/mysql</span><br><span class="line">[root@b04f945297ac mysql]# mysqlbinlog mysql-bin.000001 </span><br><span class="line">mysqlbinlog: [ERROR] unknown variable &apos;default-character-set=utf8mb4&apos;</span><br><span class="line"></span><br><span class="line">如果报错，加上--no-defaults参数运行即可</span><br><span class="line"></span><br><span class="line">[root@b04f945297ac mysql]# mysqlbinlog --no-defaults mysql-bin.000001 </span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#180525 16:02:24 server id 1  end_log_pos 123 CRC32 0x62d58cd0 Start: binlog v 4, server v 5.7.21-log created 180525 16:02:24 at startup</span><br><span class="line"># Warning: this binlog is either in use or was not closed properly.</span><br><span class="line">ROLLBACK/*!*/;</span><br><span class="line">BINLOG &apos;</span><br><span class="line">EMMHWw8BAAAAdwAAAHsAAAABAAQANS43LjIxLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAQwwdbEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">AdCM1WI=</span><br><span class="line">&apos;/*!*/;</span><br><span class="line"># at 123</span><br><span class="line">#180525 16:02:24 server id 1  end_log_pos 154 CRC32 0x57b5fe8d Previous-GTIDs</span><br><span class="line"># [empty]</span><br><span class="line"># at 154</span><br><span class="line">#180525 16:02:48 server id 1  end_log_pos 219 CRC32 0xa3058217 Anonymous_GTIDlast_committed=0sequence_number=1rbr_only=yes</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;ANONYMOUS&apos;/*!*/;</span><br><span class="line"># at 219</span><br><span class="line">#180525 16:02:48 server id 1  end_log_pos 302 CRC32 0xa849ecb0 Querythread_id=633exec_time=0error_code=0</span><br><span class="line">SET TIMESTAMP=1527235368/*!*/;</span><br><span class="line">SET @@session.pseudo_thread_id=633/*!*/;</span><br><span class="line">SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;</span><br><span class="line">SET @@session.sql_mode=1073741824/*!*/;</span><br><span class="line">SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;</span><br><span class="line">/*!\C utf8mb4 *//*!*/;</span><br><span class="line">SET @@session.character_set_client=224,@@session.collation_connection=224,@@session.collation_server=8/*!*/;</span><br><span class="line">SET @@session.time_zone=&apos;SYSTEM&apos;/*!*/;</span><br><span class="line">SET @@session.lc_time_names=0/*!*/;</span><br><span class="line">SET @@session.collation_database=DEFAULT/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 302</span><br><span class="line">#180525 16:02:48 server id 1  end_log_pos 378 CRC32 0x66324940 Table_map: `tourism`.`user_tags` mapped to number 180</span><br><span class="line"># at 378</span><br><span class="line">#180525 16:02:48 server id 1  end_log_pos 445 CRC32 0x25589cf0 Write_rows: table id 180 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &apos;</span><br><span class="line">KMMHWxMBAAAATAAAAHoBAAAAALQAAAAAAAEAB3RvdXJpc20ACXVzZXJfdGFncwALA/wPAQEPERER</span><br><span class="line">EREKAlAA/AMAAAAAAMAHQEkyZg==</span><br><span class="line">KMMHWx4BAAAAQwAAAL0BAAAAALQAAAAAAAEAAgAL///A/AMAAAAAAANjY2MBAAcAczowOiIiO1sI</span><br><span class="line">M6hbCDOo8JxYJQ==</span><br><span class="line">&apos;/*!*/;</span><br><span class="line"># at 445</span><br><span class="line">#180525 16:02:48 server id 1  end_log_pos 476 CRC32 0xd1963b7d Xid = 71618</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure><blockquote><p>这里Binlog 显示和选择存储的格式相关</p></blockquote><p>执行下面语句，查看对应Binlog记录格式</p><p><code>INSERT INTO</code>staff<code>(</code>name<code>) VALUES (&#39;zhimma&#39;)</code></p><h3 id="row格式对应格式："><a href="#row格式对应格式：" class="headerlink" title="row格式对应格式："></a>row格式对应格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BINLOG &apos;</span><br><span class="line">Cb8PWxMBAAAAOgAAAF0BAAAAAGQAAAAAAAEABHRlc3QABXN0YWZmAAYDDw8DAxIF/QL9AgAAkkVd</span><br><span class="line">Dg==</span><br><span class="line">Cb8PWx4BAAAAPwAAAJwBAAAAAGQAAAAAAAEAAgAG/8ADAAAABgB6aGltbWEAAAAAAAAAAAAAgAAA</span><br></pre></td></tr></table></figure><h3 id="statement格式对应格式："><a href="#statement格式对应格式：" class="headerlink" title="statement格式对应格式："></a>statement格式对应格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use `test`/*!*/;</span><br><span class="line">SET TIMESTAMP=1527758668/*!*/;</span><br><span class="line">INSERT INTO `staff` (`name`) VALUES (&apos;zhimma&apos;)</span><br><span class="line">/*!*/;</span><br></pre></td></tr></table></figure><h3 id="mixd格式对应格式："><a href="#mixd格式对应格式：" class="headerlink" title="mixd格式对应格式："></a>mixd格式对应格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BINLOG &apos;</span><br><span class="line">S74PWw8BAAAAdwAAAHsAAAAAAAQANS43LjIxLWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAABLvg9bEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">AY4lTRU=</span><br></pre></td></tr></table></figure><h2 id="提取Binlog文件"><a href="#提取Binlog文件" class="headerlink" title="提取Binlog文件"></a>提取Binlog文件</h2><h3 id="提取指定的binlog日志"><a href="#提取指定的binlog日志" class="headerlink" title="提取指定的binlog日志"></a>提取指定的binlog日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac mysql]# mysqlbinlog --no-defaults  /var/lib/mysql/mysql-bin.000001 |grep INSERT  </span><br><span class="line">SET INSERT_ID=4/*!*/;</span><br><span class="line">INSERT INTO `staff` (`name`) VALUES (&apos;zhimma&apos;)</span><br></pre></td></tr></table></figure><h3 id="提取指定position位置的binlog日志"><a href="#提取指定position位置的binlog日志" class="headerlink" title="提取指定position位置的binlog日志"></a>提取指定position位置的binlog日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac mysql]# mysqlbinlog --no-defaults --start-position=&quot;154&quot; --stop-position=&quot;481&quot; /var/lib/mysql/mysql-bin.000001 | grep INSERT</span><br><span class="line">SET INSERT_ID=5/*!*/;</span><br><span class="line">INSERT INTO `staff` (`name`) VALUES (&apos;zhimma&apos;)</span><br></pre></td></tr></table></figure><h3 id="提取指定position位置的binlog日志并输出到压缩文件"><a href="#提取指定position位置的binlog日志并输出到压缩文件" class="headerlink" title="提取指定position位置的binlog日志并输出到压缩文件"></a>提取指定position位置的binlog日志并输出到压缩文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --start-position=&quot;154&quot; --stop-position=&quot;481&quot; /var/lib/mysql/mysql-bin.000001 |gzip &gt; extra_01.sql.gz</span><br><span class="line">[root@b04f945297ac binlog]# ls</span><br><span class="line">extra_01.sql.gz</span><br><span class="line">建议加上过滤</span><br><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --start-position=&quot;154&quot; --stop-position=&quot;481&quot; /var/lib/mysql/mysql-bin.000001 | grep INSERT | gzip &gt; extra_01.sql.gz</span><br></pre></td></tr></table></figure><h3 id="提取指定position位置的binlog日志导入数据库"><a href="#提取指定position位置的binlog日志导入数据库" class="headerlink" title="提取指定position位置的binlog日志导入数据库"></a>提取指定position位置的binlog日志导入数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --start-position=&quot;154&quot; --stop-position=&quot;481&quot; /var/lib/mysql/mysql-bin.000001 | mysql -uroot -p</span><br></pre></td></tr></table></figure><h3 id="提取指定时间区间的binlog并输出到日志文件"><a href="#提取指定时间区间的binlog并输出到日志文件" class="headerlink" title="提取指定时间区间的binlog并输出到日志文件"></a>提取指定时间区间的binlog并输出到日志文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --start-datetime=&quot;2018-05-30 00:00:00&quot; --stop-datetime=&quot;2018-06-30 00:00:00&quot; /var/lib/mysql/mysql-bin.000001 --result-file=20180530_20180630.sql</span><br></pre></td></tr></table></figure><h3 id="提取指定位置的多个binlog日志文件"><a href="#提取指定位置的多个binlog日志文件" class="headerlink" title="提取指定位置的多个binlog日志文件"></a>提取指定位置的多个binlog日志文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --start-datetime=&quot;2018-05-30 00:00:00&quot; --stop-datetime=&quot;2018-06-30 00:00:00&quot; /var/lib/mysql/mysql-bin.000001 /var/lib/mysql/mysql-bin.000002 --result-file=20180530_20180630.sql</span><br></pre></td></tr></table></figure><h3 id="提取指定数据库binlog并转换字符集到UTF8"><a href="#提取指定数据库binlog并转换字符集到UTF8" class="headerlink" title="提取指定数据库binlog并转换字符集到UTF8"></a>提取指定数据库binlog并转换字符集到UTF8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog --no-defaults --database=test --set-charset=utf8 --start-datetime=&quot;2018-05-30 00:00:00&quot; --stop-datetime=&quot;2018-06-30 00:00:00&quot; /var/lib/mysql/mysql-bin.000001 /var/lib/mysql/mysql-bin.000002 &gt; test_20180530_20180630.sql</span><br></pre></td></tr></table></figure><h3 id="远程提取使用row格式的binlog日志并输出到本地文件"><a href="#远程提取使用row格式的binlog日志并输出到本地文件" class="headerlink" title="远程提取使用row格式的binlog日志并输出到本地文件"></a>远程提取使用row格式的binlog日志并输出到本地文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac binlog]#  mysqlbinlog  --no-defaults -urobin -p -P3606 -h192.168.1.1 --read-from-remote-server -vv --database=test --set-charset=utf8 --start-datetime=&quot;2018-05-30 00:00:00&quot; --stop-datetime=&quot;2018-06-30 00:00:00&quot; /var/lib/mysql/mysql-bin.000001 &gt; remote_20180530_20180630.sql</span><br></pre></td></tr></table></figure><blockquote><p>有了sql语句，数据就好恢复了</p></blockquote><h2 id="binlog2sql"><a href="#binlog2sql" class="headerlink" title="binlog2sql"></a><a href="https://github.com/danfengcao/binlog2sql" target="_blank" rel="noopener">binlog2sql</a></h2><p>点击查看文档</p><p><a href="https://blog.csdn.net/shudaqi2010/article/details/54412895" target="_blank" rel="noopener">https://blog.csdn.net/shudaqi2010/article/details/54412895</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据类型</title>
      <link href="/2018/11/30/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/11/30/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h3><h3 id="varchar数据类型的变化"><a href="#varchar数据类型的变化" class="headerlink" title="varchar数据类型的变化"></a>varchar数据类型的变化</h3><p>MySQL4.1以下的版本中，varchar数据类型的最大长度限制为255，其数据范围可以是0~255或1~255（根据不同版本数据库来定）</p><p>MySQL5.0以上的版本中，varchar数据类型的长度支持到了65535，也就是说可以存放65532个字节的数据，起始位和结束位占去了3个字节</p><p>Mysql5根据编码不同,存储大小也不同，具体有以下规则：</p><ul><li>存储限制</li></ul><p>varchar 字段是将实际内容单独存储在聚簇索引之外，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。</p><ul><li>编码长度限制</li></ul><p>字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766;</p><p>字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过<strong>21845</strong>。</p><p>若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。</p><ul><li>行长度限制</li></ul><p>导致实际应用中varchar长度限制的是一个行定义的长度。 MySQL要求一个行的定义长度不能超过65535。若定义的表长度超过这个值，则提示</p><p><code>ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。</code></p><h3 id="char-M-varchar-M-不同之处"><a href="#char-M-varchar-M-不同之处" class="headerlink" title="char(M), varchar(M)不同之处"></a>char(M), varchar(M)不同之处</h3><p>char(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存char值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。char存储定长数据很方便，<strong>char字段上的索引效率级高</strong>，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p><p>varchar(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间，(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。varchar值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。varchar值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。varchar存储变长数据，但存储效率没有char高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么”+1”呢？这一个字节用于保存实际使用了多大的长度。<strong>从空间上考虑，用varchar合适；从效率上考虑，用char合适</strong>，关键是根据实际情况找到权衡点。</p><p>char和varchar最大的不同就是一个是固定长度，一个是可变长度。由于是可变长度，因此实际存储的时候是实际字符串再加上一个记录字符串长度的字节(如果超过255则需要两个字节)。如果分配给char或varchar列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。</p><h3 id="VARCHAR和TEXT、BlOB类型的区别"><a href="#VARCHAR和TEXT、BlOB类型的区别" class="headerlink" title="VARCHAR和TEXT、BlOB类型的区别"></a>VARCHAR和TEXT、BlOB类型的区别</h3><p>VARCHAR，BLOB和TEXT类型是变长类型，对于其存储需求取决于列值的实际长度(在前面的表格中用L表示)，而不是取决于类型的最大可能尺寸。例如，一个VARCHAR(10)列能保存最大长度为10个字符的一个字符串，实际的存储需要是字符串的长度 ，加上1个字节以记录字符串的长度。对于字符串’abcd’，L是4而存储要求是5个字节。</p><p>BLOB和TEXT类型需要1，2，3或4个字节来记录列值的长度，这取决于类型的最大可能长度。VARCHAR需要定义大小，有65535字节的最大限制；TEXT则不需要。如果你把一个超过列类型最大长度的值赋给一个BLOB或TEXT列，值被截断以适合它。</p><p>一个BLOB是一个能保存可变数量的数据的二进制的大对象。4个BLOB类型TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB仅仅在他们能保存值的最大长度方面有所不同。</p><p>BLOB 可以储存图片,TEXT不行，TEXT只能储存纯文本文件。4个TEXT类型TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT对应于4个BLOB类型，并且有同样的最大长度和存储需求。在BLOB和TEXT类型之间的唯一差别是对BLOB值的排序和比较以大小写敏感方式执行，而对TEXT值是大小写不敏感的。换句话说，一个TEXT是一个大小写不敏感的BLOB</p><h3 id="总结char，varchar，text区别"><a href="#总结char，varchar，text区别" class="headerlink" title="总结char，varchar，text区别"></a>总结char，varchar，text区别</h3><p>长度的区别，char范围是0～255，varchar最长是64k，但是注意这里的64k是整个row的长度，要考虑到其它的column，还有如果存在not null的时候也会占用一位，对不同的字符集，有效长度还不一样，比如utf8的，最多21845，还要除去别的column，但是varchar在一般情况下存储都够用了。如果遇到了大文本，考虑使用text，最大能到4G。</p><p>效率来说基本是char&gt;varchar&gt;text，但是如果使用的是Innodb引擎的话，推荐使用varchar代替char</p><p>char和varchar可以有默认值，text不能指定默认值</p><p>数据库选择合适的数据类型存储还是很有必要的，对性能有一定影响。这里在零碎记录两笔，对于int类型的，如果不需要存取负值，最好加上unsigned；对于经常出现在where语句中的字段，考虑加索引，整形的尤其适合加索引。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2018/11/30/Nginx/"/>
      <url>/2018/11/30/Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h3><p>Mainline version        开发版本</p><p>Stable version        稳定版本</p><p>Legacy versions        历史版本</p><h3 id="安装源"><a href="#安装源" class="headerlink" title="安装源"></a>安装源</h3><p>To set up the yum repository for RHEL/CentOS, create the file named <code>/etc/yum.repos.d/nginx.repo</code> with the following contents:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; [nginx]</span><br><span class="line">&gt; name=nginx repo</span><br><span class="line">&gt; baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/</span><br><span class="line">&gt; gpgcheck=0</span><br><span class="line">&gt; enabled=1</span><br><span class="line">&gt; </span><br><span class="line">&gt; baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Replace “<code>OS</code>” with “<code>rhel</code>” or “<code>centos</code>”, depending on the distribution used, and “<code>OSRELEASE</code>” with “<code>6</code>” or “<code>7</code>”, for 6.x or 7.x versions, respectively.</p><h3 id="查看nginx安装包"><a href="#查看nginx安装包" class="headerlink" title="查看nginx安装包"></a>查看nginx安装包</h3><p><code>yum list | grep nginx</code></p><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><p><code>yum install nginx -y</code></p><h3 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@host ~]# nginx -v</span><br><span class="line"><span class="attribute">nginx</span> version: nginx/<span class="number">1</span>.<span class="number">14</span>.<span class="number">2</span></span><br><span class="line">[root<span class="variable">@host</span> ~]<span class="comment"># nginx -V</span></span><br><span class="line">nginx version: nginx/<span class="number">1</span>.<span class="number">14</span>.<span class="number">2</span></span><br><span class="line">built by gcc <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span> <span class="number">20150623</span> (Red Hat <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">28</span>) (GCC)</span><br><span class="line">built with OpenSSL <span class="number">1</span>.<span class="number">0</span>.<span class="number">2k</span>-fips  <span class="number">26</span> Jan <span class="number">2017</span></span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --<span class="literal">error</span>-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=<span class="string">'-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC'</span> --with-ld-opt=<span class="string">'-Wl,-z,relro -Wl,-z,now -pie'</span></span><br></pre></td></tr></table></figure><h2 id="nginx-配置解析"><a href="#nginx-配置解析" class="headerlink" title="nginx 配置解析"></a>nginx 配置解析</h2><table><thead><tr><th>user</th><th>设置nginx服务的系统使用用户</th></tr></thead><tbody><tr><td>worker_processes</td><td>工作进程数</td></tr><tr><td>error_log</td><td>nginx的错误日志</td></tr><tr><td>pid</td><td>nginx服务</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> www www;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /home/wwwlogs/nginx_error.log <span class="literal">error</span>;</span><br><span class="line"><span class="comment"># pid /usr/local/nginx/logs/nginx.pid;</span></span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="comment">#Specifies the value for maximum file descriptors that can be opened by this process.</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>events</th><th>worker_connections</th><th>每个工作进程运行的最大链接数</th></tr></thead><tbody><tr><td></td><td>use</td><td>工作进程模式</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx-模块"><a href="#nginx-模块" class="headerlink" title="nginx 模块"></a>nginx 模块</h2><h3 id="stub-status"><a href="#stub-status" class="headerlink" title="stub_status"></a>stub_status</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /nginx &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 20 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 274 274 784 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 19</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL添加新用户1364</title>
      <link href="/2018/11/30/MySQL%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B71364/"/>
      <url>/2018/11/30/MySQL%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B71364/</url>
      
        <content type="html"><![CDATA[<p>MySQL5.7添加新用户 出现<code>ERROR 1364 (HY000): Field &#39;ssl_cipher&#39; doesn&#39;t have a default value</code></p><p>## </p><h2 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h2><p><code>insert into user (host,user,authentication_string,select_priv,insert_priv,update_priv) values (&#39;%&#39; , &#39;mma&#39; ,PASSWORD(&#39;123456&#39;),&#39;Y&#39;,&#39;Y&#39;,&#39;Y&#39;);</code></p><p><strong>原因</strong>：</p><p>在我的配置文件my.cnf中有这样一条语句<code>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</code></p><p>指定了严格模式，为了安全，严格模式禁止通过insert 这种形式直接修改<strong>MySQL</strong>库中的<strong>user</strong>表进行添加新用户</p><p><strong>解决方法</strong>:</p><p>将配置文件中的STRICT_TRANS_TABLES删掉，即改为：</p><p><code>sql_mode=NO_ENGINE_SUBSTITUTION</code></p><p>然后重启mysql即可</p><h2 id="解决方法2-推荐-："><a href="#解决方法2-推荐-：" class="headerlink" title="解决方法2(推荐)："></a>解决方法2(推荐)：</h2><p>添加用户：</p><p><code>grant usage on *.* to &#39;mma&#39;@&#39;%&#39; identified by &#39;123456&#39; with grant option;</code></p><p>赋予权限</p><p><code>grant all privileges on *.* to &#39;mma&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></p><p><strong>or</strong></p><p><code>grant select,insert,update,delete,create,drop ON TUTORIALS.* TO &#39;mma&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></p><p>刷新权限</p><p><code>flush privileges;</code></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx与PHP的交互机制(1)</title>
      <link href="/2018/11/30/Nginx%E4%B8%8EPHP%E7%9A%84%E4%BA%A4%E4%BA%92%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/11/30/Nginx%E4%B8%8EPHP%E7%9A%84%E4%BA%A4%E4%BA%92%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx与PHP的交互机制-1"><a href="#Nginx与PHP的交互机制-1" class="headerlink" title="Nginx与PHP的交互机制(1)"></a>Nginx与PHP的交互机制(1)</h1><p>from there <a href="https://www.awaimai.com/371.html" target="_blank" rel="noopener">https://www.awaimai.com/371.html</a></p><p>在搭建 LAMP/LNMP 服务器时，会经常遇到 PHP-FPM、FastCGI和CGI 这几个概念。如果对它们一知半解，很难搭建出高性能的服务器。接下来我们就以图形方式，解释这些概念之间的关系。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在整个网站架构中，Web Server（如Apache）只是内容的分发者。举个栗子，如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Nginx%2BPHP/php-nginx-1.png" alt="php-nginx-1"></p><p>如果请求的是 index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。</p><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Nginx%2BPHP/php-nginx-2.png" alt="php-nginx-2"></p><p>当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程</p><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a><strong>CGI</strong></h2><p><strong>CGI</strong>是 Web Server 与 Web Application 之间数据交换的一种协议。<br>CGI全称是“公共网关接口”(Common Gateway Interface)，描述的是<strong>服务器和请求处理程序之间传输数据的一种标准</strong>（服务器与你的或其它机器上的程序进行“交谈”的一种工具）。 所以，<code>CGI</code>是一种协议。<code>CGI</code>可用于任何语言，只要该语言具有标准的输出、输入以及环境变量。如perl、php等语言。 以nginx和php为例，我们可以理解为，这是php在与nginx服务器之间交互时，对传输数据的一种约定。</p><p><strong>CGI的原理是什么?</strong><br>当需要请求使用网关的资源时，服务器会请辅助应用程序来处理请求（比如nginx会请php程序来处理请求）。 服务器会将辅助应用程序的数据传送给网关。然后网关会向服务器返回一条响应或者响应数据，服务器再将响应或响应数据转发给客户端。<br><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Nginx%2BPHP/cgi.png" alt="cgi"></p><p>由此我们可以清楚两点：</p><ol><li>服务器和网关是相互独立的应用程序</li><li>服务器是应用程序和网关之间的一座桥梁</li></ol><p>由此，我们可知<code>CGI</code>有一个致命的弱点，<strong>即应用程序的每次请求，都要引发一个全新的进程</strong>。所以，服务器和网关之间的分离会造成性能的 耗费，会限制使用<code>CGI</code>的服务器的性能，并且会加重服务端机器资源的负担。<br>好啦，重角要登场了。后来为了解决这个问题，出现了<code>FastCGI</code>，也就是快速的<code>CGI</code>。 接下来，我们再详细的了解下<code>FastCGI</code>。</p><h2 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a><strong>FastCGI</strong></h2><p> <strong>FastCGI</strong>:(Fast Common Gateway Interface),即快速通用网关接口，是一种让交互程序与Web服务器通信的协议。它是<code>CGI</code>的增强版本 <code>FastCGI</code>致力于减少网页服务器与CGI程序之间互动的开销，从而使服务器可以同时处理更多的网页请求。<br>以上来自维基百科，我们可以由此了解到，<code>FastCGI</code>，<strong>同<code>CGI</code>一样，也是一种协议，</strong>只不过它是<code>CGI</code>的增强版本。<br><strong>那<code>FastCGI</code>是如何增强性能的呢？</strong> <code>FastCGI</code>接口模拟了<code>CGI</code>，但<code>FastCGI</code>是作为持久守护进程运行的，消除了为每个请求建立或拆除新进程所带来的性能损耗。也就是允许，一个进程内可以处理多个请求。 也就说CGI解释器保持在内存中，并接受了<code>FastCGI</code>进程管理和调度，所以它可以提供更好的性能，可扩展性，故障切换等特点</p><p><strong>FastCGI的特点:</strong></p><ol><li>FastCGI与语言无关</li><li>FastCGI应用在进程中，独立于核心网络服务器，提供了一个比API环境更安全的环境。 APIs的代码和web服务器的应用的核心是 紧紧关联的。这也就意味着在API应用程序的错误可能会损坏其它应用程序或核心服务器。恶意API应用程序代码甚至可以窃取另一个应用程序或核心服务器密钥。</li><li>FastCGI技术目前支持PHP,C/C++, Java lanuage, Perl, Tcl, Python, SmallTalk, Ruby etc.. 它在Apache, ISS, Lighttpd和其他流行的 服务器中的相关模块都是可以使用的。FastCGI不依赖于任何服务器体系结构，所以即使服务器在技术上改变了，FastCGI还是稳定的</li></ol><p><strong>FastCGI的工作原理</strong></p><ol><li>Web Server 启动时载入FastCGI进程管理器 (IIS ISAPI 或Apache Module)</li><li>FastCGI进程管理器首先初始化自己，启动一批CGI解释器进程（可见多个php-cgi），然后等待来自Web Server的连接。</li><li>当Web Server中的一个客户端请求达到时， FastCGI进程管理器会选择并连接一个CGI解释器。Web server的CGI环境变量和标准输入会被送达FastCGI进程的php-cgi。</li><li>FastCGI子进程从同一连接完成返还给Web Server的标准输出和错误信息。当请求进程完成后，FastCGI进程会关闭此连接。FastCGI会等待并出来来自FastCGI进程管理器（运行在Web Server中的）的下一个连接。 在CGI模式，php-cgi然后会退出。</li></ol><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Nginx%2BPHP/nginx-fastcgi-php.png" alt="nginx-fastcgi-php"></p><p>如上图所示，FastCGI的下游，是CGI-APP，在我们的LNMP架构里，这个CGI-APP就是PHP程序。<br>而FastCGI的上游是Nginx，他们之间有一个通信载体，即图中的socket。<br>上图中的Pre-fork，则对应着我们PHP-FPM的启动，也就是在我们启动PHP-FPM时便会根据用户配置启动诸多FastCGI触发器（FastCGI Wrapper）。</p><p><strong>FastCGI的不足</strong> 因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M_10=150M），开启的64个php-cgi进程消耗1280M内存（20M_64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。 如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。 <a href="http://zyan.cc/nginx_php_v6/" target="_blank" rel="noopener">上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)</a></p><h2 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a><strong>PHP-CGI</strong></h2><p><strong>PHP-CGI</strong>：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序,是PHP自带的FastCGI管理器。</p><p><strong>PHP-CGI的不足:</strong></p><ol><li>php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启</li><li>直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</li></ol><h2 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a><strong>PHP-FPM</strong></h2><p><strong>PHP-FPM</strong>：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。<br>PHP-FPM的全称是PHP FastCGI Process Manager。<br>它是 PHP 针对 FastCGI 协议的具体实现，它会通过用户配置来管理一批FastCGI进程.<br>因此它也是PHP 在多种服务器端应用编程端口（SAPI：cgi、fast-cgi、cli、isapi、apache）里使用最普遍、性能最佳的一款进程管理器。<br>在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全。<br>PHP-FPM更像是管理器，负责管理PHP FastCGI，而真正衔接Nginx与PHP的则是FastCGI进程。<br>因此，CGI是通用网关协议，FastCGI则是一种常驻进程的CGI模式程序，而PHP-FPM更像是管理器，用于管理FastCGI进程。<br>WEB 中:</p><ul><li>Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器，</li><li>Web Application 一般指PHP、Java、Asp.net等应用程序。</li></ul><p><strong>Nginx+PHP的工程模式下，两位主角分工明确，Nginx负责承载HTTP请求的响应与返回，以及超时控制记录日志等HTTP相关的功能，而PHP则负责处理具体请求要做的业务逻辑，它们俩的这种合作模式也是常见的分层架构设计中的一种，在它们各有专注面的同时，FastCGI又很好的将两块衔接，保障上下游通信交互</strong>，这种通过某种协议或规范来衔接好上下游的模式，在我们日常的PHP应用开发中也有这样的思想落地，譬如我们所开发的<strong>高性能API</strong>，具体的Client到底是PC、APP还是某个其他程序，我们不关心，而这些PC、APP、第三方程序也不关心我们的PHP代码实现，他们按照API的规范来请求做处理即可</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCat实践</title>
      <link href="/2018/11/30/Mycat%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/11/30/Mycat%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>接着上一篇MySql主从配置完成后，下面实战下Mycat做读写分离和分库分表</p><p>参考：</p><p><a href="https://foofish.net/mysql-for-mycat.html" target="_blank" rel="noopener">https://foofish.net/mysql-for-mycat.html</a></p><p><a href="https://www.cnblogs.com/joylee/p/7513038.html" target="_blank" rel="noopener">https://www.cnblogs.com/joylee/p/7513038.html</a></p><p>[TOC]</p><h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><p>windows 下4台服务器，真实机IP：192.168.2.107，其中</p><table><thead><tr><th>服务器</th><th>IP</th><th>说明</th></tr></thead><tbody><tr><td>master</td><td>172.17.0.2</td><td>物理数据库，主库</td></tr><tr><td>mycat</td><td>172.17.0.3</td><td>mycat服务器，连接数据库时，连接此服务器</td></tr><tr><td>slave1</td><td>172.17.0.4</td><td>物理数据库，从库</td></tr><tr><td>slave2</td><td>172.17.0.5</td><td>物理数据库，从库</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mma&gt;docker ps</span><br><span class="line">CONTAINER ID          PORTS     NAMES</span><br><span class="line">b04f945297ac          0.0.0.0:1024-&gt;1024/tcp, 0.0.0.0:6379-&gt;6379/tcp, 0.0.0.0:9001-&gt;9001/tcp, 0.0.0.0:220-&gt;22/tcp, 0.0.0.0:8080-&gt;80/tcp, 0.0.0.0:33060-&gt;3306/tcp                                master</span><br><span class="line">dcccd23b6177          0.0.0.0:8066-&gt;8066/tcp, 0.0.0.0:223-&gt;22/tcp, 0.0.0.0:8083-&gt;80/tcp, 0.0.0.0:31024-&gt;1024/tcp, 0.0.0.0:33063-&gt;3306/tcp, 0.0.0.0:36379-&gt;6379/tcp, 0.0.0.0:9004-&gt;9001/tcp       myCat</span><br><span class="line">9ae039d46474          0.0.0.0:221-&gt;22/tcp, 0.0.0.0:8081-&gt;80/tcp, 0.0.0.0:10241-&gt;1024/tcp, 0.0.0.0:33061-&gt;3306/tcp, 0.0.0.0:16379-&gt;6379/tcp, 0.0.0.0:9002-&gt;9001/tcp                            slave1</span><br><span class="line">06e5a050e74b          0.0.0.0:222-&gt;22/tcp, 0.0.0.0:8082-&gt;80/tcp, 0.0.0.0:10242-&gt;1024/tcp, 0.0.0.0:33062-&gt;3306/tcp, 0.0.0.0:26379-&gt;6379/tcp, 0.0.0.0:9003-&gt;9001/tcp                            slave2</span><br></pre></td></tr></table></figure><h3 id="master"><a href="#master" class="headerlink" title="master:"></a>master:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      154 | zhimma       |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure><h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat:"></a>mycat:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dcccd23b6177 mycat]# mycat status</span><br><span class="line">Mycat-server is running (317).</span><br></pre></td></tr></table></figure><h3 id="slave1"><a href="#slave1" class="headerlink" title="slave1:"></a>slave1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.17.0.2</span><br><span class="line">                  Master_User: zhimma</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 154</span><br><span class="line">               Relay_Log_File: 9ae039d46474-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 367</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 154</span><br><span class="line">              Relay_Log_Space: 581</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: f781e2b4-28e1-11e8-a1c0-0242ac110002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><h3 id="salve2"><a href="#salve2" class="headerlink" title="salve2:"></a>salve2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.2.107</span><br><span class="line">                  Master_User: zhimma</span><br><span class="line">                  Master_Port: 33060</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 154</span><br><span class="line">               Relay_Log_File: 06e5a050e74b-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 367</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 154</span><br><span class="line">              Relay_Log_Space: 581</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: f781e2b4-28e1-11e8-a1c0-0242ac110002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>省略</p><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@dcccd23b6177 mycat]# pwd</span><br><span class="line">/etc/mycat</span><br><span class="line">[root@dcccd23b6177 mycat]# ls</span><br><span class="line">bin  catlet  conf  lib  logs  tmlogs  version.txt</span><br><span class="line">[root@dcccd23b6177 mycat]#</span><br></pre></td></tr></table></figure><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>mycat命令，启动、重启、停止等</td></tr><tr><td>catlet</td><td>catlet为Mycat的一个扩展功能</td></tr><tr><td>conf</td><td>Mycat 配置信息,重点关注</td></tr><tr><td>lib</td><td>Mycat引用的jar包，Mycat是java开发的</td></tr><tr><td>logs</td><td>日志文件，包括Mycat启动的日志和运行的日志。</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Mycat的配置文件都在conf目录里面，这里介绍几个常用的文件：</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>server.xml</td><td>Mycat的配置文件，设置账号、参数等</td></tr><tr><td>schema.xml</td><td>Mycat对应的物理数据库和数据库表的配置</td></tr><tr><td>rule.xml</td><td>Mycat分片（分库分表）规则</td></tr></tbody></table><h2 id="Mycat的架构"><a href="#Mycat的架构" class="headerlink" title="Mycat的架构"></a>Mycat的架构</h2><p>Mycat的架构其实很好理解，Mycat是代理，Mycat后面就是物理数据库。和Web服务器的Nginx类似。对于使用者来说，访问的都是Mycat，不会接触到后端的数据库。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/MySQL/mycat_process.png" alt="mycat"></p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>zhimma_mycat<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重点关注下面这段，其他默认即可。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>用户配置节点</td></tr><tr><td>–<br>name</td><td>登录的用户名，也就是连接Mycat的用户名</td></tr><tr><td>–<br>password</td><td>登录的密码，也就是连接Mycat的密码</td></tr><tr><td>–<br>schemas</td><td>数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,db2</td></tr><tr><td>–<br>privileges</td><td>配置用户针对表的增删改查的权限，具体见文档吧</td></tr></tbody></table><p>我这里配置了一个账号root密码是123456,针对数据库zhimma_mycat,读写权限都有，没有针对表做任何特殊的权限。</p><h3 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a><strong>schema.xml</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"zhimma_mycat"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"users"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"articles"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"categories"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"zhimma"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select users()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.2.107:33060"</span> <span class="attr">user</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- can have multi read hosts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS1"</span> <span class="attr">url</span>=<span class="string">"192.168.2.107:33061"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.2.107:33062"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>schema</td><td>数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应,此处为zhimma_mycat</td></tr><tr><td>dataNode</td><td>分片信息，也就是分库相关配置</td></tr><tr><td>dataHost</td><td>物理数据库，真正存储数据的数据库</td></tr></tbody></table><p>每个节点的属性逐一说明：</p><h4 id="schema"><a href="#schema" class="headerlink" title="schema:"></a>schema:</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>逻辑数据库名，与server.xml中的schema对应</td></tr><tr><td>checkSQLschema</td><td>布尔值，默认和推荐都是关闭。<br><br>如果开启则会拦截SQL语句，将其中的mycat相关字段删除<br>如：select <em> from zhimma_mycat.users;将会把SQL语句变为：<br>select </em> from users;</td></tr><tr><td>sqlMaxLimit</td><td>SQL返回条数，最好加上限制，防止查询量过大导致卡死</td></tr></tbody></table><h4 id="table"><a href="#table" class="headerlink" title="table:"></a>table:</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>表名，物理数据库中表名</td></tr><tr><td>dataNode</td><td>表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name</td></tr><tr><td>primaryKey</td><td>主键字段名，自动生成主键时需要设置</td></tr><tr><td>autoIncrement</td><td>是否自增</td></tr><tr><td>rule</td><td>分片规则名，具体规则下文rule详细介绍</td></tr></tbody></table><h4 id="dataNode"><a href="#dataNode" class="headerlink" title="dataNode"></a>dataNode</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>节点名，与table中dataNode对应</td></tr><tr><td>datahost</td><td>物理数据库名，与datahost中name对应</td></tr><tr><td>database</td><td>物理数据库中数据库名</td></tr></tbody></table><h4 id="dataHost"><a href="#dataHost" class="headerlink" title="dataHost"></a>dataHost</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>物理数据库名，与dataNode中dataHost对应</td></tr><tr><td>balance</td><td>均衡负载的方式</td></tr><tr><td>writeType</td><td>写入方式</td></tr><tr><td>dbType</td><td>数据库类型</td></tr><tr><td>heartbeat</td><td>心跳检测语句，注意语句结尾的分号要加。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> MyCat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-FPM配置详解</title>
      <link href="/2018/11/30/PHP-FPM%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/30/PHP-FPM%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ywnds.com/?p=5329" target="_blank" rel="noopener">PHP-FPM配置文件参数解释</a></p><h3 id="PHP-FPM配置详解"><a href="#PHP-FPM配置详解" class="headerlink" title="PHP-FPM配置详解"></a>PHP-FPM配置详解</h3><p>FPM配置文件为php-fpm.conf，其语法类似 php.ini 。其php手册上也有详细的讲解：<a href="http://php.net/manual/zh/install.fpm.configuration.php" target="_blank" rel="noopener">http://php.net/manual/zh/install.fpm.configuration.php</a></p><h4 id="php-fpm-conf全局配置段"><a href="#php-fpm-conf全局配置段" class="headerlink" title="php-fpm.conf全局配置段"></a>php-fpm.conf全局配置段</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含其他POOL定义配置文件</span></span><br><span class="line"><span class="keyword">include</span>=/etc/php-fpm.d<span class="comment">/*.conf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 全局配置段，定义PID文件的位置和错误日志的位置</span></span><br><span class="line"><span class="comment">[global]</span></span><br><span class="line"><span class="comment">daemonize = yes</span></span><br><span class="line"><span class="comment">pid = /var/run/php-fpm/php-fpm.pid</span></span><br><span class="line"><span class="comment">error_log = /var/log/php-fpm/error.log</span></span><br></pre></td></tr></table></figure><p>一般在主配置文件php-fpm.conf全局配置段中的配置非常少，php-fpm可以配置多个pool，每个pool都是以一个独立的配置文件来运作，默认都会定义在主配置文件的include包含文件目录中。php默认会提供一个www的pool，大概配置如下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/php-fpm.d/www.conf</span><br><span class="line">[www]</span><br><span class="line">user = apache</span><br><span class="line">group = apache</span><br><span class="line"> </span><br><span class="line">listen = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span></span><br><span class="line">listen.allowed_clients = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = <span class="number">50</span></span><br><span class="line">pm.start_servers = <span class="number">5</span></span><br><span class="line">pm.min_spare_servers = <span class="number">5</span></span><br><span class="line">pm.max_spare_servers = <span class="number">35</span></span><br></pre></td></tr></table></figure><p>每个pool配置文件参数可以独立，也可以设置在主配置文件的全局配置段中，这样每个pool就共用一个参数。建议最好分开设置。大概常用参数如下：</p><h5 id="daemonize-yes"><a href="#daemonize-yes" class="headerlink" title="daemonize = yes"></a>daemonize = yes</h5><p>#后台执行fpm，默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</p><h5 id="listen-127-0-0-1-9000"><a href="#listen-127-0-0-1-9000" class="headerlink" title="listen = 127.0.0.1:9000"></a>listen = 127.0.0.1:9000</h5><p>#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’，每个进程池都需要设置。如果nginx和php在不同的机器上，分布式处理，就设置ip这里就可以了。</p><h5 id="listen-backlog-1"><a href="#listen-backlog-1" class="headerlink" title="listen.backlog = -1"></a>listen.backlog = -1</h5><p>#backlog数，设置 listen 的半连接队列长度，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：<a href="http://www.3gyou.cc/?p=41。" target="_blank" rel="noopener">http://www.3gyou.cc/?p=41。</a></p><h5 id="log-level-notice"><a href="#log-level-notice" class="headerlink" title="log_level = notice"></a>log_level = notice</h5><p>#错误级别. 上面的php-fpm.log纪录的登记。可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice。</p><h5 id="emergency-restart-threshold-60"><a href="#emergency-restart-threshold-60" class="headerlink" title="emergency_restart_threshold = 60"></a>emergency_restart_threshold = 60</h5><h5 id="emergency-restart-interval-60s"><a href="#emergency-restart-interval-60s" class="headerlink" title="emergency_restart_interval = 60s"></a>emergency_restart_interval = 60s</h5><p>#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。0 表示 ‘关闭该功能’. 默认值: 0 (关闭).</p><h5 id="process-control-timeout-0"><a href="#process-control-timeout-0" class="headerlink" title="process_control_timeout = 0"></a>process_control_timeout = 0</h5><p>#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</p><h5 id="listen-allowed-clients-127-0-0-1"><a href="#listen-allowed-clients-127-0-0-1" class="headerlink" title="listen.allowed_clients = 127.0.0.1"></a>listen.allowed_clients = 127.0.0.1</h5><p>#允许访问FastCGI进程的IP白名单，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接。</p><h5 id="listen-owner-www"><a href="#listen-owner-www" class="headerlink" title="listen.owner = www"></a>listen.owner = www</h5><h5 id="listen-group-www"><a href="#listen-group-www" class="headerlink" title="listen.group = www"></a>listen.group = www</h5><h5 id="listen-mode-0666"><a href="#listen-mode-0666" class="headerlink" title="listen.mode = 0666"></a>listen.mode = 0666</h5><p>#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</p><h5 id="user-www"><a href="#user-www" class="headerlink" title="user = www"></a>user = www</h5><h5 id="group-www"><a href="#group-www" class="headerlink" title="group = www"></a>group = www</h5><p>#启动进程的用户和用户组，FPM 进程运行的Unix用户, 必须要设置。用户组，如果没有设置，则默认用户的组被使用。</p><h5 id="pm-dynamic"><a href="#pm-dynamic" class="headerlink" title="pm = dynamic"></a>pm = dynamic</h5><p>#php-fpm进程启动模式，pm可以设置为static和dynamic和ondemand。如果选择static，则进程数就是固定的，由pm.max_children指定固定的子进程数。如果选择dynamic，则进程数是动态变化的，由以下参数决定：</p><h5 id="pm-max-children-50"><a href="#pm-max-children-50" class="headerlink" title="pm.max_children = 50"></a>pm.max_children = 50</h5><p>#子进程能开启的最大数。</p><h5 id="pm-start-servers-2"><a href="#pm-start-servers-2" class="headerlink" title="pm.start_servers = 2"></a>pm.start_servers = 2</h5><p>#启动时的进程数，默认值为: min_spare_servers + (max_spare_servers – min_spare_servers) / 2。</p><h5 id="pm-min-spare-servers-1"><a href="#pm-min-spare-servers-1" class="headerlink" title="pm.min_spare_servers = 1"></a>pm.min_spare_servers = 1</h5><p>#保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程。</p><h5 id="pm-max-spare-servers-3"><a href="#pm-max-spare-servers-3" class="headerlink" title="pm.max_spare_servers = 3"></a>pm.max_spare_servers = 3</h5><p>#保证空闲进程数最大值，如果空闲进程大于此值，此进行清理。</p><h5 id="pm-max-requests-500"><a href="#pm-max-requests-500" class="headerlink" title="pm.max_requests = 500"></a>pm.max_requests = 500</h5><p>#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0’ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0。</p><h5 id="pm-status-path-status"><a href="#pm-status-path-status" class="headerlink" title="pm.status_path = /status"></a>pm.status_path = /status</h5><p>#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</p><h5 id="ping-path-ping"><a href="#ping-path-ping" class="headerlink" title="ping.path = /ping"></a>ping.path = /ping</h5><p>#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</p><h5 id="ping-response-pong"><a href="#ping-response-pong" class="headerlink" title="ping.response = pong"></a>ping.response = pong</h5><p>#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</p><h5 id="access-log-log-pool-access-log"><a href="#access-log-log-pool-access-log" class="headerlink" title="access.log = log/$pool.access.log"></a>access.log = log/$pool.access.log</h5><p>#每一个请求的访问日志，默认是关闭的。</p><h5 id="access-format-“-R-–-u-t-”-m-r-Q-q-”-s-f-mili-d-kilo-M-C-”"><a href="#access-format-“-R-–-u-t-”-m-r-Q-q-”-s-f-mili-d-kilo-M-C-”" class="headerlink" title="access.format = “%R – %u %t \”%m %r%Q%q\” %s %f %{mili}d %{kilo}M %C%%”"></a>access.format = “%R – %u %t \”%m %r%Q%q\” %s %f %{mili}d %{kilo}M %C%%”</h5><p>#设定访问日志的格式。</p><h5 id="slowlog-log-pool-log-slow"><a href="#slowlog-log-pool-log-slow" class="headerlink" title="slowlog = log/$pool.log.slow"></a>slowlog = log/$pool.log.slow</h5><p>#慢请求的记录日志,配合request_slowlog_timeout使用，默认关闭</p><h5 id="request-slowlog-timeout-10s"><a href="#request-slowlog-timeout-10s" class="headerlink" title="request_slowlog_timeout = 10s"></a>request_slowlog_timeout = 10s</h5><p>#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ‘0’ 表示 ‘Off’</p><h5 id="request-terminate-timeout-0"><a href="#request-terminate-timeout-0" class="headerlink" title="request_terminate_timeout = 0"></a>request_terminate_timeout = 0</h5><p>#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。</p><h5 id="rlimit-files-1024"><a href="#rlimit-files-1024" class="headerlink" title="rlimit_files = 1024"></a>rlimit_files = 1024</h5><p>#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</p><h5 id="rlimit-core-0"><a href="#rlimit-core-0" class="headerlink" title="rlimit_core = 0"></a>rlimit_core = 0</h5><p>#设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值。</p><h5 id="chroot-data-app"><a href="#chroot-data-app" class="headerlink" title="chroot = /data/app"></a>chroot = /data/app</h5><p>#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用。</p><h5 id="chdir-data-app"><a href="#chdir-data-app" class="headerlink" title="chdir = /data/app"></a>chdir = /data/app</h5><p>#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）。</p><h5 id="catch-workers-output-yes"><a href="#catch-workers-output-yes" class="headerlink" title="catch_workers_output = yes"></a>catch_workers_output = yes</h5><p>#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空。</p><p>当然还有一些无关紧要的设置，用到了再说吧。</p><h3 id="PHP-FPM重要的设置"><a href="#PHP-FPM重要的设置" class="headerlink" title="PHP-FPM重要的设置"></a>PHP-FPM重要的设置</h3><h4 id="PHP-FPM重要的设置-1"><a href="#PHP-FPM重要的设置-1" class="headerlink" title="PHP-FPM重要的设置"></a>PHP-FPM重要的设置</h4><p>在之前的文章中就说过了。在fasgcgi模式下，php会启动多个php-fpm进程，来接收nginx发来的请求，那是不是进程越多，速度就越快呢？这可不一定！得根据我们的机器配置和业务量来决定。</p><p>我们先来看下，设定进程的配置在哪里？</p><h5 id="pm-static-dynamic-ondemand"><a href="#pm-static-dynamic-ondemand" class="headerlink" title="pm = static | dynamic | ondemand"></a>pm = static | dynamic | ondemand</h5><p>pm可以设置成这样3种，我们用的最多的就上前面2种。</p><p>pm = static模式</p><p>pm = static 表示我们创建的php-fpm子进程数量是固定的，那么就只有pm.max_children = 50这个参数生效。你启动php-fpm的时候就会一起全部启动51(1个主＋50个子)个进程，颇为壮观。</p><p>pm = dynamic模式</p><p>pm = dynamic模式，表示启动进程是动态分配的，随着请求量动态变化的。他由pm.max_children，pm.start_servers，pm.min_spare_servers，pm.max_spare_servers 这几个参数共同决定。</p><p>上面已经讲过，这里再重申一下吧：</p><p>pm.max_children ＝ 50是最大可创建的子进程的数量。必须设置。这里表示最多只能50个子进程。</p><p>pm.start_servers = 20随着php-fpm一起启动时创建的子进程数目。默认值：min_spare_servers + (max_spare_servers – min_spare_servers) / 2。这里表示，一起启动会有20个子进程。</p><p>pm.min_spare_servers = 10</p><p>设置服务器空闲时最小php-fpm进程数量。必须设置。如果空闲的时候，会检查如果少于10个，就会启动几个来补上。</p><p>pm.max_spare_servers = 30</p><p>设置服务器空闲时最大php-fpm进程数量。必须设置。如果空闲时，会检查进程数，多于30个了，就会关闭几个，达到30个的状态。<br>到底选择static还数dynamic?</p><p>很多人恐惧症来袭，不知道选什么好？</p><p>一般原则是：动态适合小内存机器，灵活分配进程，省内存。静态适用于大内存机器，动态创建回收进程对服务器资源也是一种消耗。</p><p>如果你的内存很大，有8-20G，按照一个php-fpm进程20M算，100个就2G内存了，那就可以开启static模式。如果你的内存很小，比如才256M，那就要小心设置了，因为你的机器里面的其他的进程也算需要占用内存的，所以设置成dynamic是最好的，比如：pm.max_chindren = 8, 占用内存160M左右，而且可以随时变化，对于一半访问量的网站足够了。</p><h4 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h4><p>我们有时候会经常饱受500,504问题困扰。当nginx收到如上错误码时，可以确定后端php-fpm解析php出了某种问题，比如，执行错误，执行超时。</p><p>这个时候，我们是可以开启慢日志功能的。</p><h5 id="slowlog-usr-local-var-log-php-fpm-log-slow"><a href="#slowlog-usr-local-var-log-php-fpm-log-slow" class="headerlink" title="slowlog = /usr/local/var/log/php-fpm.log.slow"></a>slowlog = /usr/local/var/log/php-fpm.log.slow</h5><h5 id="request-slowlog-timeout-15s"><a href="#request-slowlog-timeout-15s" class="headerlink" title="request_slowlog_timeout = 15s"></a>request_slowlog_timeout = 15s</h5><p>当一个请求该设置的超时时间15秒后，就会将对应的PHP调用堆栈信息完整写入到慢日志中。</p><p>php-fpm慢日志会记录下进程号，脚本名称，具体哪个文件哪行代码的哪个函数执行时间过长：</p><p>[21-Nov-2013 14:30:38] [pool www] pid 11877<br>script_filename = /usr/local/lnmp/nginx/html/<a href="http://www.quancha.cn/www/fyzb.php" target="_blank" rel="noopener">www.quancha.cn/www/fyzb.php</a><br>[0xb70fb88c] file_get_contents() /usr/local/lnmp/nginx/html/<a href="http://www.quancha.cn/www/fyzb.php:2" target="_blank" rel="noopener">www.quancha.cn/www/fyzb.php:2</a></p><p>通过日志，我们就可以知道第2行的file_get_contents 函数有点问题，这样我们就能追踪问题了。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP-FPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中匿名函数</title>
      <link href="/2018/11/30/PHP%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/30/PHP%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>匿名函数,说白了就是”没有名字的函数”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = function()&#123;</span><br><span class="line">    //this is a closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面声明的就是匿名函数,没有什么特别的,和一般函数结构神似,唯独少了个函数名。并且这个<strong>函数可以作为一个值被赋予一个变量或者对象属性</strong>。这种特性是的拥有匿名函数的编程语言在设计一些应用时,更为灵活。</p><p>匿名函数和普通函数最大的区别是在于：</p><ol><li>匿名函数可以作为一个具体的”值”赋予给变量或者对象属性</li><li>匿名函数可以被定义在不同地方,使得它可以有效利用他所在的局域内的变量（或者说上下文环境）</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class foo</span><br><span class="line">&#123;</span><br><span class="line">    public function exec(Closure $callback)</span><br><span class="line">    &#123;</span><br><span class="line">        echo $callback();//hi ,nick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$name = &quot;nick&quot;;</span><br><span class="line">(new foo())-&gt;exec(function() use ($name)&#123;</span><br><span class="line">    return &quot;hi ,&quot;.$name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到,匿名函数使用使用了上下文中的变量$name。而实际上,这个匿名函数实在另一个地方被执行（foo类里面）。这样使得我们不必将变量$name的值通过参数传递到foo类的exec方法中,而且可以减少在exec方法中不必要的处理逻辑,使得类跟家专注于自己的职责；</p><p>匿名函数定义时不会被执行,除非被调用,上文中的例子就是这样,利用这种特性,我们可以利用它来实现一个<a href="(https://blog.bytesclub.com/2017/05/07/设计模式-控制反转及其依赖注入（2）/">控制反转（IoC）容器</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一个简单的IoC容器</span><br><span class="line"> */</span><br><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected static $bindings;</span><br><span class="line"> </span><br><span class="line">    public static function bind($abstract, Closure $concrete)</span><br><span class="line">    &#123;</span><br><span class="line">        static::$bindings[$abstract] = $concrete;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static function make($abstract)</span><br><span class="line">    &#123;</span><br><span class="line">        return call_user_func(static::$bindings[$abstract]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 示例用的 talk 类</span><br><span class="line"> */</span><br><span class="line">class talk</span><br><span class="line">&#123;</span><br><span class="line">    public function greet($target)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;hi, &apos; . $target-&gt;getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 示例用的 A 类</span><br><span class="line"> */</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public function getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return &apos;Nick&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 示例用的 B 类</span><br><span class="line"> */</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    public function getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return &apos;Amy&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 以下代码是主要示例代码</span><br><span class="line"> </span><br><span class="line">// 创建一个talk类的实例</span><br><span class="line">$talk = new talk;</span><br><span class="line"> </span><br><span class="line">// 将A类绑定至容器,命名为foo</span><br><span class="line">Container::bind(&apos;foo&apos;, function() &#123;</span><br><span class="line">    return new A;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 将B类绑定至容器,命名为bar</span><br><span class="line">Container::bind(&apos;bar&apos;, function() &#123;</span><br><span class="line">    return new B;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 通过容器取出实例</span><br><span class="line">$talk-&gt;greet(Container::make(&apos;foo&apos;)); // hi, Nick</span><br><span class="line">$talk-&gt;greet(Container::make(&apos;bar&apos;)); // hi, Amy</span><br></pre></td></tr></table></figure><p>上述例子中,只有通过make方法获取实例的时候,实例才被创建,使得我们可以实现容器。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包/匿名函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置整理</title>
      <link href="/2018/11/30/Nginx%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/"/>
      <url>/2018/11/30/Nginx%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx配置整理"><a href="#Nginx配置整理" class="headerlink" title="Nginx配置整理"></a>Nginx配置整理</h1><p><a href="https://www.zybuluo.com/phper/note/89391" target="_blank" rel="noopener">https://www.zybuluo.com/phper/note/89391</a></p><h2 id="nginx-conf配置概览"><a href="#nginx-conf配置概览" class="headerlink" title="nginx.conf配置概览"></a>nginx.conf配置概览</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line"></span><br><span class="line">events&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">upstram myObject&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server1&#123;</span><br><span class="line">...</span><br><span class="line">location&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">serverN&#123;</span><br><span class="line">...</span><br><span class="line">location&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx配置文件主要分为六个区域：</p><p>main(全局设置)、event(nginx工作模式)、http(http设置)、upstream(负载均衡服务器设置)、server(主机设置)、location(URL匹配)。</p><h3 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 来指定Nginx Worker进程运行的用户及用户组，默认由nobody账号运行。</span><br><span class="line">user  nobody nobody;</span><br><span class="line">// 来指定Nginx要快起的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验一般指定一个进程就足够了，如果是多核CPU，建议数量和CPU数量保持一样即可。</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">// 用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">// 用来指定进程id的存储文件位置</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line">// 用于指定一个nginx进程最多可以打开的最多文件描述符数目</span><br><span class="line">worker_rlimit_nofile 1024;</span><br></pre></td></tr></table></figure><h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">use kqueue;  #mac平台</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use</code>用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p><code>worker_connections</code>用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由<code>worker_processes</code>和<code>worker_connections</code>决定，即<code>Max_clients=worker_processes*worker_connections</code>，在作为反向代理时，Max_clients变为：<code>Max_clients = worker_processes * worker_connections/4</code>。<br>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p><h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><p>Http模块是核心的模块，负责HTTP服务相关属性的配置，包含server和upstream子模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">// incluede 用来设定文件的mime类型，类型在配置文件目录下的mime.type文件定义，用来告诉nginx来识别文件类型</span><br><span class="line">    include       mime.types;</span><br><span class="line">// 设置了默认类型为二进制流，也就是说当文件类型未定义时使用这种方式。   </span><br><span class="line">default_type  application/octet-stream;</span><br><span class="line">    client_max_body_size 120m;</span><br><span class="line">// 设置日志格式和记录那修参数 这里设置为main，刚好用于access_log来记录这种类型</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">// 用来纪录每次的访问日志的文件地址，后面的`main`是日志的格式样式，对应于log_format的main。</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">// 用于开启高效文件传输模式，将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">// 设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">upstream myproject &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 标志定义虚拟主机开始</span><br><span class="line">server &#123;</span><br><span class="line">// 用于指定虚拟主机的服务端口</span><br><span class="line">    listen       80;</span><br><span class="line">// 用来指定IP地址或者域名，多个域名直接用空格分个格</span><br><span class="line">    server_name  localhost 192.168.12.10 www.yangyi.com;</span><br><span class="line">    // 表示虚拟主机的root web目录</span><br><span class="line">    root   /home/www;</span><br><span class="line">// 全局定义访问的默认首页地址，需要和locate&#123;&#125;下面定义的区分开来</span><br><span class="line">    index  index.php index.html index.htm; </span><br><span class="line">// 设置网页的默认编码格式</span><br><span class="line">    charset utf-8;</span><br><span class="line">// 用来存放次虚拟主机的日志目录，最后的main用来指定访问日志的输出格式</span><br><span class="line">    access_log  usr/local/var/log/host.access.log  main;</span><br><span class="line">    aerror_log  usr/local/var/log/host.error.log  error;</span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h5><p>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关<br>location 根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 匹配访问根目录</span><br><span class="line">location / &#123;</span><br><span class="line">// root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</span><br><span class="line">    root   /home/www;</span><br><span class="line">// index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</span><br><span class="line">    index  index.php index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正则匹配.php结尾的URL</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           /home/www;</span><br><span class="line">// fast_pass链接的是php-fpm 的地址</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    include        fastcgi.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="upstream-模块"><a href="#upstream-模块" class="headerlink" title="upstream 模块"></a>upstream 模块</h4><p>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream demo.com&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.12.1:80;</span><br><span class="line">    server 192.168.12.2:80 down;</span><br><span class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</span><br><span class="line">    server 192.168.12.4:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，通过<code>upstream</code>指令指定了一个负载均衡器的名称<code>demo.com</code>。这个名称可以任意指定，在后面需要的地方直接调用即可。</p><p>里面是<code>ip_hash</code>这是其中的一种负载均衡调度算法。紧接着就是各种服务器了。用<code>server</code>关键字表识，后面接ip。</p><p>Nginx的<code>负载均衡</code>模块目前支持<code>4种调度算法</code>:</p><ol><li>weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li><li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li><li>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li><li>url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li></ol><p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><ul><li>down，表示当前的server暂时不参与负载均衡。</li><li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li><li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li><li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li></ul><p><strong>注意</strong> 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中匿名函数和闭包初探</title>
      <link href="/2018/11/30/PHP%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/11/30/PHP%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="「闭包」和「匿名」的区别"><a href="#「闭包」和「匿名」的区别" class="headerlink" title="「闭包」和「匿名」的区别"></a>「闭包」和「匿名」的区别</h3><p>首先，虽然闭包和匿名在PHP中对应的都是一个东西，但是闭包和匿名并不等价。</p><p>匿名是指这个函数可以想变量一样操作，例如可以赋值给一个变量或者作为参数传递，作为函数的返回值等。</p><p>闭包则是指这个函数可以从上下文中捕获变量（不是通过传参获取），例如PHP使用use这个子句来完成这个操作；</p><p>实际上，闭包和匿名函数是伪装成函数的对象。他们是Closure类的实例。<br>闭包和字符串、整数一样，是一等值类型</p><a id="more"></a><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><blockquote><p>提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它.所以，在PHP中闭包（Closure）就是匿名函数;</p></blockquote><p>声明一个匿名函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$func = function()&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$message = function($name)</span><br><span class="line">&#123;</span><br><span class="line">    echo &apos;hello &apos;.$name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$message(&apos;world&apos;);</span><br><span class="line">//输出hello world</span><br></pre></td></tr></table></figure></p><blockquote><p>通常会把闭包当做函数的回调来使用</p><p>我们之所以能调用$message变量，是因为这个变量的值是一个闭包，而且闭包对象实现了<strong>invoke()魔术方法。只要变量名后有(),PHP就会查找并调用</strong>invoke()方法。</p></blockquote><p><code>array_map(), preg_replace_callback()</code>方法都会用到回调函数，这是使用闭包的最佳时机！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$numbersPlusOne = array_map(function ($number) &#123;</span><br><span class="line">    return $number + 1;</span><br><span class="line">&#125;, [1, 2, 3]);</span><br><span class="line">print_r($numbersPlusOne);</span><br><span class="line">//输出[2, 3, 4]</span><br></pre></td></tr></table></figure><h3 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。</span><br><span class="line">// 其中有一个方法用来计算购物车中所有商品的总价格。该方法使用了一个closure作为回调函数。</span><br><span class="line">class Cart</span><br><span class="line">&#123;</span><br><span class="line">    const PRICE_BUTTER  = 1.00;</span><br><span class="line">    const PRICE_MILK    = 3.00;</span><br><span class="line">    const PRICE_EGGS    = 6.95;</span><br><span class="line"></span><br><span class="line">    protected   $products = array();</span><br><span class="line"></span><br><span class="line">    public function add($product, $quantity)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;products[$product] = $quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getQuantity($product)</span><br><span class="line">    &#123;</span><br><span class="line">        return isset($this-&gt;products[$product]) ? $this-&gt;products[$product] :</span><br><span class="line">               FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getTotal($tax)</span><br><span class="line">    &#123;</span><br><span class="line">        $total = 0.00;</span><br><span class="line"></span><br><span class="line">        $callback =</span><br><span class="line">            function ($quantity, $product) use ($tax, &amp;$total)</span><br><span class="line">            &#123;</span><br><span class="line">                $pricePerItem = constant(__CLASS__ . &quot;::PRICE_&quot; .</span><br><span class="line">                    strtoupper($product));</span><br><span class="line">                $total += ($pricePerItem * $quantity) * ($tax + 1.0);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        array_walk($this-&gt;products, $callback);</span><br><span class="line">        return round($total, 2);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$my_cart = new Cart;</span><br><span class="line"></span><br><span class="line">// 往购物车里添加条目</span><br><span class="line">$my_cart-&gt;add(&apos;butter&apos;, 1);</span><br><span class="line">$my_cart-&gt;add(&apos;milk&apos;, 3);</span><br><span class="line">$my_cart-&gt;add(&apos;eggs&apos;, 6);</span><br><span class="line"></span><br><span class="line">// 打出出总价格，其中有 5% 的销售税.</span><br><span class="line">print $my_cart-&gt;getTotal(0.05) . &quot;\n&quot;;</span><br><span class="line">// The result is 54.29</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匿名函数不会自动从父作用域中继承变量，注意从父作用域继承变量和使用全局变量是不同的。</p><p>如果父作用域本身就是全局的 情况下就不存在从父作用域继承变量了，如果不是全局的话，想要使用父作用域中的变量，必须在声明匿名函数时候使用use换键字 来定义继承父作用域的变量。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包/匿名函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PhpStorm中使用PSR2编码规范phpcbf脚本自动修正代码格式</title>
      <link href="/2018/11/30/PhpStorm%E4%B8%AD%E4%BD%BF%E7%94%A8PSR2%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83phpcbf%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/2018/11/30/PhpStorm%E4%B8%AD%E4%BD%BF%E7%94%A8PSR2%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83phpcbf%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="安装CodeSniffer"><a href="#安装CodeSniffer" class="headerlink" title="安装CodeSniffer"></a>安装CodeSniffer</h2><h3 id="安装CodeSniffer-1"><a href="#安装CodeSniffer-1" class="headerlink" title="安装CodeSniffer"></a>安装CodeSniffer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install php-code-sniffer</span><br></pre></td></tr></table></figure><blockquote><p>安装完成后的路径:<code>/usr/local/Cellar/php-code-sniffer</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ☁  bin  pwd</span><br><span class="line">&gt; /usr/local/Cellar/php-code-sniffer/<span class="number">3.3</span><span class="number">.1</span>/bin</span><br><span class="line">&gt; ☁  bin  ls</span><br><span class="line">&gt; phpcbf           phpcs</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="配置phpcbf"><a href="#配置phpcbf" class="headerlink" title="配置phpcbf"></a>配置phpcbf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./phpcs --config-set default_standard PSR2</span><br><span class="line">./phpcbf --config-set default_standard PSR2</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;☁ bin ls</span><br><span class="line">&gt;CodeSniffer.conf phpcbf           phpcs</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="配置PhpStorm"><a href="#配置PhpStorm" class="headerlink" title="配置PhpStorm"></a>配置PhpStorm</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p>打开<code>PhpStorm</code>的设置页（<code>File-&gt;Setting</code>或者<code>Command+,</code>），到<code>Editor/Code Style</code>页<code>PHP</code>中选择风格为 <code>PSR1/2</code></p><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/md/1.jpg" alt=""></p></li><li><p>设置Code Sniffer</p><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/md/2.jpg" alt=""></p><p>选择之前phpcs的路径，填写后可以点击Validate按钮验证</p></li><li><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/md/3.jpg" alt=""></p></li></ol><p>现在使用<code>PhpStorm</code>的格式化，将会自动格式化成psr-2的风格</p><p><a href="https://qq52o.me/2460.html" target="_blank" rel="noopener">参考地址</a></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> PhpStorm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PhpStorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 密钥创建及密钥登录</title>
      <link href="/2018/11/30/SSH%20%E5%AF%86%E9%92%A5%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
      <url>/2018/11/30/SSH%20%E5%AF%86%E9%92%A5%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH-密钥创建及密钥登录"><a href="#SSH-密钥创建及密钥登录" class="headerlink" title="SSH 密钥创建及密钥登录"></a>SSH 密钥创建及密钥登录</h1><p>本文基本引自这里：<a href="https://blog.csdn.net/nahancy/article/details/79059135" target="_blank" rel="noopener">https://blog.csdn.net/nahancy/article/details/79059135</a></p><p>在我们平时使用Linux系统时候，通常使用的Linux SSH登录方式是用户名加密码的登录方式，今天来探讨另外的一种相对安全的登录方式——密钥登录</p><p>我们知道SSH登录是用的RSA非对称加密的，所以我们在SSH登录的时候就可以使用RSA密钥登录，SSH有专门创建SSH密钥的工具ssh-keygen，下面就来一睹风采。</p><p>首先进入Linux系统的用户目录下的.ssh目录下，root用户是/root/.ssh，普通用户是/home/您的用户名/.ssh，我们以root用户为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# cd /root/.ssh/</span><br><span class="line">[root@b04f945297ac .ssh]# ls</span><br><span class="line">known_hosts</span><br></pre></td></tr></table></figure><blockquote><p>上面是没有创建过ssh秘钥的样子</p></blockquote><p> 执行ssh-keygen命令创建密钥对：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# ssh-keygen -t rsa -b 4096</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/zhimma_id_rsa</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/zhimma_id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/zhimma_id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:WrIN4U/dk+1KdTxv0t5zFeXCeWWpvaNtFFMxbkDY2Cw root@b04f945297ac</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">|            Bo oo|</span><br><span class="line">|           E +o.*|</span><br><span class="line">|      .     ..o*+|</span><br><span class="line">|     . . . . +=*o|</span><br><span class="line">|      + S . + o+B|</span><br><span class="line">|       X     + *+|</span><br><span class="line">|      o o   . * *|</span><br><span class="line">|           . o Bo|</span><br><span class="line">|            . . =|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>-b 参数，指定了长度，也可以不加-b参数，直接使用ssh-keygen -t rsa</p><p>这里我重新命名了下秘钥文件名 zhimma_id_rsa</p></blockquote><p>密钥生成后会在当前目录下多出两个文件，zhimma_id_rsa和zhimma_id_rsa.pub，其中zhimma_id_rsa是私钥（敲黑板：这个很重要，不能外泄），zhimma_id_rsa.pub这个是公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# ls</span><br><span class="line">known_hosts  zhimma_id_rsa  zhimma_id_rsa.pub</span><br><span class="line">[root@b04f945297ac .ssh]#</span><br></pre></td></tr></table></figure><h2 id="放置公钥"><a href="#放置公钥" class="headerlink" title="放置公钥"></a>放置公钥</h2><h3 id="ssh-copy-id"><a href="#ssh-copy-id" class="headerlink" title="ssh-copy-id"></a>ssh-copy-id</h3><p>把公钥拷贝到需要登录的远程服务器或Linux系统上，这里可以使用<code>ssh-copy-id</code></p><blockquote><p>ssh-copy-id默认端口是22，如果要重新指定端口，则使用<code>-p 端口号</code>命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# ssh-copy-id -i /root/.ssh/zhimma_id_rsa.pub -p 203 root@192.168.2.107  </span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/zhimma_id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.2.107&apos;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh -p &apos;203&apos; &apos;root@192.168.2.107&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p>这样就把公钥加的指定的服务器上了</p><p>尝试登陆下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# ssh -i /root/.ssh/zhimma_id_rsa -p 203 root@192.168.2.107</span><br><span class="line">Last login: Wed Jun  6 04:16:09 2018 from 172.17.0.1</span><br><span class="line">[root@e91b4a662023 ~]#</span><br></pre></td></tr></table></figure><p>登陆成功！</p><h3 id="手动放置"><a href="#手动放置" class="headerlink" title="手动放置"></a>手动放置</h3><p>进入远程服务器.ssh目录，创建authorized_keys 文件，赋权限600</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@01bb4850cc8c .ssh]# touch authorized_keys</span><br><span class="line">[root@01bb4850cc8c .ssh]# chmod -R 600 authorized_keys </span><br><span class="line">[root@01bb4850cc8c .ssh]# ls -al</span><br><span class="line">total 16</span><br><span class="line">drwx------ 1 root root 4096 Jun  6 07:02 .</span><br><span class="line">dr-xr-x--- 1 root root 4096 Apr 27 08:15 ..</span><br><span class="line">-rw------- 1 root root    0 Jun  6 07:02 authorized_keys</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jun  6 07:02 dd</span><br><span class="line">-rw-r--r-- 1 root root  824 Mar 16 08:59 known_hosts</span><br></pre></td></tr></table></figure><p>复制<code>zhimma_id_rsa.pub</code>的内容进入这个文件</p><p>尝试登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac .ssh]# ssh -i /root/.ssh/zhimma_id_rsa -p 204 root@192.168.2.107</span><br><span class="line">Last login: Wed Jun  6 04:18:46 2018 from 172.17.0.1</span><br><span class="line">[root@01bb4850cc8c ~]#</span><br></pre></td></tr></table></figure><p>登陆成功！</p><h2 id="ssh-keygen可用的参数"><a href="#ssh-keygen可用的参数" class="headerlink" title="ssh-keygen可用的参数"></a>ssh-keygen可用的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen可用的参数选项有：</span><br><span class="line">     -a trials  在使用 -T 对 DH-GEX 候选素数进行安全筛选时需要执行的基本测试数量。</span><br><span class="line">     -B      显示指定的公钥/私钥文件的 bubblebabble 摘要。</span><br><span class="line">     -b bits 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</span><br><span class="line">     -C comment 提供一个新注释</span><br><span class="line">     -c      要求修改私钥和公钥文件中的注释。本选项只支持 RSA1 密钥。</span><br><span class="line">             程序将提示输入私钥文件名、密语(如果存在)、新注释。</span><br><span class="line">     -D reader下载存储在智能卡 reader 里的 RSA 公钥。</span><br><span class="line"></span><br><span class="line">     -e      </span><br><span class="line">         读取OpenSSH的私钥或公钥文件，并以 RFC 4716 SSH 公钥文件格式在 stdout 上显示出来。</span><br><span class="line">              该选项能够为多种商业版本的 SSH 输出密钥。</span><br><span class="line">     -F hostname</span><br><span class="line">             在 known_hosts 文件中搜索指定的 hostname ，并列出所有的匹配项。</span><br><span class="line">             这个选项主要用于查找散列过的主机名/ip地址，还可以和 -H 选项联用打印找到的公钥的散列值。</span><br><span class="line">     -f filename</span><br><span class="line">             指定密钥文件名。</span><br><span class="line">     -G output_file</span><br><span class="line">             为 DH-GEX 产生候选素数。这些素数必须在使用之前使用 -T 选项进行安全筛选。</span><br><span class="line">     -g      在使用 -r 打印指纹资源记录的时候使用通用的 DNS 格式。</span><br><span class="line">     -H      对 known_hosts 文件进行散列计算。这将把文件中的所有主机名/ip地址替换为相应的散列值。</span><br><span class="line">             原来文件的内容将会添加一个&quot;.old&quot;后缀后保存。这些散列值只能被 ssh 和 sshd 使用。</span><br><span class="line">             这个选项不会修改已经经过散列的主机名/ip地址，因此可以在部分公钥已经散列过的文件上安全使用。</span><br><span class="line">     -i      读取未加密的SSH-2兼容的私钥/公钥文件，然后在 stdout 显示OpenSSH兼容的私钥/公钥。</span><br><span class="line">             该选项主要用于从多种商业版本的SSH中导入密钥。</span><br><span class="line">     -l      显示公钥文件的指纹数据。它也支持 RSA1 的私钥。</span><br><span class="line">             对于RSA和DSA密钥，将会寻找对应的公钥文件，然后显示其指纹数据。</span><br><span class="line">     -M memory</span><br><span class="line">             指定在生成 DH-GEXS 候选素数的时候最大内存用量(MB)。</span><br><span class="line"></span><br><span class="line">     -N new_passphrase</span><br><span class="line">             提供一个新的密语。</span><br><span class="line"></span><br><span class="line">     -P passphrase</span><br><span class="line">             提供(旧)密语。</span><br><span class="line">     -p      要求改变某私钥文件的密语而不重建私钥。程序将提示输入私钥文件名、原来的密语、以及两次输入新密语。</span><br><span class="line">     -q      安静模式。用于在 /etc/rc 中创建新密钥的时候。</span><br><span class="line">     -R hostname</span><br><span class="line">             从 known_hosts 文件中删除所有属于 hostname 的密钥。</span><br><span class="line">             这个选项主要用于删除经过散列的主机(参见 -H 选项)的密钥。</span><br><span class="line">     -r hostname</span><br><span class="line">             打印名为 hostname 的公钥文件的 SSHFP 指纹资源记录。</span><br><span class="line">     -S start</span><br><span class="line">             指定在生成 DH-GEX 候选模数时的起始点(16进制)。</span><br><span class="line">     -T output_file</span><br><span class="line">             测试 Diffie-Hellman group exchange 候选素数(由 -G 选项生成)的安全性。</span><br><span class="line">     -t type</span><br><span class="line">             指定要创建的密钥类型。可以使用：&quot;rsa1&quot;(SSH-1) &quot;rsa&quot;(SSH-2) &quot;dsa&quot;(SSH-2)</span><br><span class="line">     -U reader</span><br><span class="line">             把现存的RSA私钥上传到智能卡 reader</span><br><span class="line">     -v      详细模式。ssh-keygen 将会输出处理过程的详细调试信息。常用于调试模数的产生过程。</span><br><span class="line">             重复使用多个 -v 选项将会增加信息的详细程度(最大3次)。</span><br><span class="line">     -W generator</span><br><span class="line">             指定在为 DH-GEX 测试候选模数时想要使用的 generator</span><br><span class="line">     -y      读取OpenSSH专有格式的公钥文件，并将OpenSSH公钥显示在 stdout 上。</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PhpStrom中安装CodeSniffer</title>
      <link href="/2018/11/30/PhpStrom%E4%B8%AD%E5%AE%89%E8%A3%85CodeSniffer/"/>
      <url>/2018/11/30/PhpStrom%E4%B8%AD%E5%AE%89%E8%A3%85CodeSniffer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>环境 ： windows10</p><p>本地开发环境 ：phpStudy</p><p>Phpstrom版本：Phpstrom 2017.1<br><a id="more"></a></p></blockquote><h2 id="Phpstrom"><a href="#Phpstrom" class="headerlink" title="Phpstrom"></a>Phpstrom</h2><hr><p>Phpstorm是JetBrains 公司开发的跨平台的PHP IDE。在用Phpstorm编辑PHP，HTML和JavaScript的代码时，Phpstorm提供实施代码分析，错误提示和自动格式化等功能。支持的PHP版本包括5.3, 5.4, 5.5, 5.6 和 7.0。一款便携又强大的IDE，很多功能能够帮助你更好的进行开发。</p><h2 id="PHP-CodeSniffer"><a href="#PHP-CodeSniffer" class="headerlink" title="PHP CodeSniffer"></a>PHP CodeSniffer</h2><hr><p>PHP CodeSniffer是PEAR中的一个用PHP5写的一个PHP的代码风格检测器，它根据预先设定好的PHP编码风格和规则，去检查应用中的代码风格情况是否有违反一组预先设置好的编码标准，内置了ZEND，PEAR的编码风格规则，当然也支持自己定制。PHP CodeSniffer 是确保代码简洁一致的必不可少的开发工具，甚至还可以帮助程序员减少一些语义错误。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr><h3 id="PHP扩展安装"><a href="#PHP扩展安装" class="headerlink" title="PHP扩展安装"></a>PHP扩展安装</h3><ol><li>下载<a href="http://pear.php.net/go-pear.phar" target="_blank" rel="noopener">PEAR</a>文件</li><li>切换到PHP软件目录，运行<code>php go-pear.phar</code></li><li>按照提示指令输入，完成安装</li><li>装PHP Code Sniffer<code>pear install PHP_CodeSniffer</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">E:\phpStudy\php\php-5.6.27-nts&gt;php go-pear.phar</span><br><span class="line"></span><br><span class="line">Are you installing a system-wide PEAR or a local copy?</span><br><span class="line">(system|local) [system] :</span><br><span class="line"></span><br><span class="line">Below is a suggested file layout for your new PEAR installation.  To</span><br><span class="line">change individual locations, type the number in front of the</span><br><span class="line">directory.  Type &apos;all&apos; to change all of them or simply press Enter to</span><br><span class="line">accept these locations.</span><br><span class="line"></span><br><span class="line"> 1. Installation base ($prefix)                   : E:\phpStudy\php\php-5.6.27-nts</span><br><span class="line"> 2. Temporary directory for processing            : E:\phpStudy\php\php-5.6.27-nts\tmp</span><br><span class="line"> 3. Temporary directory for downloads             : E:\phpStudy\php\php-5.6.27-nts\tmp</span><br><span class="line"> 4. Binaries directory                            : E:\phpStudy\php\php-5.6.27-nts</span><br><span class="line"> 5. PHP code directory ($php_dir)                 : E:\phpStudy\php\php-5.6.27-nts\pear</span><br><span class="line"> 6. Documentation directory                       : E:\phpStudy\php\php-5.6.27-nts\docs</span><br><span class="line"> 7. Data directory                                : E:\phpStudy\php\php-5.6.27-nts\data</span><br><span class="line"> 8. User-modifiable configuration files directory : E:\phpStudy\php\php-5.6.27-nts\cfg</span><br><span class="line"> 9. Public Web Files directory                    : E:\phpStudy\php\php-5.6.27-nts\www</span><br><span class="line">10. System manual pages directory                 : E:\phpStudy\php\php-5.6.27-nts\man</span><br><span class="line">11. Tests directory                               : E:\phpStudy\php\php-5.6.27-nts\tests</span><br><span class="line">12. Name of configuration file                    : C:\Windows\pear.ini</span><br><span class="line">13. Path to CLI php.exe                           : E:\phpStudy\php\php-5.6.27-nts</span><br><span class="line"></span><br><span class="line">1-13, &apos;all&apos; or Enter to continue:</span><br><span class="line">Beginning install...</span><br><span class="line">Configuration written to C:\Windows\pear.ini...</span><br><span class="line">Initialized registry...</span><br><span class="line">Preparing to install...</span><br><span class="line">installing phar://E:/phpStudy/php/php-5.6.27-nts/go-pear.phar/PEAR/go-pear-tarballs/Archive_Tar-1.4.2.tar...</span><br><span class="line">installing phar://E:/phpStudy/php/php-5.6.27-nts/go-pear.phar/PEAR/go-pear-tarballs/Console_Getopt-1.4.1.tar...</span><br><span class="line">installing phar://E:/phpStudy/php/php-5.6.27-nts/go-pear.phar/PEAR/go-pear-tarballs/PEAR-1.10.3.tar...</span><br><span class="line">installing phar://E:/phpStudy/php/php-5.6.27-nts/go-pear.phar/PEAR/go-pear-tarballs/Structures_Graph-1.1.1.tar...</span><br><span class="line">installing phar://E:/phpStudy/php/php-5.6.27-nts/go-pear.phar/PEAR/go-pear-tarballs/XML_Util-1.4.2.tar...</span><br><span class="line">install ok: channel://pear.php.net/Archive_Tar-1.4.2</span><br><span class="line">install ok: channel://pear.php.net/Console_Getopt-1.4.1</span><br><span class="line">install ok: channel://pear.php.net/Structures_Graph-1.1.1</span><br><span class="line">install ok: channel://pear.php.net/XML_Util-1.4.2</span><br><span class="line">install ok: channel://pear.php.net/PEAR-1.10.3</span><br><span class="line">PEAR: Optional feature webinstaller available (PEAR&apos;s web-based installer)</span><br><span class="line">PEAR: Optional feature gtkinstaller available (PEAR&apos;s PHP-GTK-based installer)</span><br><span class="line">PEAR: Optional feature gtk2installer available (PEAR&apos;s PHP-GTK2-based installer)</span><br><span class="line">PEAR: To install optional features use &quot;pear install pear/PEAR#featurename&quot;</span><br><span class="line"></span><br><span class="line">** WARNING! Old version found at E:\phpStudy\php\php-5.6.27-nts, please remove it or be sure to use the new e:\phpstudy\php\php-5.6.27-nts\pear.bat command</span><br><span class="line"></span><br><span class="line">The &apos;pear&apos; command is now at your service at e:\phpstudy\php\php-5.6.27-nts\pear.bat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* WINDOWS ENVIRONMENT VARIABLES *</span><br><span class="line">For convenience, a REG file is available under E:\phpStudy\php\php-5.6.27-ntsPEAR_ENV.reg .</span><br><span class="line">This file creates ENV variables for the current user.</span><br><span class="line"></span><br><span class="line">Double-click this file to add it to the current user registry.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E:\phpStudy\php\php-5.6.27-nts&gt;pear install PHP_CodeSniffer</span><br><span class="line">WARNING: channel &quot;pear.php.net&quot; has updated its protocols, use &quot;pear channel-update pear.php.net&quot; to update</span><br><span class="line">downloading PHP_CodeSniffer-2.8.1.tgz ...</span><br><span class="line">Starting to download PHP_CodeSniffer-2.8.1.tgz (522,712 bytes)</span><br><span class="line">.........................................................................................................done: 522,712 bytes</span><br><span class="line">install ok: channel://pear.php.net/PHP_CodeSniffer-2.8.1</span><br></pre></td></tr></table></figure><h3 id="Phpstrom配置"><a href="#Phpstrom配置" class="headerlink" title="Phpstrom配置"></a>Phpstrom配置</h3><ol><li>下载对应的标准到Standard（<code>E:\phpStudy\php\php-5.6.27-nts\pear\PHP\CodeSniffer\Standards</code>）目录下面<blockquote><p>这里我省略了这一步</p></blockquote></li><li>打开Phpstrom设置,依次打开<code>Setting-&gt;Languages and Frameworks-&gt;PHP-&gt;Code Sniffer</code>，按照下图操作<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/4.png" alt="image"></li><li>Standard配置，按照下图操作<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/5.png" alt="image"></li><li>最好保存即可预览效果</li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> PhpStorm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PhpStorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-FPM如何合理设置max_chindren和pm模式，包括开启status监听</title>
      <link href="/2018/11/30/php-fpm%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AEmax_chindren%E5%92%8Cpm%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%BC%80%E5%90%AFstatus%E7%9B%91%E5%90%AC/"/>
      <url>/2018/11/30/php-fpm%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AEmax_chindren%E5%92%8Cpm%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%BC%80%E5%90%AFstatus%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="php-fpm如何合理设置max-chindren和pm模式，包括开启status监听"><a href="#php-fpm如何合理设置max-chindren和pm模式，包括开启status监听" class="headerlink" title="php-fpm如何合理设置max_chindren和pm模式，包括开启status监听"></a>php-fpm如何合理设置max_chindren和pm模式，包括开启status监听</h2><h3 id="开启status获得执行状态"><a href="#开启status获得执行状态" class="headerlink" title="开启status获得执行状态"></a>开启status获得执行状态</h3><h4 id="启用php-fpm状态功能"><a href="#启用php-fpm状态功能" class="headerlink" title="启用php-fpm状态功能"></a>启用php-fpm状态功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/php-fpm.d/www.conf</span><br><span class="line">修改：</span><br><span class="line">pm.status_path = /status</span><br></pre></td></tr></table></figure><h4 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ ^/status$</span></span><br><span class="line"><span class="regexp"></span>    &#123;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重启nginx和php-fpm"><a href="#重启nginx和php-fpm" class="headerlink" title="重启nginx和php-fpm"></a>重启nginx和php-fpm</h4><h4 id="打开status页面"><a href="#打开status页面" class="headerlink" title="打开status页面"></a>打开status页面</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac ~]<span class="comment"># curl http://visit.ma/status</span></span><br><span class="line">pool:                 www</span><br><span class="line">process manager:      dynamic</span><br><span class="line">start time:           <span class="number">23</span>/Jul/<span class="number">2018</span>:<span class="number">15</span>:<span class="number">32</span>:<span class="number">09</span> +<span class="number">0800</span></span><br><span class="line">start since:          <span class="number">1055</span></span><br><span class="line">accepted conn:        <span class="number">9</span></span><br><span class="line">listen queue:         <span class="number">0</span></span><br><span class="line">max listen queue:     <span class="number">0</span></span><br><span class="line">listen queue len:     <span class="number">128</span></span><br><span class="line">idle processes:       <span class="number">5</span></span><br><span class="line">active processes:     <span class="number">1</span></span><br><span class="line">total processes:      <span class="number">6</span></span><br><span class="line">max active processes: <span class="number">1</span></span><br><span class="line">max children reached: <span class="number">0</span></span><br><span class="line">slow requests:        <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><p><strong>pool</strong> – fpm池子名称，大多数为www<br><strong>process manager</strong> – 进程管理方式,值：static, dynamic or ondemand. dynamic<br><strong>start time</strong> – 启动日期,如果reload了php-fpm，时间会更新<br><strong>start since</strong> – 运行时长<br><strong>accepted conn</strong> – 当前池子接受的请求数<br><strong>listen queue</strong> – 请求等待队列，如果这个值不为0，那么要增加FPM的进程数量<br><strong>max listen queue</strong> – 请求等待队列最高的数量<br><strong>listen queue len</strong> – socket等待队列长度<br><strong>idle processes</strong> – 空闲进程数量<br><strong>active processes</strong> – 活跃进程数量<br>total processes – 总进程数量<br><strong>max active processes</strong> – 最大的活跃进程数量（FPM启动开始算）<br><strong>max children reached</strong>  - 大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。<br><strong>slow requests</strong> – 启用了php-fpm slow-log，缓慢请求的数量</p><h4 id="php-fpm其他参数"><a href="#php-fpm其他参数" class="headerlink" title="php-fpm其他参数"></a>php-fpm其他参数</h4><p><strong>php-fpm</strong>状态页比较个性化的一个地方是它可以带参数，可以带参数<strong>json</strong>、<strong>xml</strong>、<strong>html</strong>并且前面三个参数可以分别和<strong>full</strong>做一个组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">curl http://visit.ma/status?json</span><br><span class="line">curl http://visit.ma/status?xml</span><br><span class="line">curl http://visit.ma/status?html</span><br><span class="line">curl http://visit.ma/status?full</span><br><span class="line"></span><br><span class="line">[root@b04f945297ac ~]# curl http://visit.ma/status?full</span><br><span class="line">pool:                 www</span><br><span class="line">process manager:      dynamic</span><br><span class="line">start time:           23/Jul/2018:15:32:09 +0800</span><br><span class="line">start since:          1240</span><br><span class="line">accepted conn:        10</span><br><span class="line">listen queue:         0</span><br><span class="line">max listen queue:     0</span><br><span class="line">listen queue len:     128</span><br><span class="line">idle processes:       5</span><br><span class="line">active processes:     1</span><br><span class="line">total processes:      6</span><br><span class="line">max active processes: 1</span><br><span class="line">max children reached: 0</span><br><span class="line">slow requests:        0</span><br><span class="line"></span><br><span class="line">************************</span><br><span class="line">pid:                  5466</span><br><span class="line">state:                Idle</span><br><span class="line">start time:           23/Jul/2018:15:32:09 +0800</span><br><span class="line">start since:          1240</span><br><span class="line">requests:             2</span><br><span class="line">request duration:     99</span><br><span class="line">request method:       GET</span><br><span class="line">request URI:          /status</span><br><span class="line">content length:       0</span><br><span class="line">user:                 -</span><br><span class="line">script:               -</span><br><span class="line">last request cpu:     0.00</span><br><span class="line">last request memory:  2097152</span><br><span class="line">************************</span><br><span class="line">pid:                  5467</span><br><span class="line">state:                Idle</span><br><span class="line">start time:           23/Jul/2018:15:32:09 +0800</span><br><span class="line">start since:          1240</span><br><span class="line">requests:             2</span><br><span class="line">request duration:     184</span><br><span class="line">request method:       GET</span><br><span class="line">request URI:          /status?full</span><br><span class="line">content length:       0</span><br><span class="line">user:                 -</span><br><span class="line">script:               -</span><br><span class="line">last request cpu:     0.00</span><br><span class="line">last request memory:  2097152</span><br></pre></td></tr></table></figure><p>这里重点说下<strong>full</strong>参数详解</p><p><strong>pid</strong> – 进程PID，可以单独kill这个进程. You can use this PID to kill a long running process.<br><strong>state</strong> – 当前进程的状态 (Idle, Running, …)<br><strong>start time</strong> – 进程启动的日期<br><strong>start since</strong> – 当前进程运行时长<br><strong>requests</strong> – 当前进程处理了多少个请求<br><strong>request duration</strong> – 请求时长（微妙）<br>request method – 请求方法 (GET, POST, …)<br><strong>request URI</strong> – 请求URI<br><strong>content length</strong> – 请求内容长度 (仅用于 POST)<br><strong>user</strong> – 用户 (PHP_AUTH_USER) (or ‘-’ 如果没设置)<br><strong>script</strong> – PHP脚本 (or ‘-’ if not set)<br><strong>last request cpu</strong> – 最后一个请求CPU使用率<br><strong>last request memorythe</strong> - 上一个请求使用的内存</p><h3 id="合理设置max-chindren和pm模式"><a href="#合理设置max-chindren和pm模式" class="headerlink" title="合理设置max_chindren和pm模式"></a>合理设置max_chindren和pm模式</h3><p><img src="https://learn-plan.oss-cn-beijing.aliyuncs.com/Nginx%2BPHP/htop.png" alt="htop"></p><p>使用htop命令查看单个php-fpm所申请的VIRT大小，我32G服务器是400左右（实际要除以8=M，就是：50M左右），如果按照每个进程消耗50M*1.5倍=75M左右，如果你的服务器内存是32G，我们假设可用于php-fpm的内存为60%=20G，则：20*1024/75=273，所以，一般我们建议max_chindren最大为273，最好还是设置为：8的倍数，所以我设置为256.</p><p>然后我们可以根据域名/status的结果来合理设置其他参数（<strong>pm.start_servers</strong>和<strong>pm.min_spare_servers</strong>和<strong>pm.max_spare_servers</strong>）</p><p>在php.ini中，我们可以看到<strong>memory_limit</strong>有一句这样的原文，<code>Maximum amount of memory a script may consume (128MB)</code>，就是说单个进程使用的最大内存大小，这个参数吧，当然不能低于刚刚计算的75M了，一般我们可以设置为3倍，则75*3=225M左右（建议：128，256，512，1024…）</p><p>这里假如有攻击的话，max_chindren=256，memory_limit=256，256*256=64G，很明显会导致内存爆满，所以如果想又保持性能，又能一定程度上防止内存爆满，可以将max_chindren设置的低一点，memory_limit可以设置为每个进程消耗的值（一般不建议低于128M吧，如果是独立服务器的话）。</p><h4 id="PHP-FPM-子进程数量，是不是越多越好？"><a href="#PHP-FPM-子进程数量，是不是越多越好？" class="headerlink" title="PHP-FPM 子进程数量，是不是越多越好？"></a>PHP-FPM 子进程数量，是不是越多越好？</h4><p>当然不是，pm.max_chindren，进程多了，增加进程管理的开销以及上下文切换的开销。</p><p>更核心的是，<strong>能并发执行的 php-fpm 进程不会超过 cpu 个数</strong>。</p><p>如何设置，取决于你的代码</p><p>如果代码是 CPU 计算密集型的，pm.max_chindren 不能超过 CPU 的内核数。</p><p>如果不是，那么将 pm.max_chindren 的值大于 CPU 的内核数，是非常明智的。<br>国外技术大拿给出这么个公式：</p><p>在 N + 20% 和 M/m 之间。</p><p>N 是 CPU 内核数量。<br>M 是 PHP 能利用的内存数量。<br>m 是每个 PHP 进程平均使用的内存数量。<br>适用于 <strong>dynamic</strong> 方式。</p><p><strong>static方式：M/(m * 1.2)</strong></p><p>当然，还有一种保险的方式，来配置 max_children。适用于 static 方式。</p><p>先把 max_childnren 设置成一个比较大的值。<br>稳定运行一段时间后，观察 php-fpm 的 status 里的 max<br>active processes 是多少<br>然后把 max_children 配置比它大一些就可以了。<br>pm.max_requests：指的是每个子进程在处理了多少个请求数量之后就重启。</p><p>这个参数，理论上可以随便设置，但是为了预防内存泄漏的风险，还是设置一个合理的数比较好</p><p>所以，我的服务器32G内存设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory_limit = 256M</span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = 256</span><br><span class="line">pm.start_servers = 32</span><br><span class="line">pm.min_spare_servers = 16</span><br><span class="line">pm.max_spare_servers = 32</span><br></pre></td></tr></table></figure><blockquote><p> pm.max_children：静态方式下开启的php-fpm进程数量。</p><p>pm.start_servers：动态方式下的起始php-fpm进程数量。</p><p>pm.min_spare_servers：动态方式下的最小php-fpm进程数量。</p><p>pm.max_spare_servers：动态方式下的最大php-fpm进程数量。</p><p><strong>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置数量的php-fpm进程。</strong></p><p><strong>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置数量的php-fpm进程。</strong></p></blockquote><p><a href="http://www.zhanghongliang.com/article/1300" target="_blank" rel="noopener">http://www.zhanghongliang.com/article/1300</a></p><p><a href="http://www.ttlsa.com/php/use-php-fpm-status-page-detail/" target="_blank" rel="noopener">http://www.ttlsa.com/php/use-php-fpm-status-page-detail/</a></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> PHP-FPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中按照姓名或者中文首字母区间查询排序</title>
      <link href="/2018/11/30/mysql%E4%B8%AD%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E6%88%96%E8%80%85%E4%B8%AD%E6%96%87%E9%A6%96%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/11/30/mysql%E4%B8%AD%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E6%88%96%E8%80%85%E4%B8%AD%E6%96%87%E9%A6%96%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>英文26个字母中除了i,u,v三个字母不能成为汉语拼音的首字母外,其它的字母都可以。<br>先上一个表格,说明下各个字母字母的拼音编码的开始值和结束值</p><a id="more"></a><table><thead><tr><th style="text-align:center">字母</th><th style="text-align:center">起值</th><th style="text-align:center">止值</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">45217</td><td style="text-align:center">45252</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">45253</td><td style="text-align:center">45760</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">45761</td><td style="text-align:center">46317</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">46318</td><td style="text-align:center">46825</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">46826</td><td style="text-align:center">47009</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">47010</td><td style="text-align:center">47296</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">47297</td><td style="text-align:center">47613</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">47614</td><td style="text-align:center">48118</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">48119</td><td style="text-align:center">49061</td></tr><tr><td style="text-align:center">K</td><td style="text-align:center">49062</td><td style="text-align:center">49323</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">49324</td><td style="text-align:center">49895</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">49896</td><td style="text-align:center">50370</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">50371</td><td style="text-align:center">50613</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">50614</td><td style="text-align:center">50621</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">50622</td><td style="text-align:center">50905</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">50906</td><td style="text-align:center">51386</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">51387</td><td style="text-align:center">51445</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">51446</td><td style="text-align:center">52217</td></tr><tr><td style="text-align:center">T</td><td style="text-align:center">52218</td><td style="text-align:center">52697</td></tr><tr><td style="text-align:center">W</td><td style="text-align:center">52698</td><td style="text-align:center">52979</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">52980</td><td style="text-align:center">53688</td></tr><tr><td style="text-align:center">Y</td><td style="text-align:center">53689</td><td style="text-align:center">54480</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">54481</td><td style="text-align:center">55289</td></tr></tbody></table><p>用途：<br>假如需要查询数据库中 以A-G字母开头的省,并且按照字母顺序排序：<br>数据库中数据<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/database/sql1.jpg" alt="数据库中数据"></p><p>需要的结果</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/database/sql2.jpg" alt="需要的结果"></p><p>类似这种结构或者这种数据排序,我们直接可以执行下面的sql语句查询</p><p><code>select * from wr_province where CONV(HEX(left(CONVERT(province_name USING gbk),1)),16,10) between 45217 and 47613 ORDER BY convert(province_name USING gbk) asc;</code></p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/database/sql3.jpg" alt="sql结果"></p><p>下面有一个我在自己项目中使用的例子,用的是循环查询,大家可以看看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$sort = array(</span><br><span class="line">    &apos;A-G&apos; =&gt; array(&apos;45217&apos;, &apos;47613&apos;),</span><br><span class="line">    &apos;H-K&apos; =&gt; array(&apos;47614&apos;, &apos;49323&apos;),</span><br><span class="line">    &apos;L-S&apos; =&gt; array(&apos;49324&apos;, &apos;52217&apos;),</span><br><span class="line">    &apos;T-Z&apos; =&gt; array(&apos;52218&apos;, &apos;55289&apos;)</span><br><span class="line">);</span><br><span class="line">$model = D(&apos;Province&apos;);</span><br><span class="line">$array = array();</span><br><span class="line">foreach ($sort as $key =&gt; $value)&#123;</span><br><span class="line">    $sql = &quot;select * from wr_province where CONV(HEX(left(CONVERT(province_name USING gbk),1)),16,10) between &#123;$value[0]&#125; and &#123;$value[1]&#125; ORDER BY convert(province_name USING gbk) asc&quot;;</span><br><span class="line">    $data = $model-&gt;query($sql);</span><br><span class="line">    foreach ($data as $value)&#123;</span><br><span class="line">        $array[$key][] = array(&apos;code&apos;=&gt;$value[&apos;province_id&apos;],&apos;address&apos;=&gt;$value[&apos;province_name&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">debug(json_encode($array));</span><br><span class="line">//结果：</span><br></pre></td></tr></table></figure><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/database/sql4.png" alt="sql结果"></p><p>满足需求;</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sea.js中加载layer，缺少css文件解决</title>
      <link href="/2018/11/30/sea.js%E4%B8%AD%E5%8A%A0%E8%BD%BDlayer%EF%BC%8C%E7%BC%BA%E5%B0%91css%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/11/30/sea.js%E4%B8%AD%E5%8A%A0%E8%BD%BDlayer%EF%BC%8C%E7%BC%BA%E5%B0%91css%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>今天做项目时遇到了一个问题，看下图<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/layer1.jpg" alt="缺少css之后"><br>页面错乱，询问前端工程师后，定位问题应该是缺少layer.css导致的，这就很奇怪了，之前的项目使用layer的时候，也只是单单的引入jquery和layer.min.js<br>为什么现在这个新项目就不行了呢？</p><p>答案就是：新项目使用sea.js进行js文件加载，可能内部的路径问题导致layer.js无法加载到自己的css文件，在网上查找一番之后，给出如下解决办法：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">manage.js 使用的js文件</span><br><span class="line"></span><br><span class="line">define(function (require) &#123;</span><br><span class="line">   var layer = require(&apos;layer&apos;);</span><br><span class="line">   var paths = JSON.parse(PATH_INFO);</span><br><span class="line">   layer.config(&#123;</span><br><span class="line">    path: paths.remote_asset+&apos;/Common/Manage/plugins/layer/&apos; //layer.js所在的目录，可以是绝对目录，也可以是相对目录</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>手动配置layer的路径，可以是绝对路径也可以是相对路径，只要能找得到layer的文件夹</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">config.js sea.js配置文件</span><br><span class="line"></span><br><span class="line">alias: &#123;</span><br><span class="line">            jquery: &apos;remote_asset/Manage/js/jquery.min.js&apos;,</span><br><span class="line">            bootstrap: &apos;remote_asset/Manage/plugins/bootstrap-3.3.5/js/bootstrap.min.js&apos;,</span><br><span class="line">            layer: &apos;remote_asset/Manage/plugins/layer/layer.min.js&apos;,</span><br><span class="line">            validate: &apos;remote_asset/Manage/plugins/jquery-validation-1.13.1/jquery.validate.min.js&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">        preload: [</span><br><span class="line">            &apos;jquery&apos;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><p>就这样，重新配置layer,让它自己能找到css文件并且加载，看看修改后的效果吧：<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/layer2.jpg" alt="缺少css之后"></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seajs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装与配置</title>
      <link href="/2018/11/30/redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/30/redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="redis安装与配置"><a href="#redis安装与配置" class="headerlink" title="redis安装与配置"></a>redis安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><a href="https://redis.io/download" target="_blank" rel="noopener">redis下载地址</a></p></li><li><p>解压缩<code>tar -zxf redis-4.0.2.tar.gz</code></p></li><li><p><code>cd redis-4.0.2</code></p></li><li><p><code>make</code></p></li><li><p><code>cd src</code></p></li><li><p><code>make install</code></p><p>​</p></li></ul><p>到此就安装完成。但是，由于安装redis的时候，我们没有选择安装路径，故是默认位置安装。在此，我们可以将可执行文件和配置文件移动到习惯的目录。 </p><figure class="highlight plain"><figcaption><span>/usr/local </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/redis/bin </span><br><span class="line">mkdir -p /usr/local/redis/etc </span><br><span class="line">cd /usr/local/redis-4.0.2 </span><br><span class="line">mv ./redis.conf /usr/local/redis/etc </span><br><span class="line">cd src </span><br><span class="line">mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server redis-sentinel /usr/local/redis/bin</span><br></pre></td></tr></table></figure><p><strong>比较重要的3个可执行文件</strong>：<br><strong>redis-server</strong>：Redis服务器程序<br><strong>redis-cli</strong>：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。<br><strong>redis-benchmark</strong>：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能</p><p><strong>Redis的启动命令：</strong><br><code>/usr/local/redis/bin/redis-server</code><br>或<br><code>cd /usr/local/redis/bin</code><br><code>./redis-server /usr/local/redis/etc/redis.conf</code>为redis-server指定配置文件</p><h3 id="Redis的配置"><a href="#Redis的配置" class="headerlink" title="Redis的配置"></a>Redis的配置</h3><p>下面列举了Redis中的一些常用配置项：<br>daemonize 如果需要将Redis服务以守护进程在后台运行，则把该项的值改为yes</p><p>pidfile 配置多个pid的地址，默认在/var/run/redis/pid</p><p>bind 绑定ip，设置后只接受来自该ip的请求</p><p>port 监听端口，默认是6379</p><p>timeout 客户端连接超时的设定，单位是秒</p><p>loglevel 分为4级，debug、verbose、notice、warning</p><p>logfile 配置log文件地址</p><p>databases 设置数据库的个数，默认使用的数据库为0</p><p>save 设置redis进行数据库镜像的频率</p><p>rdbcompression 在进行镜像备份时，是否进行压缩</p><p>Dbfilename 镜像备份文件的文件名</p><p>Dir 数据库镜像备份文件的存放路径</p><p>Slaveof 设置数据库为其他数据库的从数据库</p><p>Masterauth 主数据库连接需要的密码验证<br>Requirepass 设置登录时，需要使用的密码<br>Maxclients 设置同时连接的最大客户端数量<br>Maxmemory 设置redis能够使用的最大内存<br>Appendonly 开启append only模式<br>Appendfsync 设置对appendonly.aof文件同步的频率<br>vm-enabled 是否开启虚拟内存支持<br>vm-swap-file 设置虚拟内存的交换文件路径<br>vm-max-memory 设置redis能够使用的最大虚拟内存<br>vm-page-size 设置虚拟内存的页大小<br>vm-pages 设置交换文件的总的page数量<br>vm-max-threads 设置VMIO同时使用的线程数量<br>Glueoutputbuf 把小的输出缓存存放在一起<br>hash-max-zipmap-entries 设置hash的临界值<br>Activerehashing 重新hash</p><p><strong>修改redis的配置参数</strong>：<br>vi /usr/local/redis/etc/redis.conf<br>将daemonize no改为daemonize yes，保存退出。<br>再来启动redis服务器<br>cd /usr/local/redis/bin<br>./redis-server /usr/local/redis/etc/redis.conf 启动redis并指定配置文件</p><p>ps aux | grep redis 查看redis是否启动成功</p><p>netstat -tlun 查看主机的6379端口是否在使用（监听）</p><p>./redis-cli 打开redis的客户端</p><p>quit 退出redis的客户端</p><p>pkill redis-server 关闭redis服务器</p><p>./redis-cli shutdown 也可以通过这条命令关闭redis服务器</p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><p>只有两个步骤：</p><ol><li><p>设置redis.conf中<code>daemonize</code>为<strong>yes</strong>,确保守护进程开启。</p></li><li><p>编写开机自启动脚本</p><p>基本原理为：<br>系统开机启动时会去加载<code>/etc/init.d/</code>下面的脚本，通常而言每个脚本文件会自定义实现程序的启动；若想将新的程序开机自启动，只需在该目录下添加一个自定义启动程序的脚本，然后设置相应规则即可。<br>如在这里我们在<code>/etc/init.d/</code>下新建一个 redis 的脚本，开机启动时会去加载执行该脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx #!/bin/sh## Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/redis/bin/redis-serverCLIEXEC=/usr/local/redis/bin/redis-cliPIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pidCONF=&quot;/usr/local/redis/etc/$&#123;REDISPORT&#125;.conf&quot;case &quot;$1&quot; in    start)        if [ -f $PIDFILE ]        then                echo &quot;$PIDFILE exists, process is already running or crashed&quot;        else                echo &quot;Starting Redis server...&quot;                $EXEC $CONF        fi        ;;    stop)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>设置可执行权限：<code>chmod 755 redis</code></p></li><li><p>启动<code>/etc/init.d/redis start</code></p></li><li><p>设置开机自启动:<code>chkconfig redis on</code></p></li></ol><p><a href="https://blog.csdn.net/qq_38158631/article/details/78644274" target="_blank" rel="noopener">https://blog.csdn.net/qq_38158631/article/details/78644274</a></p><p><a href="https://blog.csdn.net/baidu_30000217/article/details/51558408" target="_blank" rel="noopener">https://blog.csdn.net/baidu_30000217/article/details/51558408</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Git</title>
      <link href="/2018/11/30/%E5%B8%B8%E7%94%A8%E7%9A%84git/"/>
      <url>/2018/11/30/%E5%B8%B8%E7%94%A8%E7%9A%84git/</url>
      
        <content type="html"><![CDATA[<h3 id="Git的概念"><a href="#Git的概念" class="headerlink" title="Git的概念"></a>Git的概念</h3><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><a id="more"></a><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/git.png" alt="&#39;Git的工作原理&#39;"></p><blockquote><p>Workspace（工作区）： </p><p>执行git add *命令就把改动提交到了暂存区，执行git pull命令将远程仓库的数据拉到当前分支并合并，执行git checkout [branch-name]切换分支</p></blockquote><blockquote><p>Index（暂存区）：</p><p>执行git commit -m ‘说明’ 命令就把改动提交到了仓库区（当前分支）</p></blockquote><blockquote><p>Repository（仓库区或本地仓库）：</p><p>执行git push origin master提交到远程仓库，执行git clone 地址将克隆远程仓库到本地</p></blockquote><blockquote><p>Remote（远程仓库）：</p><p>就是类似github，coding等网站所提供的仓库</p></blockquote><h3 id="Git术语"><a href="#Git术语" class="headerlink" title="Git术语"></a>Git术语</h3><p>仓库（Repository）：<br>一个仓库包括了所有的版本信息、所有的分支和标记信息。在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本</p><p>分支（Branches）：<br>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支执行命令git checkout branch</p><p>标记（Tags）：<br>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2016年11月17号在testing分支上的代码状态</p><p>提交（Commit）：<br>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</p><p>修订（Revision）：<br>用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长，16进制标识的字符串.。最新的版本可以通过HEAD来获取。之前的版本可以通过”HEAD~1”来获取，以此类推</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"> </span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"> </span><br><span class="line"># 下载一个项目和它的整个代码历史（各个分支提交记录等）</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><blockquote><p>git init后会出现.git文件夹，里面有配置文件，如果没有git bash里面输入ls -lah就可以看到了</p></blockquote><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"> </span><br><span class="line"># 编辑Git配置文件，只是配置用户信息的话直接看下面两行命令即可</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"> </span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p><h4 id="增加删除文件"><a href="#增加删除文件" class="headerlink" title="增加删除文件"></a>增加删除文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"> </span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"> </span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"> </span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"> </span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"> </span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"> </span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"> </span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"> </span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"> </span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"> </span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"> </span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h4 id="推送远程服务器"><a href="#推送远程服务器" class="headerlink" title="推送远程服务器"></a>推送远程服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"> </span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"> </span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"> </span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"> </span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"> </span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"> </span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"> </span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"> </span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"> </span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"> </span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"> </span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"> </span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"> </span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"> </span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"> </span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"> </span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"> </span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"> </span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"> </span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"> </span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"> </span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"> </span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"> </span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"> </span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"> </span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"> </span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"> </span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"> </span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"> </span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"> </span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"> </span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"> </span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"> </span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"> </span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"> </span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"> </span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"> </span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"> </span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"> </span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"> </span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"> </span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"> </span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"> </span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"> </span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"> </span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"> </span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"> </span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line">$ git blame [file]</span><br><span class="line"> </span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"> </span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"> </span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"> </span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"> </span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"> </span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"> </span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"> </span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"> </span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/git2.jpg" alt="&#39;Git常用命令图解&#39;"></p><p><a href="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/TortoiseGit-1.8%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8EGit%E5%AE%89%E8%A3%85%E5%8C%85_%E6%89%8B%E5%86%8C.zip" target="_blank" rel="noopener">点击下载 git for windows客户端</a></p><p><a href="https://github.com/cncounter/translation/blob/master/tiemao_2014/GitHelp/GitHelp.md" target="_blank" rel="noopener">安装教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Docker容器的MySQL主从配置</title>
      <link href="/2018/11/30/%E5%9F%BA%E4%BA%8EDocker%E5%AE%B9%E5%99%A8%E7%9A%84MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/30/%E5%9F%BA%E4%BA%8EDocker%E5%AE%B9%E5%99%A8%E7%9A%84MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Docker容器的MySQL主从配置"><a href="#基于Docker容器的MySQL主从配置" class="headerlink" title="基于Docker容器的MySQL主从配置"></a>基于Docker容器的MySQL主从配置</h1><p>我本机的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY                                     TAG                 IMAGE ID           </span><br><span class="line">ssh_network_vim_lnmp_redis_swoole_supervisor   latest              6da5efb40932</span><br></pre></td></tr></table></figure><p>环境搭建及MySQL安装步骤省略，根据已有的镜像创建容器</p><ol><li><p>master数据库</p><p><code>docker run -it -d --privileged=true --name master -p 33060:3306 -p 220:22 -p 8080:80 -p 1024:1024 -p 16379:6379 -p 9001:9001 -v   E:\www\:/home/www ssh_network_vim_lnmp_redis_swoole_supervisor /usr/sbin/init</code></p></li><li><p>slave1数据库</p><p><code>docker run -it -d --privileged=true --name slave1 -p 33061:3306 -p 221:22 -p 8081:80 -p 2024:1024 -p 26379:6379 -p 9002:9001 -v   E:\www\:/home/www ssh_network_vim_lnmp_redis_swoole_supervisor /usr/sbin/init</code></p></li><li><p>slave2数据库</p><p><code>docker run -it -d --privileged=true --name slave2 -p 33062:3306 -p 222:22 -p 8082:80 -p 3024:1024 -p 36379:6379 -p 9003:9001 -v   E:\www\:/home/www ssh_network_vim_lnmp_redis_swoole_supervisor /usr/sbin/init</code></p><p>​</p><p>……  slaveN</p></li></ol><h2 id="binlog方式"><a href="#binlog方式" class="headerlink" title="binlog方式"></a>binlog方式</h2><h3 id="master数据库"><a href="#master数据库" class="headerlink" title="master数据库"></a>master数据库</h3><p>真实机IP：192.168.2.107   容器IP:172.17.0.2</p><h4 id="修改MySQL配置文件-my-cnf"><a href="#修改MySQL配置文件-my-cnf" class="headerlink" title="修改MySQL配置文件(my.cnf)"></a>修改MySQL配置文件(my.cnf)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin #启动二进制文件 </span><br><span class="line">server_id=1 #服务器ID</span><br></pre></td></tr></table></figure><p>附一份全一点的配置,指定需要同步的数据库和不需要同步的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=1</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">binlog_format=mixed  // binlog 日志文件格式</span><br><span class="line">sync-binlog=1//</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=product</span><br><span class="line">binlog-do-db=test</span><br><span class="line">binlog-do-db=local</span><br></pre></td></tr></table></figure><p>重启MySQL；</p><h4 id="创建复制用户"><a href="#创建复制用户" class="headerlink" title="创建复制用户"></a>创建复制用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.<span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'zhimma'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> . <span class="keyword">TO</span> <span class="string">'zhimma'</span>@<span class="string">'%'</span>;</span><br><span class="line">或者</span><br><span class="line">2.  <span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'zhimma'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>;</span><br></pre></td></tr></table></figure><h4 id="查看MySQL"><a href="#查看MySQL" class="headerlink" title="查看MySQL"></a>查看MySQL</h4><figure class="highlight plain"><figcaption><span>master status```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      998 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果是项目中途使用主从复制，可以使用下面方法迁移数据</p><ol><li><p>锁定所有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br><span class="line">Query OK, 0 rows affected (2.59 sec)</span><br></pre></td></tr></table></figure></li><li><p>备份表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@b04f945297ac ~]# mysqldump -uroot -p123456 --all-databases -l -F &gt;/tmp/all_db.sql</span><br></pre></td></tr></table></figure></li><li><p>解锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UNLOCK TABLES; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>传输数据到从库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 221/222 /tmp/all_db.sql root@192.168.2.107:/tmp</span><br></pre></td></tr></table></figure></li></ol><h3 id="slave数据库"><a href="#slave数据库" class="headerlink" title="slave数据库"></a>slave数据库</h3><h4 id="修改server-uuid"><a href="#修改server-uuid" class="headerlink" title="修改server-uuid"></a>修改server-uuid</h4><p>将<code>/var/lib/mysql/auto.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[auto]</span><br><span class="line">server-uuid=f781e2b4-28e1-11e8-a1c0-0242ac110001</span><br></pre></td></tr></table></figure><h4 id="修改MySQL配置文件-my-cnf-1"><a href="#修改MySQL配置文件-my-cnf-1" class="headerlink" title="修改MySQL配置文件(my.cnf)"></a>修改MySQL配置文件(my.cnf)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin #启动二进制文件 </span><br><span class="line">server_id=101 #服务器ID</span><br></pre></td></tr></table></figure><p>重启MySQL；</p><h4 id="导入主备份文件"><a href="#导入主备份文件" class="headerlink" title="导入主备份文件"></a>导入主备份文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@9ae039d46474 tmp]# mysql -uroot -p123456 &lt; /tmp/all_db.sql</span><br></pre></td></tr></table></figure><h4 id="开启slave同步"><a href="#开启slave同步" class="headerlink" title="开启slave同步"></a>开启slave同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&apos;192.168.2.107&apos;,MASTER_PORT=33060, MASTER_USER=&apos;zhimma&apos;, MASTER_PASSWORD=&apos;123456&apos;, MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, MASTER_LOG_POS=998;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&apos;172.17.0.2&apos;, MASTER_USER=&apos;zhimma&apos;, MASTER_PASSWORD=&apos;123456&apos;, MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, MASTER_LOG_POS=998;</span><br><span class="line"></span><br><span class="line">start slave</span><br></pre></td></tr></table></figure><h4 id="查看是否同步成功slave连接master成功"><a href="#查看是否同步成功slave连接master成功" class="headerlink" title="查看是否同步成功slave连接master成功"></a>查看是否同步成功slave连接master成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.43 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Queueing master event to the relay log</span><br><span class="line">                  Master_Host: 192.168.2.107</span><br><span class="line">                  Master_User: zhimma</span><br><span class="line">                  Master_Port: 33060</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000003</span><br><span class="line">          Read_Master_Log_Pos: 4</span><br><span class="line">               Relay_Log_File: 06e5a050e74b-relay-bin.000001</span><br><span class="line">                Relay_Log_Pos: 4</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">              Slave_IO_Running: Yes</span><br><span class="line">              Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 998</span><br><span class="line">              Relay_Log_Space: 1483</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: f781e2b4-28e1-11e8-a1c0-0242ac110002</span><br><span class="line">             Master_Info_File: /var/lib/mysql/master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: </span><br><span class="line">            Executed_Gtid_Set: </span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: </span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in set (0.20 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>同步成功</p><p><a href="http://www.cnblogs.com/clsn/p/8150036.html" target="_blank" rel="noopener">http://www.cnblogs.com/clsn/p/8150036.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬瓦工CentOs7 实现BBR加速以及SS安装</title>
      <link href="/2018/11/30/%E6%90%AC%E7%93%A6%E5%B7%A5Cenots7%20%E5%AE%9E%E7%8E%B0BBR%E5%8A%A0%E9%80%9F%E4%BB%A5%E5%8F%8ASS%E5%AE%89%E8%A3%85/"/>
      <url>/2018/11/30/%E6%90%AC%E7%93%A6%E5%B7%A5Cenots7%20%E5%AE%9E%E7%8E%B0BBR%E5%8A%A0%E9%80%9F%E4%BB%A5%E5%8F%8ASS%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h3 id="环境-centos7-64位"><a href="#环境-centos7-64位" class="headerlink" title="环境:   centos7 64位"></a>环境:   <code>centos7 64位</code></h3><h3 id="1、一键安装Shadowsock"><a href="#1、一键安装Shadowsock" class="headerlink" title="1、一键安装Shadowsock"></a>1、一键安装Shadowsock</h3><ul><li>下载脚本<br> <code>wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh</code> </li><li>增加执行权限<br> <code>chmod +x shadowsocks-libev.sh</code> </li><li>运行<br> <code>./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</code> </li></ul><blockquote><p>安装过程中会提示配置端口、密码、加密方式。</p></blockquote><ul><li>卸载:<br> <code>./shadowsocks-libev.sh uninstall</code></li><li>ss控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start </span><br><span class="line">停止：/etc/init.d/shadowsocks stop </span><br><span class="line">重启：/etc/init.d/shadowsocks restart </span><br><span class="line">查看状态：/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><h3 id="2、安装BBR加速"><a href="#2、安装BBR加速" class="headerlink" title="2、安装BBR加速"></a>2、安装BBR加速</h3><blockquote><p>目前支持的Linux系统包括：Ubuntu 14.04 x64、Ubuntu 16.04 x64、CentOS 6 x64、CentOS 7 x64 只支持 64 位系统，要求 glibc 版本 2.14 以上。</p></blockquote><ul><li>关闭防火墙</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、systemctl disable firewalld</span><br><span class="line">2、systemctl stop firewalld</span><br></pre></td></tr></table></figure><ul><li>BBR安装脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、wget https://raw.githubusercontent.com/kuoruan/shell-scripts/master/ovz-bbr/ovz-bbr-installer.sh</span><br><span class="line">2、chmod +x ovz-bbr-installer.sh</span><br><span class="line">3、./ovz-bbr-installer.sh</span><br></pre></td></tr></table></figure><blockquote><p>安装过程中，会提示加速端口(可以更改)</p></blockquote><ul><li>判断BBR是否正常工作</li></ul><h4 id="ping-10-0-0-2-如果能通，则代表启动成功"><a href="#ping-10-0-0-2-如果能通，则代表启动成功" class="headerlink" title="ping 10.0.0.2 如果能通，则代表启动成功"></a>ping 10.0.0.2 如果能通，则代表启动成功</h4><ul><li>控制bbr</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl &#123;start|stop|restart|status&#125; haproxy-lkl</span><br></pre></td></tr></table></figure><ul><li>配置bbr加速端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/haproxy-lkl/etc/port-rules</span><br></pre></td></tr></table></figure><blockquote><p>一行一个端口，可写范围</p></blockquote><ul><li>​    卸载BBR<br> ​    </li></ul><p>作者：我是你的nobita</p><p>链接：<a href="https://www.jianshu.com/p/9f27d4cabd40" target="_blank" rel="noopener">https://www.jianshu.com/p/9f27d4cabd40</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> CentOs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬瓦工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口</title>
      <link href="/2018/11/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/11/30/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>来自这里<a href="https://blog.csdn.net/sunlylorn/article/details/6124319" target="_blank" rel="noopener">https://blog.csdn.net/sunlylorn/article/details/6124319</a></p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><p>一个类中如果有一个方法是抽象方法，那么这个类必须定义为抽象类</p></li><li><p>抽象类是指在 class 前加了 abstract 关键字且存在抽象方法（在类方法 function 关键字前加了 abstract 关键字）的类。</p></li><li><p>抽象类不能直接实例化，抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。</p></li><li><p>如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="comment">/** 抽象类中可以定义变量 */</span>  </span><br><span class="line">    <span class="keyword">protected</span> $value1 = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span> $value2 = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">public</span> $value3 = <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 大多数情况下，抽象类至少含有一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。 </span></span><br><span class="line"><span class="comment">     * 可以像声明普通类方法那样声明抽象方法，但是要以分号而不是方法体结束。也就是说抽象方法在抽象类中不能被实现，也就是没有函数体“&#123;some codes&#125;”。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">/** 也可以定义非抽象方法 */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"run function"</span> .PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Service</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"say function"</span> .PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">jump</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiniA</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"talk function "</span>.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">other</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;jump();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class = <span class="keyword">new</span> MiniA();</span><br><span class="line">$class-&gt;talk();</span><br><span class="line">$class-&gt;other();</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p>PHP接口类interface就是一个类的领导者，指明方向，<code>子类必须完成它指定方法</code></p><ul><li><p>抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字 interface 来声明。</p></li><li><p>interface 是完全抽象的，只能声明方法，而且只能声明 public 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也<strong>不能声明实例变量 </strong>。然而， <strong>interface 却可以声明常量变量</strong> 。但将常量变量放在 interface 中违背了其作为接口的作用而存在的宗旨，也混淆了 interface 与类的不同价值。如果的确需要，可以将其放在相应的 abstract class 或 Class 中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> NAME = <span class="string">'zhimma'</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">talk</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">echo</span> Bar:: NAME;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>任何实现接口的类都要实现接口中所定义的所有方法,否则该类必须声明为 abstract 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement say() method.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement talk() method.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">Bar</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。一个类可以同时继承一个父类和实现任意多个接口。 extends 子句应该在 implements 子句之前。 PHP 只支持继承自一个父类，因此 extends 关键字后只能跟一个类名。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement say() method.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement talk() method.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>接口不可以实现另一个接口，但可以继承多个</p><p>​</p><p>​</p></li></ul><h3 id="抽象类对比接口"><a href="#抽象类对比接口" class="headerlink" title="抽象类对比接口"></a>抽象类对比接口</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul><li>两者都是抽象类，都不能实例化。</li><li>interface 实现类及 abstract class 的子类都必须要实现已经声明的抽象方法。</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>interface 需要实现，要用 implements ，而 abstract class 需要继承，要用 extends 。</li><li>一个类可以实现多个 interface ，但一个类只能继承一个 abstract class </li><li>interface 强调特定功能的实现，而 abstract class 强调所属关系。</li><li>尽管 interface 实现类及 abstract class 的子类都必须要实现相应的抽象方法，但实现的形式不同。 interface 中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体 ) ，实现类必须要实现。而 abstract class 的子类可以有选择地实现。<ul><li>abstract class 中并非所有的方法都是抽象的，只有那些冠有 abstract 的方法才是抽象的，子类必须实现。那些没有 abstract 的方法，在 abstract class 中必须定义方法体</li><li>abstract class 的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。</li></ul></li><li>abstract class 是 interface 与 class 的中介。 abstract class 在 interface 及 class 中起到了承上启下的作用。一方面， abstract class 是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。</li><li>接口中的抽象方法前不用也不能加 abstract 关键字，默认隐式就是抽象方法，也不能加 final关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上 abstract 表示显示声明为抽象方法。</li><li>接口中的抽象方法默认是 public 的，也只能是 public 的，不能用 private ， protected 修饰符修饰。而抽象类中的抽象方法则可以用 public ， protected 来修饰，但不能用 private </li></ul><h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><h4 id="interface-的应用场合"><a href="#interface-的应用场合" class="headerlink" title="interface 的应用场合"></a>interface 的应用场合</h4><ul><li>类与类之间需要特定的接口进行协调，而不在乎其如何实现</li><li>作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。</li><li>需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li><li>需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</li></ul><h4 id="abstract-的应用场合"><a href="#abstract-的应用场合" class="headerlink" title="abstract 的应用场合"></a>abstract 的应用场合</h4><p>在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它</p><ul><li>定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用 abstract class 定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖</li><li>某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。 abstract 的中介作用可以很好地满足这一点。</li><li>规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特 定的功能 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂JWT</title>
      <link href="/2018/11/30/%E6%90%9E%E6%87%82JWT/"/>
      <url>/2018/11/30/%E6%90%9E%E6%87%82JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="搞懂JWT"><a href="#搞懂JWT" class="headerlink" title="搞懂JWT"></a>搞懂JWT</h1><p>本文基本一字不差的转载至<a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="noopener">这里</a></p><p>JSON Web Token（JWT）是一个非常轻巧的<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank" rel="noopener">规范</a>。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息</p><p>让我们来假想一下一个场景。在A用户关注了B用户的时候，系统发邮件给B用户，并且附有一个链接“点此关注A用户”。链接的地址可以是这样的<br><code>https://your.awesome-app.com/make-friend/?from_user=B&amp;target_user=A</code><br>上面的URL主要通过URL来描述这个当然这样做有一个弊端，那就是要求用户B用户是一定要先登录的。可不可以简化这个流程，让B用户不用登录就可以完成这个操作。JWT就允许我们做到这点。<br><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/jwt.png" alt="jwt"></p><h3 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h3><p>一个JWT实际上就是一个字符串，它由三部分组成，<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong></p><h5 id="载荷（Payload）"><a href="#载荷（Payload）" class="headerlink" title="载荷（Payload）"></a>载荷（Payload）</h5><p>我们先将上面的添加好友的操作描述成一个JSON对象。其中添加了一些其他的信息，帮助今后收到这个JWT的服务器理解这个JWT。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">"iss"</span>: <span class="string">"John Wu JWT"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"iat"</span>: <span class="number">1441593502</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"exp"</span>: <span class="number">1441594722</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"aud"</span>: <span class="string">"www.example.com"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"sub"</span>: <span class="string">"jrocket@example.com"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"from_user"</span>: <span class="string">"B"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"target_user"</span>: <span class="string">"A"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面的前五个字段都是由JWT的标准所定义的。</p><ul><li><code>iss</code>: 该JWT的签发者</li><li><code>sub</code>: 该JWT所面向的用户</li><li><code>aud</code>: 接收该JWT的一方</li><li><code>exp</code>(expires): 什么时候过期，这里是一个Unix时间戳</li><li><code>iat</code>(issued at): 在什么时候签发的</li></ul><p>这些定义都可以在<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank" rel="noopener">标准</a>中找到。<br>将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的<strong>Payload</strong>（载荷）。</p><p><code>eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</code></p><p>如果你使用Node.js，可以用Node.js的包<a href="https://github.com/brianloveswords/base64url" target="_blank" rel="noopener">base64url</a>来得到这个字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base64url = <span class="built_in">require</span>(<span class="string">'base64url'</span>)</span><br><span class="line"><span class="keyword">var</span> header = &#123;</span><br><span class="line">    <span class="string">"from_user"</span>: <span class="string">"B"</span>,</span><br><span class="line">    <span class="string">"target_user"</span>: <span class="string">"A"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(base64url(<span class="built_in">JSON</span>.stringify(header)))</span><br><span class="line"><span class="comment">// 输出：eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</span></span><br></pre></td></tr></table></figure></p><blockquote><p>小知识：Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p></blockquote><h5 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h5><p>JWT还需要一个头部，头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，我们说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法。<br>对它也要进行Base64编码，之后的字符串就成了JWT的<strong>Header</strong>（头部）。<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></p><h5 id="签名（签名）"><a href="#签名（签名）" class="headerlink" title="签名（签名）"></a>签名（签名）</h5><p>将上面的两个编码后的字符串都用句号<code>.</code>连接在一起（头部在前），就形成了<br><code>yJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0</code><br>这一部分的过程在<a href="https://github.com/brianloveswords/node-jws/blob/master/lib/sign-stream.js" target="_blank" rel="noopener">node-jws的源码</a>中有体现</p><p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用<code>mystar</code>作为密钥的话，那么就可以得到我们加密后的内容<br><code>rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</code><br>这一部分又叫做<strong>签名</strong>。</p><p><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/sig1.png" alt="签名"><br>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT<br><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</code></p><p>于是，我们就可以将邮件中的URL改成<br><code>https://your.awesome-app.com/make-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</code><br>这样就可以安全地完成添加好友的操作了！<br>且慢，我们一定会有一些问题：</p><ol><li>签名的目的是什么？</li><li>Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？<br>让我逐一为你说明。</li></ol><h3 id="签名的目的"><a href="#签名的目的" class="headerlink" title="签名的目的"></a>签名的目的</h3><p>最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。</p><p>所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。</p><p><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/sig2.png" alt="sig2"><br>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用<code>alg</code>字段指明了我们的加密算法了。</p><p>如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。</p><h3 id="信息会暴露？"><a href="#信息会暴露？" class="headerlink" title="信息会暴露？"></a>信息会暴露？</h3><p>是的。</p><p>所以，在JWT中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。</p><p>但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。</p><h3 id="JWT的适用场景"><a href="#JWT的适用场景" class="headerlink" title="JWT的适用场景"></a>JWT的适用场景</h3><p>我们可以看到，JWT适合用于向Web应用传递一些非敏感信息。例如在上面提到的完成加好友的操作，还有诸如下订单的操作等等。</p><p>其实JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装Swoole扩展问题记录</title>
      <link href="/2018/11/30/mac%E5%AE%89%E8%A3%85swoole%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/30/mac%E5%AE%89%E8%A3%85swoole%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="openssl-ssl-h’-file-not-found"><a href="#openssl-ssl-h’-file-not-found" class="headerlink" title="openssl/ssl.h’ file not found`"></a>openssl/ssl.h’ file not found`</h2><p><code>/private/tmp/pear/temp/swoole/include/swoole.h:438:10: fatal error: &#39;openssl/ssl.h&#39; file not found</code></p><p><strong>原因：</strong><br>openssl 未安装或 openssl 库不在标准位置中<br><strong>解决方案：</strong></p><ol><li><p>确认是否安装了 openssl<br><code>brew search openssl</code><br>若未安装则执行命令<code>brew install openssl</code>进行安装</p></li><li><p>确认 openssl 库是否在标准位置中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~ ls /usr/local/include/openssl</span><br><span class="line">☁  ~ No such file or directory</span><br></pre></td></tr></table></figure><p>这就是问题所在了，找到 openssl/include/openssl 目录，并 cp 到 /usr/local/include 目录中。</p><p><code>☁  ~  ln -s /usr/local/Cellar/openssl/1.0.2p/include/openssl/ /usr/local/include/</code></p><p>一般情况下就可以解决该问题了。</p><p>但是，也可能会遇到很诡异的状况，上步没有解决问题，依然找不到 openssl/ssl.h 等文件<br>复制 openssl 源文件到 swoole 的源码目录中，编译就可以了。</p><p><code>cp -R  /usr/local/Cellar/openssl/1.0.2p/include/openssl swoole-src-2.1.3/include</code></p><p>这个肯定能解决问题了</p></li></ol><h2 id="Enable-openssl-support-require-openssl-library"><a href="#Enable-openssl-support-require-openssl-library" class="headerlink" title="Enable openssl support, require openssl library."></a><code>Enable openssl support, require openssl library.</code></h2><p><code>/private/tmp/pear/temp/swoole/php_swoole.h:137:2: error: &quot;Enable openssl support, require openssl library.&quot;</code></p><p>上面的问题解决了，再次<code>pecl install swoole</code>时候报了这个错，找了很久都么有找到解决方案，偶然看到pecl 安装的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enable debug/trace log support? [no] : yes</span><br><span class="line">enable sockets supports? [no] : yes</span><br><span class="line">enable openssl support? [no] : yes</span><br><span class="line">enable http2 support? [no] : yes</span><br><span class="line">enable async-redis support? [no] : yes</span><br><span class="line">enable mysqlnd support? [no] : yes</span><br><span class="line">enable postgresql coroutine client support? [no] : no</span><br><span class="line">building in /private/tmp/pear/temp/pear-build-zhimmaSwGIQ1/swoole-4.2.1</span><br><span class="line">running: /private/tmp/pear/temp/swoole/configure --with-php-config=/usr/local/opt/php@7.1/bin/php-config --enable-debug-log=yes --enable-sockets=yes --enable-openssl=yes --enable-http2=yes --enable-async-redis=yes --enable-mysqlnd=yes --enable-coroutine-postgresql=no</span><br></pre></td></tr></table></figure><p>，于是猜想如果指定<code>openssl</code>的目录，是否可以解决，先看看<code>openssl</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  which openssl</span><br><span class="line">/usr/local/opt/openssl/bin/openssl</span><br></pre></td></tr></table></figure><p>于是安装过程就变成下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enable debug/trace log support? [no] : yes</span><br><span class="line">enable sockets supports? [no] : yes</span><br><span class="line">enable openssl support? [no] : yes --with-openssl-dir=/usr/local/opt/openssl/bin/openssl</span><br><span class="line">enable http2 support? [no] : yes</span><br><span class="line">enable async-redis support? [no] : yes</span><br><span class="line">enable mysqlnd support? [no] : yes</span><br><span class="line">enable postgresql coroutine client support? [no] : no</span><br><span class="line">building in /private/tmp/pear/temp/pear-build-zhimmaN9CyFV/swoole-4.2.1</span><br><span class="line">running: /private/tmp/pear/temp/swoole/configure --with-php-config=/usr/local/opt/php@7.1/bin/php-config --enable-debug-log=yes --enable-sockets=yes --enable-openssl=yes --with-openssl-dir=/usr/local/opt/openssl/bin/openssl --enable-http2=yes --enable-async-redis=yes --enable-mysqlnd=yes --enable-coroutine-postgresql=no</span><br></pre></td></tr></table></figure><p>错误解决</p><h2 id="Enable-http2-support-require-nghttp2-library"><a href="#Enable-http2-support-require-nghttp2-library" class="headerlink" title="Enable http2 support, require nghttp2 library."></a><code>Enable http2 support, require nghttp2 library.</code></h2><p><code>/private/tmp/pear/temp/swoole/php_swoole.h:148:2: error: &quot;Enable http2 support, require nghttp2 library.</code></p><p><strong>解决方案：</strong></p><p><code>brew install nghttp2</code></p><blockquote><p>未能解决</p></blockquote><h2 id="hiredis-hiredis-h-39-file-not-found"><a href="#hiredis-hiredis-h-39-file-not-found" class="headerlink" title="hiredis/hiredis.h&#39; file not found"></a><code>hiredis/hiredis.h&#39; file not found</code></h2><p><code>/private/tmp/pear/temp/swoole/swoole_redis.c:20:10: fatal error: hiredis/hiredis.h&#39; file not found</code></p><p><strong>解决方案：</strong></p><p><code>brew install hiredis</code></p><h2 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">--disable-option-checking  ignore unrecognized --enable/--with options</span><br><span class="line">  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)</span><br><span class="line">  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]</span><br><span class="line">  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]</span><br><span class="line">  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)</span><br><span class="line">  --with-libdir=NAME      Look for libraries in .../NAME rather than .../lib</span><br><span class="line">  --with-php-config=PATH  Path to php-config php-config</span><br><span class="line">  --enable-swoole-debug   Enable swoole debug</span><br><span class="line">  启用swoole的调试日志。不要在生产环境中启用此配置。</span><br><span class="line">  --enable-trace-log   Enable swoole trace log</span><br><span class="line">  --enable-sockets        Do you have sockets extension?</span><br><span class="line">  启用对 sockets 的支持。依赖 sockets</span><br><span class="line">  --enable-async-redis    Do you have hiredis?</span><br><span class="line">  启用对异步Redis客户端的支持。依赖 hiredis</span><br><span class="line">  --enable-coroutine-postgresql    Do you install postgresql?</span><br><span class="line">  启用协程 Postgresql 客户端，依赖 libpq</span><br><span class="line">  --enable-openssl        Use openssl?</span><br><span class="line">  启用openssl支持。依赖 libssl.so</span><br><span class="line">  --enable-http2          Use http2.0?</span><br><span class="line">  启用HTTP2的支持。依赖 nghttp2</span><br><span class="line">  --enable-thread         Experimental: Use thread?</span><br><span class="line">  启用线程支持 //实验性功能。请勿在生产环境中使用此功能</span><br><span class="line">  --enable-hugepage       Experimental: Use hugepage?</span><br><span class="line">  启用 hugepage //使用大内存页优化性能，具体鸟哥在他的博客中讲到。</span><br><span class="line">  如果已经开启了 jemalloc，再开启hugepage 印象性能</span><br><span class="line">  https://blog.digitalocean.com/transparent-huge-pages-and-alternative-memory-allocators/</span><br><span class="line">  实验性功能。请勿在生产环境中使用此功能</span><br><span class="line">  --enable-swoole         Enable swoole support</span><br><span class="line">  --enable-swoole-static    Enable swoole static compile support</span><br><span class="line">  --with-swoole           With swoole support</span><br><span class="line">  --with-libpq-dir=DIR    Include libpq support (requires libpq &gt;= 9.5)</span><br><span class="line">  --with-openssl-dir=DIR    Include OpenSSL support (requires OpenSSL &gt;= 0.9.6)</span><br><span class="line">  设置openssl库的路径，例如：--with-openssl-dir=/opt/openssl/.</span><br><span class="line">  --with-jemalloc-dir=DIR    Include jemalloc support</span><br><span class="line">  使用 jemalloc 进行内存优化支持</span><br><span class="line">  --enable-mysqlnd       Do you have mysqlnd?</span><br><span class="line">  启用对 mysqlnd 的支持，依赖 mysqlnd</span><br><span class="line">  --enable-coroutine      Enable coroutine (requires PHP &gt;= 5.5)</span><br><span class="line">  启用协程</span><br><span class="line">  --enable-asan      Enable asan</span><br><span class="line">  启用 Address-Sanitizier 内存检测工具 //只有开启debug才有效</span><br><span class="line">  --enable-picohttpparser     Experimental: Do you have picohttpparser?</span><br><span class="line">  启用 picohttpparser 支持 //这是一个超高性能的http解析器，实验性功能。请勿在生产环境中使用此功能</span><br><span class="line">  --enable-timewheel     Experimental: Enable timewheel heartbeat?</span><br><span class="line">  启用时间轮算法并优化心跳算法 //实验性功能。请勿在生产环境中使用此功能</span><br><span class="line">  --enable-debug,  compile with debug symbols</span><br><span class="line">  编译时加入符号表 //使用gdb调试时有用</span><br><span class="line">  --enable-shared=PKGS    Build shared libraries default=yes</span><br><span class="line">  --enable-static=PKGS    Build static libraries default=yes</span><br><span class="line">  --enable-fast-install=PKGS</span><br><span class="line">                          Optimize for fast installation default=yes</span><br><span class="line">  --with-gnu-ld           Assume the C compiler uses GNU ld default=no</span><br><span class="line">  --disable-libtool-lock  Avoid locking (might break parallel builds)</span><br><span class="line">  --with-pic              Try to use only PIC/non-PIC objects default=use both</span><br><span class="line">  --with-tags=TAGS        Include additional configurations automatic</span><br></pre></td></tr></table></figure><h2 id="centos-安装swoole-扩展"><a href="#centos-安装swoole-扩展" class="headerlink" title="centos 安装swoole 扩展"></a>centos 安装swoole 扩展</h2><h3 id="builtin-saddl-overflow"><a href="#builtin-saddl-overflow" class="headerlink" title="__builtin_saddl_overflow"></a>__builtin_saddl_overflow</h3><p><a href="https://www.vpser.net/manage/centos-6-upgrade-gcc.html" target="_blank" rel="noopener">https://www.vpser.net/manage/centos-6-upgrade-gcc.html</a></p><blockquote><p>__builtin_saddl_overflow’ was not declared in this scope<br>这是一个已知的问题 - 问题是 CentOS 上的默认 gcc 缺少必需的定义，即使在升级 gcc 之后，PECL 也会找到旧的编译器。要安装驱动程序，必须首先通过安装 devtoolset 集合来升级 gcc，如下所示：</p></blockquote><ul><li>sudo yum install centos-release-scl</li><li>sudo yum install devtoolset-7</li><li>scl enable devtoolset-7 bash</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> Swoole </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有可用软件包nginx</title>
      <link href="/2018/11/30/%E6%B2%A1%E6%9C%89%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85nginx/"/>
      <url>/2018/11/30/%E6%B2%A1%E6%9C%89%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85nginx/</url>
      
        <content type="html"><![CDATA[<p>今天安装Nginx时候使用：<code>yum install nginx</code>，报出了<code>没有可用软件包 nginx</code>，我的环境是CentOS7,在网上查询后，贴出解决方法</p><p><a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install" target="_blank" rel="noopener">ngixn官方解决方法</a></p><ul><li>先创建yum的一个repository文件：/etc/yum.repos.d/nginx.repo；</li><li><p>将下面配置粘贴保存进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)安装Nginx</span><br><span class="line">yum install nginx</span><br><span class="line">(2)启动nginx</span><br><span class="line">service nginx start / systemctl start nginx.service</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库之主键、外键、索引</title>
      <link href="/2018/11/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/11/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%B8%BB%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E3%80%81%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><hr><p>主键用来标志唯一的某一行,主键也是数据表中唯一索引,比如用户表中有id,name,但是id是唯一的,你要找出一个用户,就只能根据id去找,才能找出唯一一个,另外主键必须非空且唯一,一个表最多只能有一个主键,主键是可选的,但是为每个表指定主键通常会更好.MySQL中使用<strong>PRIMARY KEY</strong>来指定主键,</p><a id="more"></a><h3 id="创建表时指定主键"><a href="#创建表时指定主键" class="headerlink" title="创建表时指定主键"></a>创建表时指定主键</h3><p>demo1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">id INT PRIMARY KEY auto_increment,</span><br><span class="line">username VARCHAR (255)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>demo2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">id INT auto_increment,</span><br><span class="line">username VARCHAR (255),</span><br><span class="line">PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="为已存在的表创建主键"><a href="#为已存在的表创建主键" class="headerlink" title="为已存在的表创建主键"></a>为已存在的表创建主键</h3><p>例如已存在表user(id,username),现在将字段id指定为主键并且自增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE USER ADD PRIMARY KEY (id),</span><br><span class="line"> MODIFY id INT AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE USER DROP PRIMARY KEY,</span><br><span class="line"> MODIFY id INT;</span><br></pre></td></tr></table></figure><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><hr><p>外键是用来指定参照完整性约束,举个例子：</p><p>假如某个电脑生产商,它的数据库中保存着整机和配件的产品信息.用来保存整机产品信息的表叫做 Pc;用来保存配件供货信息的表叫做Parts.</p><p>在Pc表中有一个字段,用来描述这款电脑所使用的CPU型号;</p><p>在Parts 表中相应有一个字段,描述的正是CPU的型号,我们可以把它想成是全部CPU的型号列表.</p><p>很显然,这个厂家生产的电脑,其使用的CPU一定是供货信息表(parts)中存在的型号.这时,两个表中就存在一种约束关系(constraint)——Pc表中的CPU型号受到Parts 表中型号的约束.<br>被指定为外键的列必须要有索引,外键参考列必须为令一个表的主键;</p><h3 id="创建表时指定外键"><a href="#创建表时指定外键" class="headerlink" title="创建表时指定外键"></a>创建表时指定外键</h3><p>例如user(id,username)和表article(id,uid,title),其中article.uid时外键指向user.id主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE article (</span><br><span class="line">id INT auto_increment,</span><br><span class="line">uid INT,</span><br><span class="line">PRIMARY KEY (id),</span><br><span class="line">CONSTRAINT fk_user_article_uid FOREIGN KEY (uid) REFERENCES USER (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果外键列没有索引,则MySQL会自动为其添加一个和外键同名的索引</p></blockquote><h3 id="修改表时添加外键约束"><a href="#修改表时添加外键约束" class="headerlink" title="修改表时添加外键约束"></a>修改表时添加外键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD CONSTRAINT fk_user_article_uid FOREIGN KEY (uid) REFERENCES USER (id);</span><br></pre></td></tr></table></figure><h3 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article DROP FOREIGN KEY fk_user_article_uid;</span><br></pre></td></tr></table></figure><blockquote><p>注意：删除外键时,该外键对应的所索引并不会被删除</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><hr><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>这是最基本的索引类型,而且它没有唯一性之类的限制.普通索引可以通过以下几种方式创建： </p><h4 id="建表时创建索引"><a href="#建表时创建索引" class="headerlink" title="建表时创建索引"></a>建表时创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX &lt;索引的名字&gt; ON tablename (列的列表);</span><br><span class="line">CREATE INDEX name ON user (username);</span><br></pre></td></tr></table></figure><h4 id="修改表时添加索引"><a href="#修改表时添加索引" class="headerlink" title="修改表时添加索引"></a>修改表时添加索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表);</span><br><span class="line">ALTER TABLE USER ADD INDEX username (username);</span><br></pre></td></tr></table></figure><h3 id="唯一性索引"><a href="#唯一性索引" class="headerlink" title="唯一性索引"></a>唯一性索引</h3><p>这种索引和前面的”普通索引”基本相同,但有一个区别：索引列的所有值都只能出现一次,即必须唯一.唯一性索引可以用以下几种方式创建:</p><h4 id="建表时创建索引-1"><a href="#建表时创建索引-1" class="headerlink" title="建表时创建索引"></a>建表时创建索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE  INDEX &lt;索引的名字&gt; ON tablename (列的列表);</span><br><span class="line">CREATE UNIQUE  INDEX name ON user (username);</span><br></pre></td></tr></table></figure><h4 id="修改表时添加索引-1"><a href="#修改表时添加索引-1" class="headerlink" title="修改表时添加索引"></a>修改表时添加索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ADD UNIQUE  INDEX [索引的名字] (列的列表);</span><br><span class="line">ALTER TABLE USER ADD UNIQUE INDEX username (username);</span><br></pre></td></tr></table></figure><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>上文介绍过,此处略</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MySQL从3.23.23版开始支持全文索引和全文检索.在MySQL中,全文索引的索引类型为FULLTEXT.全文索引可以在VARCHAR或者TEXT类型的列上创建.它可以通过CREATE TABLE命令创建,也可以通过ALTER TABLE或CREATE INDEX命令创建.对于大规模的数据集,通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快</p><hr><h2 id="索引的其他说明"><a href="#索引的其他说明" class="headerlink" title="索引的其他说明"></a>索引的其他说明</h2><hr><h3 id="单列索引与多列索引"><a href="#单列索引与多列索引" class="headerlink" title="单列索引与多列索引"></a>单列索引与多列索引</h3><p>索引可以是单列索引,也可以是多列索引.</p><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create INDEX 索引名称 ON tablename (row1,row2,row3);</span><br></pre></td></tr></table></figure><h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ADD INDEX 索引名称 (row1,row2,row3);</span><br></pre></td></tr></table></figure><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>多列索引还有另外一个优点,它通过称为最左前缀（Leftmost Prefixing）的概念体现出来,我们举个列子：</p><p>现在我们有一个name、age、phone列上的多列索引,我们称这个索引为<strong>indexs</strong>.当搜索条件是以下各种列的组合时,MySQL将使用<strong>indexs</strong>索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name,age,phone</span><br><span class="line">name,age</span><br><span class="line">name</span><br></pre></td></tr></table></figure><p>从另一方面理解,它相当于我们创建了(name、age、phone)、(name,age)以及(name)这些列组合上的索引.下面这些查询都能够使用这个<strong>indexs</strong>索引： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT * FROM user WHERE user=&apos;Mike&apos; AND age=&apos;18&apos; AND phone=&apos;117&apos;; </span><br><span class="line">SELECT * FROM user WHERE user=&apos;Mike&apos; AND age=&apos;19&apos;; </span><br><span class="line">SELECT * FROM user WHERE user=&apos;Mike&apos; AND age=&apos;20&apos;;</span><br></pre></td></tr></table></figure><h3 id="如何选择索引列"><a href="#如何选择索引列" class="headerlink" title="如何选择索引列"></a>如何选择索引列</h3><p>在性能优化过程中,选择在哪些列上创建索引是最重要的步骤之一.可以考虑使用索引的主要有两种类型的列：在WHERE子句中出现的列,在join子句中出现的列.请看下面这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT age ## 不使用索引 FROM user WHERE name =&apos;Mike&apos; ## 考虑使用索引 AND </span><br><span class="line">age=&apos;18&apos; ## 考虑使用索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT article.title, ##不使用索引 user.name ##不使用索引 FROM user LEFT JOIN article ON </span><br><span class="line">user.id=article.uid ##考虑使用索引 WHERE user.phone=&apos;229&apos; ##考虑使用索引 AND </span><br><span class="line">nickname=&apos;mma&apos; ##考虑使用索引</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elk stack实践</title>
      <link href="/2017/06/12/elk%20stack%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/06/12/elk%20stack%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><p>真实机IP：192.168.1.198，其中</p><table><thead><tr><th>服务器</th><th>IP</th><th>说明</th></tr></thead><tbody><tr><td>Redis-server</td><td>172.17.0.3</td><td>nginx服务器1</td></tr><tr><td>Project1(logstash)</td><td>172.17.0.2</td><td>nginx服务器2</td></tr><tr><td>Project2(logstash)</td><td>172.17.0.3</td><td>服务器1</td></tr><tr><td>Elk</td><td>172.17.0.6</td><td>服务器2</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --privileged=true --name redis-master -p 63791:6379 -p 221:22 -v /Users/zhimma/Data/www/:/data/www/ 67793c412ed1 /usr/sbin/init</span><br><span class="line"></span><br><span class="line">docker run -it -d --privileged=true --name project1 -p 50441:5044 -p 8081:80 -p 10241:1024 -p 222:22  -v /Users/zhimma/Data/www/:/data/www/ 67793c412ed1 /usr/sbin/init</span><br><span class="line"></span><br><span class="line">docker run -it -d --privileged=true --name project2 -p 50442:5044 -p 8082:80 -p 10242:1024 -p 223:22  -v /Users/zhimma/Data/www/:/data/www/ 67793c412ed1 /usr/sbin/init</span><br><span class="line"></span><br><span class="line">docker run -it -d --privileged=true --name elk -p 50443:5044 -p 15602:5601 -p 224:22  -p 8083:80 -p 10243:1024 -v /Users/zhimma/Data/www/:/data/www/ 67793c412ed1 /usr/sbin/init</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID              PORTS                       NAMES</span><br><span class="line"><span class="number">3</span>f139b00a661              <span class="number">3306</span>/tcp, <span class="number">6379</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">224</span>-&gt;<span class="number">22</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8083</span>-&gt;<span class="number">80</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">10243</span>-&gt;<span class="number">1024</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">50443</span>-&gt;<span class="number">5044</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">15602</span>-&gt;<span class="number">5601</span>/tcp   </span><br><span class="line">elk</span><br><span class="line">e08ca55e124d              <span class="number">3306</span>/tcp, <span class="number">6379</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">223</span>-&gt;<span class="number">22</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8082</span>-&gt;<span class="number">80</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">10242</span>-&gt;<span class="number">1024</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">50442</span>-&gt;<span class="number">5044</span>/tcp                            </span><br><span class="line">project2</span><br><span class="line"><span class="number">3</span>b670e7a9ad1              <span class="number">3306</span>/tcp, <span class="number">6379</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">222</span>-&gt;<span class="number">22</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8081</span>-&gt;<span class="number">80</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">10241</span>-&gt;<span class="number">1024</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">50441</span>-&gt;<span class="number">5044</span>/tcp                            </span><br><span class="line">project1</span><br><span class="line">dbefa01b3393              <span class="number">80</span>/tcp, <span class="number">3306</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">221</span>-&gt;<span class="number">22</span>/tcp, <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">63791</span>-&gt;<span class="number">6379</span>/tcp</span><br><span class="line">redis-master</span><br></pre></td></tr></table></figure><blockquote><p>所有服务器关闭防火墙</p><p>将软件和配置文件放在宿主机目录，各个容器就可以共享使用了</p></blockquote><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/elk.png" alt="elk-stach"></p><h2 id="redis-master安装logstash"><a href="#redis-master安装logstash" class="headerlink" title="redis-master安装logstash"></a>redis-master安装logstash</h2><p>服务器安装redis,进行配置,开机启动</p><h2 id="project服务器安装logstash"><a href="#project服务器安装logstash" class="headerlink" title="project服务器安装logstash"></a>project服务器安装logstash</h2><h3 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure><p>###下载logstash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/downloads</span><br><span class="line">mkdir /opt/soft</span><br><span class="line">cd /opt/downloads</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.1.tar.gz</span><br><span class="line">tar -zxvf logstash-6.4.1.tar.gz -C /opt/soft/</span><br></pre></td></tr></table></figure><h3 id="配置logstash"><a href="#配置logstash" class="headerlink" title="配置logstash"></a>配置logstash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/soft/logstash-6.4.0/config/jvm.options</span><br><span class="line"></span><br><span class="line">-Xms2g</span><br><span class="line">-Xmx2g</span><br></pre></td></tr></table></figure><h3 id="安装配置supervisor"><a href="#安装配置supervisor" class="headerlink" title="安装配置supervisor"></a>安装配置supervisor</h3><blockquote><p>参考：<a href="https://blog.csdn.net/donggege214/article/details/80264811" target="_blank" rel="noopener">https://blog.csdn.net/donggege214/article/details/80264811</a></p></blockquote><ul><li><code>vi /etc/supervisord.conf</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/<span class="keyword">var</span>/run/supervisor/supervisor.sock </span><br><span class="line">chmod=<span class="number">0700</span></span><br><span class="line">chown=root:root</span><br><span class="line">[<span class="keyword">include</span>]</span><br><span class="line">files = supervisord.d<span class="comment">/*.conf</span></span><br></pre></td></tr></table></figure><ul><li><code>vi /etc/supervisord/l.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:elk-l]</span><br><span class="line">command=/opt/soft/logstash-6.4.0/bin/logstash -r -f /data/www/elk/conf/project/*.conf</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=root</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/var/log/elk/l.log</span><br><span class="line">priority=10</span><br></pre></td></tr></table></figure><ul><li><code>vi /data/www/elk/conf/project/project.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; [ &quot;/data/www/project-mdl/trunk/Common/Runtime/Apps/*.log&quot; ]</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    ignore_older =&gt; 0</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">    type =&gt; &quot;Api&quot;</span><br><span class="line">    codec =&gt; multiline &#123;</span><br><span class="line">      pattern =&gt; &quot;^\[&quot;</span><br><span class="line">      negate =&gt; true</span><br><span class="line">      what =&gt; &quot;previous&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123; </span><br><span class="line">  if [type] == &quot;Api&quot; &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        host =&gt; &apos;192.168.1.198&apos;</span><br><span class="line">        port =&gt; &apos;63791&apos;</span><br><span class="line">        db =&gt; &apos;1&apos;</span><br><span class="line">        data_type =&gt; &quot;list&quot;</span><br><span class="line">        key =&gt; &quot;project&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启supervisor，如果数据写入redis-master服务器，那么就代表项目日志收集成功</p><h2 id="ELK服务器"><a href="#ELK服务器" class="headerlink" title="ELK服务器"></a>ELK服务器</h2><h3 id="安装java环境-1"><a href="#安装java环境-1" class="headerlink" title="安装java环境"></a>安装java环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java</span><br></pre></td></tr></table></figure><h3 id="安装elk"><a href="#安装elk" class="headerlink" title="安装elk"></a>安装elk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/downloads</span><br><span class="line">mkdir /opt/soft</span><br><span class="line">cd /opt/downloads</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.1.tar.gz</span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.1-linux-x86_64.tar.gz</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.1.tar.gz</span><br><span class="line">tar -zxvf logstash-6.4.1.tar.gz -C /opt/soft/</span><br><span class="line">tar -zxvf elasticsearch-6.4.1.tar.gz -C /opt/soft/</span><br><span class="line">tar -zxvf kibana-6.4.1-linux-x86_64.tar.gz -C /opt/soft/</span><br></pre></td></tr></table></figure><h3 id="配置elk"><a href="#配置elk" class="headerlink" title="配置elk"></a>配置elk</h3><h4 id="创建elastic用户"><a href="#创建elastic用户" class="headerlink" title="创建elastic用户"></a>创建elastic用户</h4><p>由于 Elasticsearch <code>不允许也不推荐使用 root 用户来运行</code>，因此需要新建一个用户来启动 Elasticsearch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser elastic    #创建elastic用户</span><br><span class="line">passwd elastic     #修改elastic密码</span><br></pre></td></tr></table></figure><h4 id="创建ES数据日志文件夹"><a href="#创建ES数据日志文件夹" class="headerlink" title="创建ES数据日志文件夹"></a>创建ES数据日志文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data/www/elk</span><br><span class="line">mkdir data          #创建数据目录</span><br><span class="line">mkdir log           #创建日志目录</span><br><span class="line">mkdir bak           #创建备份目录</span><br><span class="line">chown -R elatic /data/www/elk/  #修改目录拥有者为 elastic</span><br></pre></td></tr></table></figure><h4 id="优化文件句柄数以及用户可用进程数"><a href="#优化文件句柄数以及用户可用进程数" class="headerlink" title="优化文件句柄数以及用户可用进程数"></a>优化文件句柄数以及用户可用进程数</h4><p>新版 Elasticsearch 要求其可用的文件句柄至少为 65536，同时要求其进程数限制至少为 2048，可用按照下面的指令进行修改。</p><p>分别对应以下两个报错信息：</p><ol><li>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]；</li><li>max number of threads [1024] for user [es] is too low, increase to at least [2048]。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">*     soft   nofile  655350</span><br><span class="line">*     hard   nofile  655350</span><br><span class="line">*     soft   nproc   4096</span><br><span class="line">*     hard   nproc   8192</span><br><span class="line">elastic soft memlock unlimited</span><br><span class="line">elastic hard memlock unlimited</span><br></pre></td></tr></table></figure><h4 id="修改内核交换"><a href="#修改内核交换" class="headerlink" title="修改内核交换"></a>修改内核交换</h4><p>为了避免不必要的磁盘和内存交换，影响效率，需要将 <code>vm.swappiness</code> 修改为 1。</p><p>此外需要修改最大虚拟内存 <code>vm.max_map_count</code> 防止启动时报错：<code>max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">vm.swappiness = 1</span><br><span class="line">vm.max_map_count = 655360</span><br><span class="line"></span><br><span class="line">sysctl -p   # 立即生效</span><br></pre></td></tr></table></figure><h4 id="关闭swap并且重启"><a href="#关闭swap并且重启" class="headerlink" title="关闭swap并且重启"></a>关闭swap并且重启</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h4 id="配置-Elasticsearch-内存占用"><a href="#配置-Elasticsearch-内存占用" class="headerlink" title="配置 Elasticsearch 内存占用"></a>配置 Elasticsearch 内存占用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/soft/elasticsearch-6.4.1/config/</span><br><span class="line">vim jvm.options </span><br><span class="line"></span><br><span class="line">-Xms2g</span><br><span class="line">-Xmx2g</span><br></pre></td></tr></table></figure><h4 id="配置-Elasticsearch配置文件"><a href="#配置-Elasticsearch配置文件" class="headerlink" title="配置 Elasticsearch配置文件"></a>配置 Elasticsearch配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@3f139b00a661 ~]# grep -n &apos;^[a-z]&apos; /opt/soft/elasticsearch-6.4.0/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line">17:cluster.name: elk-demo</span><br><span class="line">33:path.data: /data/www/elk/data</span><br><span class="line">37:path.logs: /data/www/logs</span><br><span class="line">43:bootstrap.memory_lock: false</span><br><span class="line">55:network.host: 0.0.0.0</span><br><span class="line">59:http.port: 9200</span><br></pre></td></tr></table></figure><h3 id="安装配置supervisor-1"><a href="#安装配置supervisor-1" class="headerlink" title="安装配置supervisor"></a>安装配置supervisor</h3><ul><li><code>grep -n &#39;^[a-z]&#39; /etc/supervisord.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">4:file=/var/run/supervisor/supervisor.sock   ; (the path to the socket file)</span><br><span class="line">5:chmod=0700                 ; sockef file mode (default 0700)</span><br><span class="line">6:chown=root:root            ; socket file uid:gid owner</span><br><span class="line">16:logfile=/var/log/supervisor/supervisord.log  ; (main log file;default $CWD/supervisord.log)</span><br><span class="line">17:logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</span><br><span class="line">18:logfile_backups=10          ; (num of main logfile rotation backups;default 10)</span><br><span class="line">19:loglevel=info               ; (log level;default info; others: debug,warn,trace)</span><br><span class="line">20:pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</span><br><span class="line">21:nodaemon=false              ; (start in foreground if true;default false)</span><br><span class="line">22:minfds=1024                 ; (min. avail startup file descriptors;default 1024)</span><br><span class="line">23:minprocs=200                ; (min. avail process descriptors;default 200)</span><br><span class="line">37:supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line">40:serverurl=unix:///var/run/supervisor/supervisor.sock ; use a unix:// URL  for a unix socket</span><br><span class="line">129:files = /etc/supervisord.d/elk.conf</span><br></pre></td></tr></table></figure><ul><li><code>grep &#39;^[a-z]&#39; /etc/supervisord.d/elk.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">command=/opt/soft/elasticsearch-6.4.0/bin/elasticsearch</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=elastic</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/var/log/elk/e.log</span><br><span class="line">priority=1</span><br><span class="line">command=/opt/soft/logstash-6.4.0/bin/logstash -r -f /data/www/elk/conf/elk/*.conf</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=elastic</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/var/log/elk/l.log</span><br><span class="line">priority=10</span><br><span class="line">command=/opt/soft/kibana-6.4.0-linux-x86_64/bin/kibana</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=elastic</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/var/log/elk/k.log</span><br><span class="line">priority=20</span><br></pre></td></tr></table></figure><ul><li><code>cat /data/www/elk/conf/elk/elk.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">        host =&gt; &apos;192.168.1.198&apos;</span><br><span class="line">        port =&gt;  63791</span><br><span class="line">        db =&gt; 1</span><br><span class="line">        data_type =&gt; &quot;list&quot;</span><br><span class="line">        key =&gt; &quot;project&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  stdin &#123;</span><br><span class="line">    codec =&gt; multiline &#123;</span><br><span class="line">      pattern =&gt; &quot;^\[&quot;</span><br><span class="line">      negate =&gt; true</span><br><span class="line">      what =&gt; &quot;previous&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123; </span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [ &quot;127.0.0.1:9200&quot; ] </span><br><span class="line">      index =&gt; &quot;project&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理</title>
      <link href="/2017/06/12/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2017/06/12/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理是一个位于<strong>客户端和目标服务器之间的代理服务器（中间服务器）</strong>。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="访问形式区分："><a href="#访问形式区分：" class="headerlink" title="访问形式区分："></a>访问形式区分：</h2><p>正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；<br>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；<br>反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。<br>反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。<br>从上面的描述也能看得出来正向代理和反向代理最关键的两点区别：</p><ol><li>是否指定目标服务器</li><li>客户端是否要做设置<br><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/%E4%BB%A3%E7%90%86.jpeg" alt="代理"><br>正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。<h2 id="用途上来区分："><a href="#用途上来区分：" class="headerlink" title="用途上来区分："></a>用途上来区分：</h2>正向代理：正向代理用途是为了在防火墙内的局域网提供访问internet的途径。另外还可以使用缓冲特性减少网络使用率<br>反向代理：反向代理的用途是将防火墙后面的服务器提供给internet用户访问。同时还可以完成诸如负载均衡等功能<h2 id="从安全性来讲："><a href="#从安全性来讲：" class="headerlink" title="从安全性来讲："></a>从安全性来讲：</h2>正向代理：正向代理允许客户端通过它访问任意网站并且隐蔽客户端自身，因此你必须采取安全措施来确保仅为经过授权的客户端提供服务<br>反向代理：对外是透明的，访问者并不知道自己访问的是代理。对访问者而言，他以为访问的就是原始服务器<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="正向代理-1"><a href="#正向代理-1" class="headerlink" title="正向代理"></a>正向代理</h2>从上面的介绍也就可以猜出来正向代理的至少一个功能（俗称翻墙），也即：</li></ol><p>用户A无法访问facebook，但是能访问服务器B，而服务器B可以访问facebook。于是用户A访问服务器B，通过服务器B去访问facebook，，服务器B收到请求后，去访问facebook，facebook把响应信息返回给服务器B，服务器B再把响应信息返回给A。这样，通过代理服务器B，就实现了翻墙。</p><h2 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h2><p>从上面的介绍也可以猜出来反向代理的至少一个功能（比如负载均衡），也即：</p><p>假设用户A访问 <a href="http://www.somesite.com/something.html，但www.somesite.com上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。" target="_blank" rel="noopener">http://www.somesite.com/something.html，但www.somesite.com上并不存在something.html页面，于是接收用户请求的该服务器就偷偷从另外一台服务器上取回来，然后返回给用户，而用户并不知道something.html页面究竟位于哪台机器上。</a></p><p>反向代理的作用就比较多了，这里简单列举一下：</p><ul><li>保护和隐藏原始资源服务器</li><li>加密和SSL加速</li><li>负载均衡</li></ul><ul><li>缓存静态内容</li><li>压缩</li><li>减速上传</li><li>安全</li><li>外网发布</li></ul><p>下面做两个简单介绍</p><h3 id="保护和隐藏原始资源服务器"><a href="#保护和隐藏原始资源服务器" class="headerlink" title="保护和隐藏原始资源服务器"></a>保护和隐藏原始资源服务器</h3><p><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/%E4%BF%9D%E6%8A%A4%E5%92%8C%E9%9A%90%E8%97%8F%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8.jpeg" alt="保护和隐藏原始资源服务器"><br>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><img src="https://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpeg" alt="负载均衡"><br>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理比较类似正向代理的功能，差别在于客户端根本不知道代理的存在，它改编你的request，并会传送真实IP（使用场景就是公司限制网络的访问）。</p><p>比如为了工作效率或者安全，A公司屏蔽了QQ软件的使用。A公司的员工接上了网络，但发现无法使用qq。这就是透明代理捣的鬼。公司在内网和外网的中间插入一个透明代理，这个代理会根据规则抓取请求内容，遇到qq的请求我就把这个请求给屏蔽掉，这样就完成了透明屏蔽。当然了，如果你明白原理，就可以自己搞个正向代理来绕过公司的屏蔽。</p>]]></content>
      
      
      <categories>
          
          <category> CentOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-控制反转及其依赖注入(番外篇)</title>
      <link href="/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%89/"/>
      <url>/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上面有2篇文章介绍了PHP依赖注入和控制反转的概念和实例,为了加深理解才有这篇文章。</p><p>首先,我们假设,我们要开发一个组件命名为SomeComponent.这个组件中现在要注入一个数据库连接。<br>在这个例子中,数据库连接在component中被创建,这种方法不可取,这样做的话,我们将不能改变数据库连接参数及数据库类型等一些参数。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * The instantiation of the connection is hardcoded inside</span><br><span class="line">     * the component so is difficult to replace it externally</span><br><span class="line">     * or change its behavior</span><br><span class="line">     */</span><br><span class="line">    public function someDbTask()</span><br><span class="line">    &#123;</span><br><span class="line">        $connection = new Connection(array(</span><br><span class="line">            &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">            &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">            &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">            &quot;dbname&quot; =&gt; &quot;invo&quot;</span><br><span class="line">        ));</span><br><span class="line"> </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$some = new SomeComponent();</span><br><span class="line">$some-&gt;someDbTask();</span><br></pre></td></tr></table></figure><p>为了解决上面所说的问题,我们需要在使用前创建一个外部连接,并注入到容器中。就目前而言,这看起来是一个很好的解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    protected $_connection;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Sets the connection externally</span><br><span class="line">     */</span><br><span class="line">    public function setConnection($connection)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;_connection = $connection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function someDbTask()</span><br><span class="line">    &#123;</span><br><span class="line">        $connection = $this-&gt;_connection;</span><br><span class="line"> </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$some = new SomeComponent();</span><br><span class="line"> </span><br><span class="line">//Create the connection</span><br><span class="line">$connection = new Connection(array(</span><br><span class="line">    &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">    &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">    &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">    &quot;dbname&quot; =&gt; &quot;invo&quot;</span><br><span class="line">));</span><br><span class="line"> </span><br><span class="line">//Inject the connection in the component</span><br><span class="line">$some-&gt;setConnection($connection);</span><br><span class="line"> </span><br><span class="line">$some-&gt;someDbTask();</span><br></pre></td></tr></table></figure><p>现在我们来考虑一个问题,我们在应用程序中的不同地方使用此组件,将多次创建数据库连接。使用一种类似全局注册表的方式,从这获得一个数据库连接实例,而不是使用一次就创建一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class Registry</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Returns the connection</span><br><span class="line">     */</span><br><span class="line">    public static function getConnection()</span><br><span class="line">    &#123;</span><br><span class="line">       return new Connection(array(</span><br><span class="line">            &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">            &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">            &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">            &quot;dbname&quot; =&gt; &quot;invo&quot;</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    protected $_connection;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Sets the connection externally</span><br><span class="line">     */</span><br><span class="line">    public function setConnection($connection)&#123;</span><br><span class="line">        $this-&gt;_connection = $connection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function someDbTask()</span><br><span class="line">    &#123;</span><br><span class="line">        $connection = $this-&gt;_connection;</span><br><span class="line"> </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$some = new SomeComponent();</span><br><span class="line"> </span><br><span class="line">//Pass the connection defined in the registry</span><br><span class="line">$some-&gt;setConnection(Registry::getConnection());</span><br><span class="line"> </span><br><span class="line">$some-&gt;someDbTask();</span><br></pre></td></tr></table></figure><p>现在,让我们来想像一下,我们必须在组件中实现两个方法,首先需要创建一个新的数据库连接,第二个总是获得一个共享连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class Registry</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    protected static $_connection;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Creates a connection</span><br><span class="line">     */</span><br><span class="line">    protected static function _createConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        return new Connection(array(</span><br><span class="line">            &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">            &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">            &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">            &quot;dbname&quot; =&gt; &quot;invo&quot;</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 单例模式</span><br><span class="line">     * Creates a connection only once and returns it</span><br><span class="line">     */</span><br><span class="line">    public static function getSharedConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        if (self::$_connection===null)&#123;</span><br><span class="line">            $connection = self::_createConnection();</span><br><span class="line">            self::$_connection = $connection;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$_connection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Always returns a new connection</span><br><span class="line">     */</span><br><span class="line">    public static function getNewConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        return self::_createConnection();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    protected $_connection;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Sets the connection externally</span><br><span class="line">     */</span><br><span class="line">    public function setConnection($connection)&#123;</span><br><span class="line">        $this-&gt;_connection = $connection;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * This method always needs the shared connection</span><br><span class="line">     */</span><br><span class="line">    public function someDbTask()</span><br><span class="line">    &#123;</span><br><span class="line">        $connection = $this-&gt;_connection;</span><br><span class="line"> </span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * This method always needs a new connection</span><br><span class="line">     */</span><br><span class="line">    public function someOtherDbTask($connection)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$some = new SomeComponent();</span><br><span class="line"> </span><br><span class="line">//This injects the shared connection</span><br><span class="line">$some-&gt;setConnection(Registry::getSharedConnection());</span><br><span class="line"> </span><br><span class="line">$some-&gt;someDbTask();</span><br><span class="line"> </span><br><span class="line">//Here, we always pass a new connection as parameter</span><br><span class="line">$some-&gt;someOtherDbTask(Registry::getConnection());</span><br></pre></td></tr></table></figure></p><p>到此为止,我们已经看到了如何使用依赖注入解决我们的问题。不是在代码内部创建依赖关系,而是让其作为一个参数传递,这使得我们的程序更容易维护,降低程序代码的耦合度,实现一种松耦合。但是从长远来看,这种形式的依赖注入也有一些缺点。</p><p>例如,如果组件中有较多的依赖关系,我们需要创建多个setter方法传递,或创建构造函数进行传递。另外,每次使用组件时,都需要创建依赖组件,使代码维护不太易,我们编写的代码可能像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">//Create the dependencies or retrieve them from the registry</span><br><span class="line">$connection = new Connection();</span><br><span class="line">$session = new Session();</span><br><span class="line">$fileSystem = new FileSystem();</span><br><span class="line">$filter = new Filter();</span><br><span class="line">$selector = new Selector();</span><br><span class="line"> </span><br><span class="line">//Pass them as constructor parameters</span><br><span class="line">$some = new SomeComponent($connection, $session, $fileSystem, $filter, $selector);</span><br><span class="line"> </span><br><span class="line">// ... or using setters</span><br><span class="line"> </span><br><span class="line">$some-&gt;setConnection($connection);</span><br><span class="line">$some-&gt;setSession($session);</span><br><span class="line">$some-&gt;setFileSystem($fileSystem);</span><br><span class="line">$some-&gt;setFilter($filter);</span><br><span class="line">$some-&gt;setSelector($selector);</span><br></pre></td></tr></table></figure><p> 我想,我们不得不在应用程序的许多地方创建这个对象。如果你不需要依赖的组件后,我们又要去代码注入部分移除构造函数中的参数或者是setter方法。为了解决这个问题,我们再次返回去使用一个全局注册表来创建组件。但是,在创建对象之前,它增加了一个新的抽象层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    // ...</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Define a factory method to create SomeComponent instances injecting its dependencies</span><br><span class="line">     */</span><br><span class="line">    public static function factory()</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        $connection = new Connection();</span><br><span class="line">        $session = new Session();</span><br><span class="line">        $fileSystem = new FileSystem();</span><br><span class="line">        $filter = new Filter();</span><br><span class="line">        $selector = new Selector();</span><br><span class="line"> </span><br><span class="line">        return new self($connection, $session, $fileSystem, $filter, $selector);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这一刻,我们好像回到了问题的开始,我们正在创建组件内部的依赖,我们每次都在修改以及找寻一种解决问题的办法,但这都不是很好的做法。</p><p>一种实用和优雅的来解决这些问题,是使用<strong>容器的依赖注入</strong>,像我们在前面看到的,容器作为全局注册表,使用容器的依赖注入做为一种桥梁来解决依赖可以使我们的代码耦合度更低,很好的降低了组件的复杂性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">class SomeComponent</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    protected $_di;</span><br><span class="line"> </span><br><span class="line">    public function __construct($di)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;_di = $di;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function someDbTask()</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        // Get the connection service</span><br><span class="line">        // Always returns a new connection</span><br><span class="line">        $connection = $this-&gt;_di-&gt;get(&apos;db&apos;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function someOtherDbTask()</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        // Get a shared connection service,</span><br><span class="line">        // this will return the same connection everytime</span><br><span class="line">        $connection = $this-&gt;_di-&gt;getShared(&apos;db&apos;);</span><br><span class="line"> </span><br><span class="line">        //This method also requires a input filtering service</span><br><span class="line">        $filter = $this-&gt;_db-&gt;get(&apos;filter&apos;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$di = new Phalcon\DI();</span><br><span class="line"> </span><br><span class="line">//Register a &quot;db&quot; service in the container</span><br><span class="line">$di-&gt;set(&apos;db&apos;, function()&#123;</span><br><span class="line">    return new Connection(array(</span><br><span class="line">        &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">        &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">        &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">        &quot;dbname&quot; =&gt; &quot;invo&quot;</span><br><span class="line">    ));</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//Register a &quot;filter&quot; service in the container</span><br><span class="line">$di-&gt;set(&apos;filter&apos;, function()&#123;</span><br><span class="line">    return new Filter();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//Register a &quot;session&quot; service in the container</span><br><span class="line">$di-&gt;set(&apos;session&apos;, function()&#123;</span><br><span class="line">    return new Session();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//Pass the service container as unique parameter</span><br><span class="line">$some = new SomeComponent($di);</span><br><span class="line"> </span><br><span class="line">$some-&gt;someTask();</span><br></pre></td></tr></table></figure><p>现在,该组件只有访问某种service的时候才需要它,如果它不需要,它甚至不初始化,以节约资源。该组件是高度解耦。他们的行为,或者说他们的任何其他方面都不会影响到组件本身。我们的实现办法 Phalcon\DI 是一个实现了服务的依赖注入功能的组件,它本身也是一个容器。由于Phalcon高度解耦,Phalcon\DI 是框架用来集成其他组件的必不可少的部分,开发人员也可以使用这个组件依赖注入和管理应用程序中不同类文件的实例。</p><p>基本上,这个组件实现了 Inversion of Control 模式。基于此,对象不再以构造函数接收参数或者使用setter的方式来实现注入,而是直接请求服务的依赖注入。这就大大降低了整体程序的复杂性,因为只有一个方法用以获得所需要的一个组件的依赖关系。</p><p>此外,这种模式增强了代码的可测试性,从而使它不容易出错。在容器中注册服务框架本身或开发人员都可以注册服务。当一个组件A要求调用组件B(或它的类的一个实例),可以从容器中请求调用组件B,而不是创建组件B的一个实例。</p><p>这种工作方式为我们提供了许多优点：</p><ul><li><p>我们可以更换一个组件,从他们本身或者第三方轻松创建。</p></li><li><p>在组件发布之前,我们可以充分的控制对象的初始化,并对对象进行各种设置。</p></li><li><p>我们可以使用统一的方式从组件得到一个结构化的全局实例</p></li></ul><p>服务可以通过以下几种方式注入到容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">//Create the Dependency Injector Container</span><br><span class="line">$di = new Phalcon\DI();</span><br><span class="line"> </span><br><span class="line">//By its class name</span><br><span class="line">$di-&gt;set(&quot;request&quot;, &apos;Phalcon\Http\Request&apos;);</span><br><span class="line"> </span><br><span class="line">//Using an anonymous function, the instance will lazy loaded</span><br><span class="line">$di-&gt;set(&quot;request&quot;, function()&#123;</span><br><span class="line">    return new Phalcon\Http\Request();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//Registering directly an instance</span><br><span class="line">$di-&gt;set(&quot;request&quot;, new Phalcon\Http\Request());</span><br><span class="line"> </span><br><span class="line">//Using an array definition</span><br><span class="line">$di-&gt;set(&quot;request&quot;, array(</span><br><span class="line">    &quot;className&quot; =&gt; &apos;Phalcon\Http\Request&apos;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>在上面的例子中,当向框架请求访问一个请求数据时,它将首先确定容器中是否存在这个”reqeust”名称的服务。容器会反回一个请求数据的实例,开发人员最终得到他们想要的组件。</p><p>在上面示例中的每一种方法都有优缺点,具体使用哪一种,由开发过程中的特定场景来决定的。用一个字符串来设定一个服务非常简单,但<strong>缺少灵活性</strong>。设置服务时,使用数组则提供了更多的灵活性,而且可以使<strong>用较复杂的代码</strong>。lambda函数是两者之间一个很好的平衡,但也可能导致更多的维护管理成本。</p><p>Phalcon\DI 提供服务的延迟加载。除非开发人员在注入服务的时候直接实例化一个对象,然后存存储到容器中。在容器中,通过数组,字符串等方式存储的服务都将被延迟加载,即只有在请求对象的时候才被初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">//Register a service &quot;db&quot; with a class name and its parameters</span><br><span class="line">$di-&gt;set(&quot;db&quot;, array(</span><br><span class="line">    &quot;className&quot; =&gt; &quot;Phalcon\Db\Adapter\Pdo\Mysql&quot;,</span><br><span class="line">    &quot;parameters&quot; =&gt; array(</span><br><span class="line">          &quot;parameter&quot; =&gt; array(</span><br><span class="line">               &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">               &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">               &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">               &quot;dbname&quot; =&gt; &quot;blog&quot;</span><br><span class="line">          )</span><br><span class="line">    )</span><br><span class="line">));</span><br><span class="line"> </span><br><span class="line">//Using an anonymous function</span><br><span class="line">$di-&gt;set(&quot;db&quot;, function()&#123;</span><br><span class="line">    return new Phalcon\Db\Adapter\Pdo\Mysql(array(</span><br><span class="line">         &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">         &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">         &quot;password&quot; =&gt; &quot;secret&quot;,</span><br><span class="line">         &quot;dbname&quot; =&gt; &quot;blog&quot;</span><br><span class="line">    ));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上这两种服务的注册方式产生相同的结果。然后,通过数组定义的,在后面需要的时候,你可以修改服务参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> </span><br><span class="line">$di-&gt;setParameter(&quot;db&quot;, 0, array(</span><br><span class="line">    &quot;host&quot; =&gt; &quot;localhost&quot;,</span><br><span class="line">    &quot;username&quot; =&gt; &quot;root&quot;,</span><br><span class="line">    &quot;password&quot; =&gt; &quot;secret&quot;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>从容器中获得服务的最简单方式就是使用”get”方法,它将从容器中返回一个新的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php    </span><br><span class="line">     $request = $di-&gt;get(&quot;request&quot;);</span><br></pre></td></tr></table></figure><p>或者通过下面这种魔术方法的形式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $request = $di-&gt;getRequest();</span><br><span class="line">    Phalcon\DI //同时允许服务重用,为了得到一个已经实例化过的服务,可以使用 getShared() 方法的形式来获得服务。</span><br></pre></td></tr></table></figure><p>具体的 Phalcon\Http\Request 请求示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $request = $di-&gt;getShared(&quot;request&quot;);</span><br></pre></td></tr></table></figure><p>参数还可以在请求的时候通过将一个数组参数传递给构造函数的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $component = $di-&gt;get(&quot;MyComponent&quot;, array(&quot;some-parameter&quot;, &quot;other&quot;))</span><br></pre></td></tr></table></figure><p>复制完毕,本文引自<a href="http://www.zhaoyafei.cn/content.html?id=42" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-控制反转及其依赖注入(2)</title>
      <link href="/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%882%EF%BC%89/"/>
      <url>/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上节我们介绍了<a href="https://blog.bytesclub.com/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89/" target="_blank" rel="noopener">控制反转及依赖注入的实现</a></p><p>最后在调用测试时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用宝剑的英雄</span><br><span class="line">$class = new Hero(new Gun(&apos;倚天&apos;));</span><br><span class="line">$class-&gt;myWeapon();</span><br><span class="line">//我的倚天打起来唰唰唰~</span><br><span class="line">//用枪的英雄</span><br><span class="line">$class = new Hero(new Sword(&apos;沙漠之鹰&apos;));</span><br><span class="line">$class-&gt;myWeapon();</span><br><span class="line">//我的沙漠之鹰打起来砰砰砰~</span><br></pre></td></tr></table></figure><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>我们看到,注入时需要实例化好所依赖的对象,再传到Hero类中,虽然通过依赖注入解决了解耦问题,但是在实际使用中,比较麻烦,因为每次都需要手动实例化依赖,再传递,这对于复杂大量的依赖关系,手动解决明显力不从心。因此,项目中需要一个自动化的依赖注入管理机制,<strong>这就是IoC容器</strong>;</p><blockquote><p>IoC容器：一个封装了依赖注入DI的框架,实现了动态创建注入依赖对象,管理依赖关系,管理对象声明周期等功能</p></blockquote><p><strong>核心实现</strong>,一般分为<strong>绑定(注册)对象生成器</strong>和<strong>创建对象注入依赖</strong>这两个核心步骤</p><a id="more"></a><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><hr><h2 id="绑定-注册-对象生成器"><a href="#绑定-注册-对象生成器" class="headerlink" title="绑定(注册)对象生成器"></a>绑定(注册)对象生成器</h2><p>绑定：指的是将类于生成类对象的代码记录,对应,绑定起来。这样,在需要该类对象时,直接执行类对应的生成代码,就可以得到所需的对象;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 绑定类的生成器</span><br><span class="line">     *</span><br><span class="line">     * @param $className 类名或者映射名,类的标志</span><br><span class="line">     * @param $generator 对应实例化或者可生成此类对象的代码</span><br><span class="line">     *</span><br><span class="line">     * @throws \Exception</span><br><span class="line">     *</span><br><span class="line">     * @author mma5694@gmail.com</span><br><span class="line">     * @date   2017年5月7日00:42:02</span><br><span class="line">     */</span><br><span class="line">    public static function bind($className, $generator)</span><br><span class="line">    &#123;</span><br><span class="line">        //检测参数是否为合法的可调用结构</span><br><span class="line">        if (is_callable($generator)) &#123;</span><br><span class="line">            self::$generatorList[$className] = $generator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new \Exception(&apos;对象生成器不是可调用的结构！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意bind方法,就是上面说的绑定(注册)对象生成器的实现,一般bind方法需要两个参数：</p><ul><li>第一个就是类的标志,通常就是带有命名空间的类名称,也可以是自定义的类对应标志</li><li>第二个参数是一个<a href="https://blog.bytesclub.com/2017/05/07/PHP%E4%B8%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">匿名函数</a>,也就是生成器,执行new的代码,这个参数可以是匿名函数、函数、类方法或者其他可执行的结构都是可以的</li></ul><p>这样其实就是要用户提供类和该类对象的生成代码,将其对应,需要该类对象时再执行,但是注册时,并不调用生成类的代码,而仅仅时先存储起来(真精妙呀)。下面的例子就是将生成器代码存储到$generatorList数组中;</p><p>容器绑定对象生成器示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use ClassFile\Hero;</span><br><span class="line">use IImplements\Sword;</span><br><span class="line">use IImplements\Gun;</span><br><span class="line"></span><br><span class="line">//这里我第一个参数用的不带命名空间的类名</span><br><span class="line">IoContainer::bind(&apos;Gun&apos;, function ($title = &apos;&apos;) &#123;</span><br><span class="line">    return new Gun($title);</span><br><span class="line">&#125;);</span><br><span class="line">IoContainer::bind(&apos;Sword&apos;, function ($title = &apos;&apos;) &#123;</span><br><span class="line">    return new Sword($title);</span><br><span class="line">&#125;);</span><br><span class="line">IoContainer::bind(&apos;Hero&apos;, function ($module, $params = []) &#123;</span><br><span class="line">    return new Hero(IoContainer::make($module, $params));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用bind()方法,提供类名和实例化类对象的匿名函数,我们的容器就会将类与生成器记录下来,等着需要时实例化生成所需对象</p><h2 id="创建对象注入依赖"><a href="#创建对象注入依赖" class="headerlink" title="创建对象注入依赖"></a>创建对象注入依赖</h2><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>先看看完善后的IoContainer类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class IoContainer</span><br><span class="line">&#123;</span><br><span class="line">    //定义存放类的容器？</span><br><span class="line">    protected static $generatorList = [];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 绑定类的生成器</span><br><span class="line">     *</span><br><span class="line">     * @param $className 类名或者映射名,类的标志</span><br><span class="line">     * @param $generator 对应实例化或者可生成此类对象的代码</span><br><span class="line">     *</span><br><span class="line">     * @throws \Exception</span><br><span class="line">     *</span><br><span class="line">     * @author mma5694@gmail.com</span><br><span class="line">     * @date   2017年5月7日00:42:02</span><br><span class="line">     */</span><br><span class="line">    public static function bind($className, $generator)</span><br><span class="line">    &#123;</span><br><span class="line">        //检测参数是否为合法的可调用结构</span><br><span class="line">        if (is_callable($generator)) &#123;</span><br><span class="line">            self::$generatorList[$className] = $generator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new \Exception(&apos;对象生成器不是可调用的结构！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成类的对象</span><br><span class="line">     *</span><br><span class="line">     * @param       $className</span><br><span class="line">     * @param array $param</span><br><span class="line">     *</span><br><span class="line">     * @return mixed</span><br><span class="line">     * @throws \Exception</span><br><span class="line">     *</span><br><span class="line">     * @author mma5694@gmail.com</span><br><span class="line">     * @date   2017年5月7日00:46:00</span><br><span class="line">     */</span><br><span class="line">    public static function make($className, $param = [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$generatorList[$className])) &#123;</span><br><span class="line">            throw new \Exception(&apos;类还没有绑定注册！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return call_user_func_array(self::$generatorList[$className], $param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的make方法就是用来生成对象的方法,该方法要获取所需的类,然后调用绑定时的生成器函数,来获取对象</p><p>通过make生成类对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$hero1 = IoContainer::make(&apos;Hero&apos;,[&apos;Sword&apos;,[&apos;屠龙刀&apos;]]);</span><br><span class="line">$hero1-&gt;myWeapon(); //我的屠龙刀打起来唰唰唰~</span><br><span class="line">$hero2 = IoContainer::make(&apos;Hero&apos;,[&apos;Gun&apos;,[&apos;AK-47&apos;]]);</span><br><span class="line">$hero2-&gt;myWeapon(); //我的AK-47打起来砰砰砰~</span><br></pre></td></tr></table></figure><h3 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h3><p>我们将所有的映射一一对应写入一个配置文件中,在容器类的构造方法中,引入配置文件中的所有对应关系,自动完成绑定(注册)对象生成器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config.php </span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line">    &apos;Sword&apos;=&gt;function($title=&apos;&apos;)&#123;return new \IImplements\Sword($title);&#125;,</span><br><span class="line">    &apos;Gun&apos;=&gt;function($title=&apos;&apos;)&#123;return new \IImplements\Gun($title);&#125;,</span><br><span class="line">    &apos;Hero&apos;=&gt;function($module,$params = [])&#123;return new \ClassFile\Hero(IoContainer\IoContainer::make($module,$params));&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class IoContainer</span><br><span class="line">&#123;</span><br><span class="line">    //定义存放类的容器？</span><br><span class="line">    protected static $generatorList = [];</span><br><span class="line"></span><br><span class="line">    //配置文件注册</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $config = dirname(dirname(__FILE__)) . &quot;/Config/config.php&quot;;</span><br><span class="line">        $config = include $config;</span><br><span class="line">        foreach ($config as $key =&gt; $value) &#123;</span><br><span class="line">            if (is_callable($value)) &#123;</span><br><span class="line">                self::$generatorList[$key] = $value;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new \Exception(&apos;对象生成器不是可调用的结构！&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定类的生成器</span><br><span class="line">     *</span><br><span class="line">     * @param $className 类名或者映射名,类的标志</span><br><span class="line">     * @param $generator 对应实例化或者可生成此类对象的代码</span><br><span class="line">     *</span><br><span class="line">     * @throws \Exception</span><br><span class="line">     *</span><br><span class="line">     * @author mma5694@gmail.com</span><br><span class="line">     * @date   2017年5月7日00:42:02</span><br><span class="line">     */</span><br><span class="line">    public static function bind($className, $generator)</span><br><span class="line">    &#123;</span><br><span class="line">        //检测参数是否为合法的可调用结构</span><br><span class="line">        if (is_callable($generator)) &#123;</span><br><span class="line">            self::$generatorList[$className] = $generator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new \Exception(&apos;对象生成器不是可调用的结构！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成类的对象</span><br><span class="line">     *</span><br><span class="line">     * @param       $className</span><br><span class="line">     * @param array $param</span><br><span class="line">     *</span><br><span class="line">     * @return mixed</span><br><span class="line">     * @throws \Exception</span><br><span class="line">     *</span><br><span class="line">     * @author mma5694@gmail.com</span><br><span class="line">     * @date   2017年5月7日00:46:00</span><br><span class="line">     */</span><br><span class="line">    public static function make($className, $param = [])</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isset(self::$generatorList[$className])) &#123;</span><br><span class="line">            throw new \Exception(&apos;类还没有绑定注册！&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return call_user_func_array(self::$generatorList[$className], $param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就当调用容器类时,会自动绑定(注册)生成器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$container = new IoContainer();</span><br><span class="line">$hero1 = IoContainer::make(&apos;Hero&apos;,[&apos;Sword&apos;,[&apos;屠龙刀&apos;]]);</span><br><span class="line">$hero1-&gt;myWeapon(); //我的屠龙刀打起来唰唰唰~</span><br><span class="line">$hero2 = IoContainer::make(&apos;Hero&apos;,[&apos;Gun&apos;,[&apos;AK-47&apos;]]);</span><br><span class="line">$hero2-&gt;myWeapon(); //我的AK-47打起来砰砰砰~</span><br></pre></td></tr></table></figure><p>这样也是可以的;</p><p>上面的例子就完成了IoC容器的两个基本步骤：绑定和创建</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr><p>理解了什么是IoC容器, 本文的目的就达到了. 实际使用中(例如laravel)IoC容器的方法会有很多, 例如绑定构造器, 绑定对象实例, 绑定单例, 绑定接口实现等. 具体的使用就要到具体的框架或者产品中应用了</p><p>本文示例代码<a href="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/IoCDI%282%29.zip" target="_blank" rel="noopener">在这里</a>,引用参考文章地址<a href="http://www.hellokang.net/tag/ioc%E5%AE%B9%E5%99%A8/" target="_blank" rel="noopener">在这里</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-控制反转及其依赖注入(1)</title>
      <link href="/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89/"/>
      <url>/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%8F%8A%E5%85%B6%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>IoC:Inversion of Control 控制反转</p><p>DI：Dependency Injection 依赖注入</p><h1 id="IoC与DI"><a href="#IoC与DI" class="headerlink" title="IoC与DI"></a>IoC与DI</h1><hr><a id="more"></a><p>先记住这句话：<strong>IoC是设计模式,而DI是IoC控制反转设计模式的典型实现</strong></p><p>IoC控制反转是一种设计模式,用来解决对象间的过度依赖问题。</p><p>解决思路是：设法不在依赖对象中去获取(new)被依赖对象,最典型的的实现方式就是DI依赖注入了。</p><blockquote><p>将对象所依赖的其他对象,在类外部生成好之后,传递到类内部的,而不是在类的内部实例化。这种解决依赖的方法就是DI依赖注入。</p></blockquote><p>例如：对象Hero依赖对象Sword,我们可以选择如下定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 英雄依赖宝剑的定义实现</span><br><span class="line">class Sword</span><br><span class="line">&#123;</span><br><span class="line">    private $title;</span><br><span class="line">    public function __construct($title)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;title = $title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hero</span><br><span class="line">&#123;</span><br><span class="line">    private $weapon;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        // Hero依赖Sword</span><br><span class="line">        $this-&gt;weapon = new Sword(&apos;倚天剑&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中,Hero类对象就依赖Sword对象,但是在此例子中,Hero类对象对于Sword类对象的依赖就比较严重,一旦这个Hero使用的不再是Sword,而是Gun了,Hero的内部方法就要重写,在复杂的程序中,是不可取得,需要降低Hero对武器(无论是Sword或者Gun亦或者是其他武器)的直接依赖</p><p>解决思路就是设法不在依赖对象中去获取需要依赖的对象,这种思路就是IoC控制反转。</p><p>把原来本应在类(对象)内部完成的依赖,设法在类(对象)外部完成,这个由内到外的转化过程就是反转</p><p>所以：<strong>IoC反转最典型的实现方式就是依赖注入DI</strong>,如下代码所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 武器接口</span><br><span class="line"> * Interface Weapon</span><br><span class="line"> */</span><br><span class="line">interface Weapon</span><br><span class="line">&#123;</span><br><span class="line">    public function __construct($title);</span><br><span class="line">    /**</span><br><span class="line">     * 进攻</span><br><span class="line">     */</span><br><span class="line">    public function attack();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 宝剑类</span><br><span class="line"> */</span><br><span class="line">class Sword implements Weapon</span><br><span class="line">&#123;</span><br><span class="line">    protected $title;</span><br><span class="line">    public function __construct($title)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;title = $title;</span><br><span class="line">    &#125;</span><br><span class="line">    public function attack()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;我的&#123;$this-&gt;title&#125;打起来唰唰唰~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 枪类</span><br><span class="line"> */</span><br><span class="line">class Gun implements Weapon</span><br><span class="line">&#123;</span><br><span class="line">    protected $title;</span><br><span class="line">    public function __construct($title)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;title = $title;</span><br><span class="line">    &#125;</span><br><span class="line">    public function attack()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;我的&#123;$this-&gt;title&#125;打起来砰砰砰~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Hero</span><br><span class="line">&#123;</span><br><span class="line">    private $weapon;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * 构造方法的参数是一个对象,通过类型约束限制必须为实现Weapon武器接口的对象</span><br><span class="line">     * 在构造方法中,直接将参数传递进来的武器对象赋值到当前对象的属性上</span><br><span class="line">     * 这样,英雄Hero依赖的对象不是在Hero类的内部实例化,而是在外部实例化好,传递到Hero内部的</span><br><span class="line">     *</span><br><span class="line">     * 这就是《依赖注入》,通俗来讲,就是所依赖的对象在外部生成好之后,传递到类内内部的,而不是在</span><br><span class="line">     * 类内部实例化,这种解决依赖的方法就是DI依赖注入</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * Hero constructor。</span><br><span class="line">     *</span><br><span class="line">     * @param Weapon $weapon</span><br><span class="line">     */</span><br><span class="line">    public function __construct(Weapon $weapon)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;weapon = $weapon;</span><br><span class="line">    &#125;</span><br><span class="line">    public function myWeapon()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;weapon-&gt;attack();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用宝剑的英雄</span><br><span class="line">$class = new Hero(new Gun(&apos;倚天&apos;));</span><br><span class="line">$class-&gt;myWeapon();</span><br><span class="line">//我的倚天打起来唰唰唰~</span><br><span class="line">//用枪的英雄</span><br><span class="line">$class = new Hero(new Sword(&apos;沙漠之鹰&apos;));</span><br><span class="line">$class-&gt;myWeapon();</span><br><span class="line">//我的沙漠之鹰打起来砰砰砰~</span><br></pre></td></tr></table></figure><p>这样,无论Hero需要宝剑还是枪,都可以通过外部注入的方式,将武器传递给Hero对象</p><p>通过构造方法传递参数,是依赖注入最常用的形式,除此之外,还有属性赋值的方法,也可以完成依赖注入,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">class Hero</span><br><span class="line">&#123;</span><br><span class="line">    public $weapon;</span><br><span class="line">&#125;</span><br><span class="line">$hero = new Hero;</span><br><span class="line">$hero-&gt;weapon = new Sword(&apos;倚天&apos;);</span><br></pre></td></tr></table></figure><p>以上就是平时所说的依赖注入,有没有理解呢？</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr><p>解决了什么是依赖注入的问题, 本篇的目的就达到了,(示例代码在<a href="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP/IoCDI%281%29.zip" target="_blank" rel="noopener">这里</a>,本文参考引用<a href="http://www.hellokang.net/2016/11/08/ioc-di/" target="_blank" rel="noopener">这里</a>)<br>但还远远不够 , 注意上面的使用Hero的代码, 我们是手动将实例化好的武器对象作为参数传递给Hero的构造方法的。 此时的问题就是, 当出现大量的, 随机的需要注入的依赖如何处理? 一个个的实例化传递, 是否够自动化?</p><p>要解决这个问题, 就出现了IoC容器。 IoC容器也称为服务容器。 主要就是解决依赖和注入的问题。  实现机制是通过预先将创建对象的代码绑定或注册到IoC容器中,  然后利用该IoC容器创建对象, 在创建对象的过程中, 通过分析对象所需要的依赖(一般利用反射机制), 将注册好的创建对象的代码注入到对象的构造方法中去, 从而完成自动解决这个依赖注入的问题。 非常智能。</p><p>下篇我会接着记录</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/2017/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>title: 计算机基础<br>date: 2018-03-18 23:20:16</p><hr><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述</strong></p><p><strong>一个最最基础的事实</strong>：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。<br><strong>一个必须知道的事实</strong>：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的<strong>程序上下文</strong>。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。<br><strong>串联起来的事实</strong>：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。</p><p> <strong>进程就是包换上下文切换的程序执行时间总和</strong> = <strong>CPU加载上下文+CPU执行+CPU保存上下文</strong><br>进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><p>程序A得到CPU =&gt; CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这<strong>里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</strong></p><hr><p>开个QQ，开了一个进程；开了迅雷，开了一个进程。<br>在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。<br>所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。<br>所以一个进程管着多个线程。<br>通俗的讲：“进程是爹妈，管着众多的线程儿子”…</p><ul><li>一个进程可以包括多个线程</li><li>每个线程可以使用进程的共享内存（互斥锁）</li></ul><hr><p>操作系统的设计，因此可以归结为三点：</p><ol><li>以多进程形式，允许多个任务同时运行；</li><li>以多线程形式，允许单个任务分成不同的部分运行；</li><li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li></ol><h2 id="异步，非阻塞和-IO-复用"><a href="#异步，非阻塞和-IO-复用" class="headerlink" title="异步，非阻塞和 IO 复用"></a>异步，非阻塞和 IO 复用</h2><p><a href="https://segmentfault.com/a/1190000007614502" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007614502</a></p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。</p><p><code>同步</code>: 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。<br><code>异步</code>：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。<br>异步调用，要想获得结果，一般有两种方式</p><blockquote><ol><li>主动轮询异步调用的结果;</li><li>被调用方通过callback来通知调用方调用结果。</li></ol></blockquote><p>demo：<br><code>同步买奶茶</code>：小明点单交钱，然后等着拿奶茶；异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。</p><p><code>异步买奶茶</code>: 小明要想知道奶茶是否做好了，有两种方式：</p><blockquote><ol><li>小明主动去问店员，一会就去问一下：“奶茶做好了吗？”…直到奶茶做好。这叫轮训。</li><li>等奶茶做好了，店员喊一声：“小明，奶茶好了！”，然后小明去取奶茶。这叫回调。</li></ol></blockquote><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。</p><p><code>阻塞调用</code>在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.<br><code>非阻塞</code>调用在发出去后，不会阻塞当前进/线程，而会立即返回。</p><p>demo：<br><code>阻塞买奶茶</code>：小明点单交钱，干等着拿奶茶，什么事都不做；<br><code>非阻塞买奶茶</code>：小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈。</p><p><strong>总结：</strong></p><ul><li>同步与异步，重点在于消息通知的方式;</li><li>阻塞与非阻塞，重点在于等消息时候的行为。</li></ul><p>demo</p><ul><li>同步阻塞：小明在柜台干等着拿奶茶；</li><li>同步非阻塞：小明在柜台边刷微博边等着拿奶茶；</li><li>异步阻塞：小明拿着小票啥都不干，一直等着店员通知他拿奶茶；</li><li>异步非阻塞：小明拿着小票，刷着微博，等着店员通知他拿奶茶。</li></ul><h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p>在一个进程处理所有的并发I/O呢?<br>答案是有的，这就是I/O复用技术。</p><h4 id="最初级的I-O复用"><a href="#最初级的I-O复用" class="headerlink" title="最初级的I/O复用"></a>最初级的I/O复用</h4><p>所谓的I/O复用，就是多个I/O可以复用一个进程。<br>当一个连接过来时，我们不阻塞住，这样一个进程可以同时处理多个连接了。<br>比如一个进程接受了10000个连接，这个进程每次从头到尾的问一遍这10000个连接：“<strong>有I/O事件没？有的话就交给我处理，没有的话我一会再来问一遍。</strong>”<br>然后进程就一直从头到尾问这10000个连接，如果这1000个连接都没有I/O事件，就会造成CPU的空转，并且效率也很低</p><h4 id="升级版的I-O复用"><a href="#升级版的I-O复用" class="headerlink" title="升级版的I/O复用"></a>升级版的I/O复用</h4><p>上面虽然实现了基础版的I/O复用，但是效率太低了。于是伟大的程序猿们日思夜想的去解决这个问题…终于！<br>我们能不能引入一个代理，这个代理可以同时观察许多I/O流事件呢？<br>当没有I/O事件的时候，这个进程处于阻塞状态；当有I/O事件的时候，这个代理就去通知进程醒来？<br>于是，早期的程序猿们发明了两个代理—select、poll。<br>select、poll代理的原理是这样的：</p><blockquote><p>当连接有I/O流事件产生的时候，就会去唤醒进程去处理。</p></blockquote><p>但是进程并不知道是哪个连接产生的I/O流事件，于是进程就挨个去问：“请问是你有事要处理吗？”……问了99999遍，哦，原来是第100000个进程有事要处理。那么，前面这99999次就白问了，白白浪费宝贵的CPU时间片了</p><blockquote><p>注:select与poll原理是一样的，只不过select只能观察1024个连接，poll可以观察无限个连接。</p></blockquote><p>上面看了，select、poll因为不知道哪个连接有I/O流事件要处理，性能也挺不好的。</p><p>那么，如果发明一个代理，每次能够知道哪个连接有了I/O流事件，不就可以避免无意义的空转了吗？</p><p><strong>于是，超级无敌、闪闪发光的epoll被伟大的程序员发明出来了。</strong></p><p>epoll代理的原理是这样的：</p><blockquote><p>当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个进程。</p></blockquote><p>如此，多高效！</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的特性</title>
      <link href="/2017/02/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/"/>
      <url>/2017/02/27/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>来自这里<a href="https://www.cnblogs.com/zhyunfe/p/6398581.html、" target="_blank" rel="noopener">https://www.cnblogs.com/zhyunfe/p/6398581.html、</a></p><p>[TOC]</p><h2 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对事物的封装是指，将事物进行抽象后，提供抽象概念的实现的具体方法。</p><p>PHP也只是三种封装概念：Private，Protected，Public。</p><p><strong>私有/Private</strong><br>私有的概念是，仅仅对象内部可见，外部不可见</p><p><strong>保护/Protected</strong></p><p>保护的概念是，仅仅是自身类和继承类可见，这个关键字的<code>用途主要是防止滥用类的派生</code>，另外三方库编写的时候会用到，防止误用。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承性就是派生类(子类)自动继承一个或多个基类(父类)中的属性与方法，并可以重写或添加新的属性和方法。继承这个特性简化了对象和类的创建，增加了代码的可重性。继承分单继承和多继承，PHP所支持的是单继承，也就是说，一个子类有且只有一个父类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指在面向对象中能够根据使用类的上下文来重新定义或改变类的性质和行为同一个类的不同对象，使用同一个方法可以获得不同的结果。多态性增强了软件的灵活性和重用性。</p><h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><h3 id="单一职责原则SRP-Single-Responsibility-Principle"><a href="#单一职责原则SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则SRP(Single Responsibility Principle)"></a>单一职责原则SRP(Single Responsibility Principle)</h3><p>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</p><h3 id="开放封闭原则OCP-Open－Close-Principle"><a href="#开放封闭原则OCP-Open－Close-Principle" class="headerlink" title="开放封闭原则OCP(Open－Close Principle)"></a>开放封闭原则OCP(Open－Close Principle)</h3><p>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，<br>那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p><h3 id="替换原则-the-Liskov-Substitution-Principle-LSP"><a href="#替换原则-the-Liskov-Substitution-Principle-LSP" class="headerlink" title="替换原则(the Liskov Substitution Principle LSP)"></a>替换原则(the Liskov Substitution Principle LSP)</h3><p>子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，<br>也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p><h3 id="依赖原则-the-Dependency-Inversion-Principle-DIP-具体依赖抽象，上层依赖下层。"><a href="#依赖原则-the-Dependency-Inversion-Principle-DIP-具体依赖抽象，上层依赖下层。" class="headerlink" title="依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。"></a>依赖原则(the Dependency Inversion Principle DIP) 具体依赖抽象，上层依赖下层。</h3><p>假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到<br>了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p><h3 id="接口分离原则-the-Interface-Segregation-Principle-ISP"><a href="#接口分离原则-the-Interface-Segregation-Principle-ISP" class="headerlink" title="接口分离原则(the Interface Segregation Principle ISP)"></a>接口分离原则(the Interface Segregation Principle ISP)</h3><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡实践</title>
      <link href="/2017/02/27/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/02/27/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>引用参考：<a href="https://juejin.im/post/5821c24e570c350060bef4c3" target="_blank" rel="noopener">https://juejin.im/post/5821c24e570c350060bef4c3</a></p><h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><p>windows 下4台服务器，真实机IP：192.168.2.107，其中</p><table><thead><tr><th>服务器</th><th>IP</th><th>说明</th></tr></thead><tbody><tr><td>nginx1</td><td>172.17.0.3</td><td>nginx服务器1</td></tr><tr><td>nginx2</td><td>172.17.0.4</td><td>nginx服务器2</td></tr><tr><td>server1</td><td>172.17.0.5</td><td>服务器1</td></tr><tr><td>server2</td><td>172.17.0.6</td><td>服务器2</td></tr><tr><td>server3</td><td>172.17.0.7</td><td>服务器3</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mma&gt;docker ps</span><br><span class="line">CONTAINER ID        PORTSNAMES</span><br><span class="line">73e6f2096612        6379/tcp, 0.0.0.0:201-&gt;22/tcp, 0.0.0.0:881-&gt;80/tcp, 0.0.0.0:3361-&gt;3306/tcp, 0.0.0.0:9004-&gt;9001/tcp                                           nginx1</span><br><span class="line">805ef8d42fa6        6379/tcp, 0.0.0.0:202-&gt;22/tcp, 0.0.0.0:882-&gt;80/tcp, 0.0.0.0:3362-&gt;3306/tcp, 0.0.0.0:9005-&gt;9001/tcp                                           nginx2</span><br><span class="line">e91b4a662023        6379/tcp, 0.0.0.0:203-&gt;22/tcp, 0.0.0.0:883-&gt;80/tcp, 0.0.0.0:3363-&gt;3306/tcp, 0.0.0.0:9006-&gt;9001/tcp                                           server1</span><br><span class="line">01bb4850cc8c        6379/tcp, 0.0.0.0:204-&gt;22/tcp, 0.0.0.0:884-&gt;80/tcp, 0.0.0.0:3364-&gt;3306/tcp, 0.0.0.0:9007-&gt;9001/tcp                                           server2</span><br><span class="line">e500cbd1efad        6379/tcp, 0.0.0.0:205-&gt;22/tcp, 0.0.0.0:885-&gt;80/tcp, 0.0.0.0:3365-&gt;3306/tcp, 0.0.0.0:9008-&gt;9001/tcpserver3</span><br></pre></td></tr></table></figure><blockquote><p>主要需要暴露http服务端口</p></blockquote><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>我们知道单台服务器的性能是有上限的，当流量很大时，就需要使用多台服务器来共同提供服务，这就是所谓的集群。</p><p>负载均衡服务器，就是用来把经过它的流量，按照某种方法，分配到集群中的各台服务器上。这样一来不仅可以承担更大的流量、降低服务的延迟，还可以避免单点故障造成服务不可用。一般的反向代理服务器，都具备负载均衡的功能。</p><p>负载均衡功能可以由硬件来提供，比如以前的F5设备。也可以由软件来提供，LVS可以提供四层的负载均衡(利用IP和端口)，</p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Nginx/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="负载均衡"></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><h4 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h4><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Nginx/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2.png" alt="加权轮询"></p><blockquote><p>图中有两点需要注意，第一，如果可以把加权轮询算法分为先深搜索和先广搜索，那么nginx采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；第二，当所有后端机器都down掉时，nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态，从而导致整个前端被夯住。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> zhimma &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:883</span> weight=<span class="number">5</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:884</span> weight=<span class="number">6</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:885</span> weight=<span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> zhimma.ma;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>         http://zhimma;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 weight 之外，还有别的配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream phpServers &#123;  </span><br><span class="line">    server 192.168.2.107:883 weight=5 max_fails=1 fail_timeout=20 max_conns=100;</span><br><span class="line">    server 192.168.2.107:883 weight=6 backup down</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>max_fails</strong></p><blockquote><p>默认为1。某台Server允许请求失败的次数，超过最大次数后，在failtimeout时间内，新的请求将不会分配给这台机器。如果设置为0，Nginx会将这台Server置为永久无效状态，然后将请求发给定义了proxynextupstream, fastcginextupstream, uwsginextupstream, scginextupstream, and memcachednext_upstream指令来处理这次错误的请求。</p></blockquote><p><strong>fail_timeout</strong></p><blockquote><p>默认为10秒。某台Server达到maxfails次失败请求后，在failtimeout期间内，nginx会认为这台Server暂时不可用，不会将请求分配给它</p></blockquote><p><strong>backup</strong></p><blockquote><p>备份机，所有服务器挂了之后才会生效</p></blockquote><p><strong>down</strong></p><blockquote><p>标识某一台server不可用</p></blockquote><p><strong>max_conns</strong></p><blockquote><p>限制分配给某台Server处理的最大连接数量，超过这个数量，将不会分配新的连接给它。默认为0，表示不限制。注意：1.5.9之后的版本才有这个配置 表示最多给100这台Server分配1000个请求，如果这台Server正在处理1000个请求，nginx将不会分配新的请求给到它。假如有一个请求处理完了，还剩下999个请求在处理，这时nginx也会将新的请求分配给它。</p></blockquote><h4 id="3-IP-HASH"><a href="#3-IP-HASH" class="headerlink" title="3.IP HASH"></a>3.IP HASH</h4><h4 id="ip-hash-ip绑定"><a href="#ip-hash-ip绑定" class="headerlink" title="ip_hash(ip绑定)"></a>ip_hash(ip绑定)</h4><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Nginx/iphash.png" alt="ip_hash"></p><p>ip hash算法的核心实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0;i &lt; 3;i++)&#123;</span><br><span class="line">    hash = (hash * 113 + iphp-&gt;addr[i]) % 6271; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = hash % iphp-&gt;rrp.peers-&gt;number;</span><br></pre></td></tr></table></figure><blockquote><p>从代码中可以看出，hash值既与ip有关又与后端机器的数量有关。经过测试，上述算法可以连续产生1045个互异的value，这是该算法的硬限制。对此nginx使用了保护机制，当经过20次hash仍然找不到可用的机器时，算法退化成轮询。因此，从本质上说，ip hash算法是一种变相的轮询算法，如果两个ip的初始hash值恰好相同，那么来自这两个ip的请求将永远落在同一台服务器上，这为均衡性埋下了很深的隐患。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> zhimma &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:883</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:884</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:885</span>;</span><br><span class="line">&#125;</span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> zhimma.ma;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>         http://zhimma;</span><br><span class="line">            <span class="comment">#如果服务器要获取客户端真实IP，可以用下三句设置主机头和客户端真实地址</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><h4 id="通用hash、一致性hash"><a href="#通用hash、一致性hash" class="headerlink" title="通用hash、一致性hash"></a>通用hash、一致性hash</h4><h4 id="session-sticky"><a href="#session-sticky" class="headerlink" title="session_sticky"></a>session_sticky</h4><h2 id="配置详情"><a href="#配置详情" class="headerlink" title="配置详情"></a>配置详情</h2><h3 id="负载均衡服务器"><a href="#负载均衡服务器" class="headerlink" title="负载均衡服务器"></a>负载均衡服务器</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    <span class="attribute">upstream</span> zhimma &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:883</span>   weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:884</span>   weight=<span class="number">4</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.2.107:885</span>   weight=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> zhimma.ma;</span><br><span class="line">        <span class="attribute">root</span>   /home/www/tourism/laravel_store/public;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span>         http://zhimma;</span><br><span class="line">                <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#   include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务服务器"><a href="#业务服务器" class="headerlink" title="业务服务器"></a>业务服务器</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@e91b4a662023 conf.d]# pwd </span><br><span class="line">/etc/nginx/conf.d</span><br><span class="line">[root@e91b4a662023 conf.d]# ls</span><br><span class="line">zhimma.ma.conf</span><br><span class="line">root@e91b4a662023 conf.d]# cat zhimma.ma.conf </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  zhimma.ma;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">## Root and index files.</span></span><br><span class="line">    <span class="comment"># 这里的路径对应自己项目路径，因为我是做了目录挂载，所以剩下2台服务器nginx的配置做了区分</span></span><br><span class="line">    <span class="comment"># 分别是/home/www/zhimma/server2和/home/www/zhimma/server3</span></span><br><span class="line">    <span class="attribute">root</span> /home/www/zhimma/server1;</span><br><span class="line">    <span class="attribute">index</span>  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">            <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php<span class="variable">$is_args</span><span class="variable">$args</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx ，配置hosts,访问<code>zhimma.ma:881</code>,就能看的切换的效果了</p><p>### </p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo: sorry, you must have a tty to run sudo</title>
      <link href="/2017/02/07/sudo-sorry-you-must-have-a-tty-to-run-sudo/"/>
      <url>/2017/02/07/sudo-sorry-you-must-have-a-tty-to-run-sudo/</url>
      
        <content type="html"><![CDATA[<p>今天使用一个非root管理员操作服务器时，使用sudo命令报出了</p><p><code>sudo: sorry, you must have a tty to run sudo</code></p><p>错误，查找资料后记录如下解决方法：</p><blockquote><p>使用不同账户，执行执行脚本时候sudo经常会碰到 sudo: sorry, you must have a tty to run sudo这个情况</p><p>其实修改一下sudo的配置就好了</p><blockquote><p><code>vi /etc/sudoers</code> (最好用visudo命令)<br><code>注释掉 Default requiretty 一行</code><br><code>#Default requiretty</code></p></blockquote></blockquote><p>意思就是sudo默认需要tty终端。注释掉就可以在后台执行了。</p>]]></content>
      
      
      <categories>
          
          <category> 遇到的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遇到的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window10下docker的应用-创建本地环境的lnmp环境</title>
      <link href="/2016/12/30/window10%E4%B8%8Bdocker%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E7%9A%84lnmp%E7%8E%AF%E5%A2%83/"/>
      <url>/2016/12/30/window10%E4%B8%8Bdocker%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E7%9A%84lnmp%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="docker相关"><a href="#docker相关" class="headerlink" title="docker相关"></a>docker相关</h3><p>1.下载<a href="https://download.docker.com/win/stable/InstallDocker.msi" target="_blank" rel="noopener">docker for windows</a><br>2.安装docker的步骤就不多说了，下一步下一步就行,安装之前记得先将windows自带的hyper-v开启<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker0.jpg" alt="开启hyper-v">&nbsp;</p><a id="more"></a><p>3.配置docker</p><ul><li><p>设置共享磁盘 <img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker1.jpg" alt="设置共享磁盘"></p></li><li><p>配置镜像仓库地址为阿里云（非必须）</p><ul><li>1.在<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云镜像仓库</a>中申请自己的加速器<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker4.jpg" alt="设置docker镜像仓库为阿里云">&nbsp;</li><li>2.在docker中配置仓库地址，右键右下角docker中的设置功能进行设置<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker2.jpg" alt="在docker中配置仓库地址">&nbsp;</li></ul></li></ul><p>上面配置成功后，接下来进行docker的常用操作</p><p>4.打开windows的cmd或者git bash;</p><ul><li>输入docker，出现下列信息表示安装成功<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker3.jpg" alt="success info"><br>5.docker命令</li><li>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行容器</li><li>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像</li><li>commit    Create a new image from a container’s changes # 提交当前容器为新的镜像</li><li>cp        Copy files/folders from the containers filesystem to the host path<pre><code># 从容器中拷贝指定文件或者目录到宿主机中</code></pre></li><li>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</li><li>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化</li><li>events    Get real time events from the server          # 从 docker 服务获取容器实时事件</li><li>exec      Run a command in an existing container        # 在已存在的容器上运行命令</li><li>export    Stream the contents of a container as a tar archive   <pre><code># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</code></pre></li><li>history   Show the history of an image                  # 展示一个镜像形成历史</li><li>images    List images                                   # 列出系统当前镜像</li><li>import    Create a new filesystem image from the contents of a tarball  <pre><code># 从tar包中的内容创建一个新的文件系统映像[对应 export]</code></pre></li><li>info      Display system-wide information               # 显示系统相关信息</li><li>inspect   Return low-level information on a container   # 查看容器详细信息</li><li>kill      Kill a running container                      # kill 指定 docker 容器</li><li>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]</li><li>login     Register or Login to the docker registry server   <pre><code># 注册或者登陆一个 docker 源服务器</code></pre></li><li>logout    Log out from a Docker registry server         # 从当前 Docker registry 退出</li><li>logs      Fetch the logs of a container                 # 输出当前容器日志信息</li><li>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT<pre><code># 查看映射端口对应的容器内部源端口</code></pre></li><li>pause     Pause all processes within a container        # 暂停容器</li><li>ps        List containers                               # 列出容器列表</li><li>pull      Pull an image or a repository from the docker registry server<pre><code># 从docker镜像源服务器拉取指定镜像或者库镜像</code></pre></li><li>push      Push an image or a repository to the docker registry server<pre><code># 推送指定镜像或者库镜像至docker源服务器</code></pre></li><li>rename    Rename an existing container</li><li>restart   Restart a running container                   # 重启运行的容器</li><li>rm        Remove one or more containers                 # 移除一个或者多个容器</li><li>rmi       Remove one or more images                 <pre><code># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</code></pre></li><li>run       Run a command in a new container<pre><code># 创建一个新的容器并运行一个命令</code></pre></li><li>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]</li><li>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像</li><li>start     Start a stopped containers                    # 启动容器</li><li>stats     Display a stream of a containers’ resource usage statistics</li><li>stop      Stop a running containers                     # 停止容器</li><li>tag       Tag an image into a repository                # 给源中镜像打标签</li><li>top       Lookup the running processes of a container   # 查看容器中运行的进程信息</li><li>unpause   Unpause a paused container                    # 取消暂停容器</li><li>version   Show the docker version information           # 查看 docker 版本号</li><li>wait      Block until a container stops, then print its exit code           # 截取容器停止时的退出状态值&nbsp;</li></ul><p>6.到此windows for docker 安装了解完成，下面进行容器的运行</p><ul><li>查找镜像<br><code>docker search centos</code><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker11.png" alt="docker pull"></li><li>pull一个镜像<br><code>docker pull centos</code><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker7.jpg" alt="docker pull"><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker8.jpg" alt="docker iamges"></li><li>将这个镜像启动成为一个容器,并映射端口、挂在本地的目录、后台启动、赋予最高权限<br><code>docker run -it -d --privileged=true --name www -p 33060:3306 -p 220:22 -p 8080:80 -v e:\WWW\:/home/www centos /usr/sbin/init</code></li></ul><blockquote><p>解释一下主要参数的意义：</p><ul><li>-d&nbsp;&nbsp;&nbsp;&nbsp;以daemon方式运行</li><li>–privileged=true&nbsp;&nbsp;&nbsp;&nbsp;增加权限的选项（本人未测试）</li><li>–name &nbsp;&nbsp;&nbsp;&nbsp;给运行的容器起别名（个人理解）</li><li>-p 33060:3306 -p 220:22 -p 8080:80 &nbsp;&nbsp;&nbsp;&nbsp;进行端口映射</li><li>-v e:\WWW\:/home/www  &nbsp;&nbsp;&nbsp;&nbsp;挂载宿主机的www目录到容器内部的www目录</li></ul></blockquote><ul><li>运行后查看容器运行列表<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker9.jpg" alt="docker pull"></li><li>进入容器并查看<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker10.jpg" alt="docker run"><br>主要是查看挂在的目录是否存在<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker12.png" alt="docker run">)<br>和本地目录一致，挂在成功！<br>7 安装ifconfig<br><code>yum install net-tools –y</code><br>8 安装压缩解压缩<br><code>yum install -y unzip zip</code><br>9 安装firewall-cmd<br><code>yum install firewalld systemd –y</code><br>10 修改密码<br><code>passwd</code><br>11 安装ssh服务，使用工具与容器内进行通讯和管理</li></ul><ul><li>1 . 安装ssh服务 <code>yum install openssh*</code></li><li><p>2 . 配置ssh<code>vi  /etc/ssh/sshd_config</code></p><blockquote><p>这里我没有设置，因为是初学，使用的默认配置,如果需要设置，请参考下面的说明</p><blockquote><p>设置這些设定是一些比较基本的<br>首先先把port改掉<br>port 52041<br>再来是限定登入者<br>AllowUsers 使用者账号1 使用者账号2 …..<br>这一行在设置中是沒有的~请自行加入<br>再来把这两行的注释掉<br>PermitEmptyPasswords no<br>PasswordAuthentication yes<br>再来限制root账号登录</p></blockquote></blockquote></li><li><p>3 .重启 <code>systemctl restart sshd.service</code></p></li><li>4 .设置为开机启动<code>sudo systemctl enable sshd.service</code> </li><li>5 .开放防火墙端口<code>firewall-cmd --permanent --zone=public --add-port=22/tcp</code> </li><li>6 . 重启防火墙<code>firewall-cmd --reload</code><br>最后输入netstat -ant 看看PORT有沒有加入监控中<blockquote><p>CentOS 7 的最小安装未把 netstat 安装进去，所以如果执行失败请输入<br><code>sudo yum install net-tools</code><br><code>yum install firewalld systemd -y</code><br>测试环境下也可以彻底关闭防火墙</p><blockquote><p>关闭防火墙<br>CentOS 7.0默认使用的是firewall作为防火墙<br>  firewall：<br>  systemctl start firewalld.service#启动firewall<br>  systemctl stop firewalld.service#停止firewall<br>  systemctl disable firewalld.service#禁止firewall开机启动</p></blockquote></blockquote></li></ul><p>12.测试ssh连接<br>记住我们的端口映射好220=&gt;22 8080=&gt;80 33060=&gt;3306<br>直接上图</p><ul><li>查看本机ip<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker15.png" alt="docker run"></li><li>使用220端口连接容器<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker17.png" alt="docker run"></li><li>连接成功查看<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker18.png" alt="docker run"></li></ul><p>13.将容器保存为镜像<br>先退出容器，拿到需要保存为镜像的容器id<br><code>docker commit -m=&#39;ssh_network_vim&#39; --author=&#39;mma&#39; f3823b442695 ssh_network_vim</code></p><ul><li>-m 创建的镜像的提交信息</li><li>–author指定镜像作者，接着是容器ID、目标镜像仓库、镜像名<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker13.png" alt="docker run"></li></ul><p>ok，docker在windows上面的安装设置就到这里，下面进行lnmp环境的搭建</p><hr><p>下面进行lnmp 环境的搭建</p><h3 id="安装lnmp"><a href="#安装lnmp" class="headerlink" title="安装lnmp"></a>安装lnmp</h3><hr><p>请移步此教程：<a href="https://blog.bytesclub.com/2017/02/27/CentOS7%E2%98%9Elnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">CentOS7☞lnmp环境搭建</a></p><h3 id="正式使用"><a href="#正式使用" class="headerlink" title="正式使用"></a>正式使用</h3><hr><p>之前我安装过一次，并且配置完成提交到阿里云的仓库中了，这次的演示，我直接从阿里云下载之前我使用的镜像<br>1.下载镜像</p><ul><li>镜像信息<br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker14.png" alt="docker run"></li><li>下载镜像<br><code>docker pull registry.cn-hangzhou.aliyuncs.com/mma/centos7-lnmp:v1.0.0</code><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker16.png" alt="docker run"><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker19.png" alt="docker run"><br>2.运行一个容器，并进入进入容器<br><code>docker run -it -d --privileged=true --name www -p 33060:3306 -p 220:22 -p 8080:80 -v e:\WWW\:/home/www 84901c8f883b/usr/sbin/init</code><br>&nbsp;<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/docker/docker21.png" alt="docker run"><br>3.启动lnmp<br>4.windows访问容器中的项目</li></ul><p>ok,这篇总结就到这里，总结下，写这篇总结收获很多，第一次使用hexo，第一次在windows环境模拟linux环境（纯属zhuangb用），阿里云方面，第一次使用markdown。。。 说实在的，还是很有感触，也是个开始，继续加油下去吧！mafuntoo</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
