<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhimma&#39;s blog</title>
  
  
  <link href="https://blog.zhimma.com/atom.xml" rel="self"/>
  
  <link href="https://blog.zhimma.com/"/>
  <updated>2021-08-12T10:09:36.033Z</updated>
  <id>https://blog.zhimma.com/</id>
  
  <author>
    <name>zhimma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitlab-ci.yml关键字整理(转载)</title>
    <link href="https://blog.zhimma.com/2021/08/12/gitlab-ci-yml%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86-%E8%BD%AC%E8%BD%BD/"/>
    <id>https://blog.zhimma.com/2021/08/12/gitlab-ci-yml%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86-%E8%BD%AC%E8%BD%BD/</id>
    <published>2021-08-12T10:07:59.000Z</published>
    <updated>2021-08-12T10:09:36.033Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="Gitlab-CI-CD-管道配置参考"><a href="#Gitlab-CI-CD-管道配置参考" class="headerlink" title="Gitlab CI/CD 管道配置参考"></a>Gitlab CI/CD 管道配置参考</h2><p>在每个项目中，使用名为.gitlab-ci.yml 的 yaml 文件配置 Gitlab CI/CD 管道。</p><p>.gitlab-ci.yml 文件定义了管道的结构和顺序，并确定：</p><p>使用 Gitlab Runner 执行什么。</p><p>遇到特殊情况时要做什么决定？例如，当一个进程成功或失败时。</p><p>本主题介绍 CI/CD 管道配置。有关其他 CI/CD 配置信息，请参阅：</p><p>Gitlab CI/CD 变量，用于配置管道运行的环境。</p><p>Gitlab Runner 高级配置，用于配置 Gitlab Runner。</p><p>我们有配置管道的完整示例：</p><p>要快速介绍 Gitlab CI，请遵循我们的快速入门指南。</p><p>有关示例的集合，请参见 Gitlab CI/CD 示例。</p><p>要查看企业中使用的大型.gitlab-ci.yml 文件，请参见 gitlab ce 的.gitlab-ci.yml 文件。</p><blockquote><p>如果你有一个镜像存储库，其中有 gitlab，你可能需要在项目的 Settings &gt; Repository &gt; Pull from a remote repository &gt; Trigger 镜像更新管道。</p></blockquote><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>管道配置从 job 开始。jobs 是.gitlab-ci.yml 文件最基本的元素。</p><p>工作包括：</p><p>定义了在什么条件下应该执行它们的约束。</p><p>具有任意名称的顶级元素，必须至少包含 script 子句。</p><p>不限于可定义的数量。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job1:</span><br><span class="line">  script: &quot;execute-script-for-job1&quot;</span><br><span class="line">job2:</span><br><span class="line">  script: &quot;execute-script-for-job2&quot;</span><br></pre></td></tr></table></figure><p>上面的示例是最简单的 CI/CD 配置，有两个独立的 job，其中每个 job 执行不同的命令。当然，命令可以直接执行代码（./configure；make；make install）或者在存储库中运行 script（test.sh）。<br>工作由 Runners 挑选并在 Runner 的环境。重要的是，每个 job 都在运行彼此独立。</p><h3 id="2-验证-gitlab-ci-yml"><a href="#2-验证-gitlab-ci-yml" class="headerlink" title="2. 验证 .gitlab-ci.yml"></a>2. 验证 .gitlab-ci.yml</h3><p>Gitlab CI 的每个实例都有一个名为 lint 的嵌入式调试工具，用于验证.gitlab-ci.yml 文件的内容。您可以在您的页面 ci/lint 下找到 lint。项目命名空间。例如，<a href="https://gitlab.example.com/gitlab-org/project-123//ci/lint%E3%80%82">https://gitlab.example.com/gitlab-org/project-123//ci/lint。</a></p><h3 id="3-Unavailable-names-for-jobs"><a href="#3-Unavailable-names-for-jobs" class="headerlink" title="3. Unavailable names for jobs"></a>3. Unavailable names for jobs</h3><p>每个 job 必须有一个唯一的名称，但有一些保留的关键字不能用作 job 名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">image</span><br><span class="line">services</span><br><span class="line">stages</span><br><span class="line">types</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">variables</span><br><span class="line">cache</span><br></pre></td></tr></table></figure><h3 id="4-使用保留关键字"><a href="#4-使用保留关键字" class="headerlink" title="4. 使用保留关键字"></a>4. 使用保留关键字</h3><p>如果在使用特定值（例如，true or false）时出现验证错误，请尝试：</p><p>–引用它们。</p><p>–将它们更改为其他形式。例如，/bin/true。</p><h3 id="5-配置参数"><a href="#5-配置参数" class="headerlink" title="5. 配置参数"></a>5. 配置参数</h3><p>job 定义为定义 job 行为的参数列表。</p><p>下表列出了 job 的可用参数：</p><table><thead><tr><th>Keyword</th><th>描述</th></tr></thead><tbody><tr><td>script</td><td>由运行程序执行的 shell 脚本。</td></tr><tr><td>image</td><td>使用 Docker 图像。还提供：image:name 和 image:entrypoint。</td></tr><tr><td>services</td><td>使用 Docker 服务图像。还提供：services:name、services:alias、services:entrypoint 和 services:command。</td></tr><tr><td>before_script</td><td>重写在 job 之前执行的一组命令。</td></tr><tr><td>after_script</td><td>重写在 job 后执行的一组命令。</td></tr><tr><td>stages</td><td>定义管道中的阶段。</td></tr><tr><td>stage</td><td>定义 job 阶段（default: test）。</td></tr><tr><td>only</td><td>限制创建 when jobs。还可用：only：refs，only：kubernetes，only：variables，only：changes。</td></tr><tr><td>except</td><td>限制未创建 when jobs。还可用：except:refs，except:kubernetes，except:variables 和 except:changes。</td></tr><tr><td>tags</td><td>用于选择运行程序的标记列表。</td></tr><tr><td>allow_failure</td><td>允许 job 失败。失败的 job 不影响提交状态。</td></tr><tr><td>when</td><td>何时运行 job。还可用：when:manual and when:delayed。</td></tr><tr><td>environment</td><td>job 部署到的环境的名称。还可用：environment:name, environment:url, environment:on_stop, and environment:action.</td></tr><tr><td>cache</td><td>在后续运行之间应缓存的文件列表。还可用：cache:paths, cache:key, cache:untracked, and cache:policy.。</td></tr><tr><td>artifacts</td><td>成功时要附加到 job 的文件和目录列表。还可用：artifacts:paths, artifacts:name, artifacts:untracked, artifacts:when, artifacts:expire_in, artifacts:reports, and artifacts:reports:junit。在 Gitlab 企业版中，这些可用：artifacts:reports:codequality, artifacts:reports:sast, artifacts:reports:dependency_scanning, artifacts:reports:container_scanning, artifacts:reports:dast, artifacts:reports:license_management, artifacts:reports:performance and artifacts:reports:metrics。</td></tr><tr><td>dependencies</td><td>job 所依赖的其他 job，以便在它们之间传递 artifacts。</td></tr><tr><td>coverage</td><td>给定 job 的代码覆盖率设置。</td></tr><tr><td>retry</td><td>如果出现故障，一个 job 可以自动重试的时间和次数。</td></tr><tr><td>parallel</td><td>一个 job 应并行运行多少个实例。</td></tr><tr><td>trigger</td><td>定义下游管道触发器。</td></tr><tr><td>include</td><td>允许此 job 包含外部 yaml 文件。还提供：include:local、include:file、include:template 和 include:remote。</td></tr><tr><td>extends</td><td>此 job 将从中继承的配置项。</td></tr><tr><td>pages</td><td>上载 job 的结果以用于 Gitlab 页面。</td></tr><tr><td>variables</td><td>在 job 级别定义 job 变量。</td></tr></tbody></table><blockquote><p>NOTE: Note:Parameters types and type are deprecated.(弃用)</p></blockquote><h3 id="6-设置默认参数"><a href="#6-设置默认参数" class="headerlink" title="6. 设置默认参数"></a>6. 设置默认参数</h3><p>某些参数可以全局设置为所有 job 的默认值，使用默认值：关键字。然后，默认参数可以被特定于 job 的参数覆盖配置。</p><p>可以在默认块内定义以下 job 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">image</span><br><span class="line">services</span><br><span class="line">before_script</span><br><span class="line">after_script</span><br><span class="line">cache</span><br></pre></td></tr></table></figure><p>在下面的示例中，ruby:2.5 图像被设置为所有图像的默认值。job，rspec 2.6job 除外，它使用 ruby:2.6 映像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">default:</span><br><span class="line">  image: ruby:2.5</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  script: bundle exec rspec</span><br><span class="line"></span><br><span class="line">rspec 2.6:</span><br><span class="line">  image: ruby:2.6</span><br><span class="line">  script: bundle exec rspec</span><br></pre></td></tr></table></figure><h3 id="7-参数详细信息"><a href="#7-参数详细信息" class="headerlink" title="7. 参数详细信息"></a>7. 参数详细信息</h3><p>以下是用于配置 CI/CD 管道的参数的详细说明。</p><h4 id="7-1-script"><a href="#7-1-script" class="headerlink" title="7.1. script"></a>7.1. script</h4><p>script 是 job 所需的唯一关键字。这是一个 shellscript 由运行程序执行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  script: &quot;bundle exec rspec&quot;</span><br></pre></td></tr></table></figure><p>此参数还可以包含使用数组的多个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  script:</span><br><span class="line">    - uname -a</span><br><span class="line">    - bundle exec rspec</span><br></pre></td></tr></table></figure><blockquote><p>有时，script 命令需要用单引号或双引号括起来。例如，包含冒号（：）的命令需要用引号括起来，因此 yaml 解析器知道将整个事件解释为字符串而不是 “key:value” 对。使用特殊字符时要小心:<br>:, {, }, [, ], ,, &amp;, *, #, ?, |, -, &lt;, &gt;, =, !, %, @, `.</p></blockquote><h3 id="7-2-image"><a href="#7-2-image" class="headerlink" title="7.2. image"></a>7.2. image</h3><p>用于指定要用于 job 的 Docker 映像。</p><p>用于：</p><p>简单定义示例，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#define-image-and-services-from-gitlab-ciyml">请参见从.gitlab-ci.yml 定义图像和服务。</a></p><p>详细使用信息，<a href="https://gitlab.com/help/ci/docker/README.md">请参阅 Docker 集成文档。</a></p><h4 id="image-name"><a href="#image-name" class="headerlink" title="image:name"></a>image:name</h4><p><a href="https://gitlab.com/help/ci/docker/using_docker_images.md#extended-docker-configuration-options">扩展 Docker 配置选项。</a></p><p>有关详细信息，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#available-settings-for-image">请参阅图像的可用设置。</a></p><h4 id="image-entrypoint"><a href="#image-entrypoint" class="headerlink" title="image:entrypoint"></a>image:entrypoint</h4><p>扩展 Docker 配置选项。</p><p>有关详细信息，请参阅图像的可用设置。</p><h3 id="7-3-services"><a href="#7-3-services" class="headerlink" title="7.3. services"></a>7.3. services</h3><p>用于指定服务 Docker 映像，链接到映像中指定的基映像。</p><p>用于：</p><p>简单定义示例，请参见从.gitlab-ci.yml 定义图像和服务。</p><p>详细使用信息，请参阅 Docker 集成文档。</p><p>例如服务，<a href="https://gitlab.com/help/ci/services/README.md">请参见 Gitlab CI Services。</a></p><h4 id="services-name"><a href="#services-name" class="headerlink" title="services:name"></a>services:name</h4><p>扩展 Docker 配置选项。有关详细信息，<a href="https://gitlab.com/help/ci/docker/using_docker_images.md#available-settings-for-services"> 请参阅 “服务的可用设置”。</a></p><h4 id="services-alias"><a href="#services-alias" class="headerlink" title="services:alias"></a>services:alias</h4><p>扩展 Docker 配置选项。有关详细信息，请参阅 “服务的可用设置”。</p><h4 id="services-entrypoint"><a href="#services-entrypoint" class="headerlink" title="services:entrypoint"></a>services:entrypoint</h4><p>扩展 Docker 配置选项。有关详细信息，请参阅 “服务的可用设置”。</p><h4 id="services-command"><a href="#services-command" class="headerlink" title="services:command"></a>services:command</h4><p>扩展 Docker 配置选项。有关详细信息，请参阅 “服务的可用设置”。</p><h3 id="7-4-before-script-after-script"><a href="#7-4-before-script-after-script" class="headerlink" title="7.4. before_script / after_script"></a>7.4. before_script / after_script</h3><p>before_script 用于定义应在所有命令之前运行的命令 job，包括部署 job，但在恢复 artifacts 之后。这可以是一个数组或多行字符串。</p><p>after_script 用于定义将要运行的命令 job，包括失败的 job。这必须是一个数组或多行字符串。</p><p>在 before_script 指定的 script 是：</p><p>与主 script 中指定的 script 连接。工作级别在 script 定义之前覆盖全局级别在 script 定义之前与 script 定义连接时。</p><p>与主 scriptscript 一起在单个 shell 中作为一个 script 执行上下文。</p><p>after_script 指定的 script：</p><p>将当前工作目录设置回默认值。</p><p>在与 script 和 script 之前分开的 shell 上下文中执行 script。</p><p>由于上下文分隔，无法查看定义的 script 所做的更改在 “script” 或 “before_script”，请执行以下操作之一：</p><p>在外壳中。例如，script 中导出的命令别名和变量 script。</p><p>在工作树之外（取决于运行者执行者）。例如，由 before_script 或 scriptscript 安装的软件。</p><p>可以覆盖在 script 之前和之后定义的全局，如果按 job 设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">default:</span><br><span class="line">  before_script:</span><br><span class="line">    - global before script</span><br><span class="line"></span><br><span class="line">job:</span><br><span class="line">  before_script:</span><br><span class="line">    - execute this instead of global before script</span><br><span class="line">  script:</span><br><span class="line">    - my command</span><br><span class="line">  after_script:</span><br><span class="line">    - execute this after my script</span><br></pre></td></tr></table></figure><h3 id="7-5-stages"><a href="#7-5-stages" class="headerlink" title="7.5. stages"></a>7.5. stages</h3><p>stages 用于全局定义 job 可以使用的阶段</p><p>stages 的规格允许有灵活的多级管道。stages 中元素的顺序定义了 job 执行的顺序：</p><p>同一阶段的 job 并行运行。</p><p>下一阶段的 job 在上一阶段的 job 之后运行成功完成。</p><p>让我们考虑下面的例子，它定义了 3 个阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br></pre></td></tr></table></figure><p>首先，build 的所有 job 都是并行执行的。</p><p>如果 build 的所有 job 都成功，则 test job 将并行执行。</p><p>如果 test 的所有 job 都成功，则 deploy job 将并行执行。</p><p>如果 Deploy 的所有 job 都成功，则提交标记为通过。</p><p>如果以前的任何 job 失败，提交将标记为失败，并且不</p><p>执行下一阶段的工作。</p><p>还有两个边缘案例值得一提：</p><p>如果在.gitlab-ci.yml 中没有定义阶段，默认情况下，build, test and deploy 用作 job 的阶段。</p><p>如果 job 未指定阶段，则该 job 将被分配到 test 阶段。</p><h3 id="7-6-stage"><a href="#7-6-stage" class="headerlink" title="7.6. stage"></a>7.6. stage</h3><p>stage 是定义单个 job，并依赖于全局的 stages。它允许将 job 分组到不同的阶段，并且相同的 job 阶段是并行执行的（取决于某些条件）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line">job 1:</span><br><span class="line">  stage: build</span><br><span class="line">  script: make build dependencies</span><br><span class="line"></span><br><span class="line">job 2:</span><br><span class="line">  stage: build</span><br><span class="line">  script: make build artifacts</span><br><span class="line"></span><br><span class="line">job 3:</span><br><span class="line">  stage: test</span><br><span class="line">  script: make test</span><br><span class="line"></span><br><span class="line">job 4:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: make deploy</span><br></pre></td></tr></table></figure><p>Using your own Runners</p><p>使用自己的运行程序时，默认情况下，Gitlab 运行程序一次只运行一个 job（请参见运行程序全局设置中的并发标志）。</p><p>只有在以下情况下，job 才会并行运行：</p><p>在不同程序上运行</p><p>运行程序的并发设置已更改。</p><h3 id="7-7-only-except-basic"><a href="#7-7-only-except-basic" class="headerlink" title="7.7. only/except (basic)"></a>7.7. only/except (basic)</h3><p>only 和 except 两个参数将 job 策略设置为限制创建的 job：</p><p>only 定义要为其运行 job 的分支和标记的名称。</p><p>except 定义排除的 job</p><p>有一些规则适用于 job 策略的使用：</p><p>only 和 except 是包容性的。如果只定义 only 和 except 在 job 规范中，引用 only 由和 except。</p><p>only 和 except 允许使用正则表达式（支持的 regexp 语法）。</p><p>only 和 except 允许指定用于筛选 job 的存储库路径分支。</p><p>此外，only 和 except 情况允许使用特殊关键字：</p><table><thead><tr><th>Value</th><th>描述</th></tr></thead><tbody><tr><td>branches</td><td>当管道的 Git 引用是分支时。</td></tr><tr><td>tags</td><td>当管道的 Git 引用是标记时。</td></tr><tr><td>api</td><td>当管道被第二个管道 API 触发时（而不是触发 API）。</td></tr><tr><td>external</td><td>使用 Gitlab 以外的 CI 服务时。</td></tr><tr><td>pipelines</td><td>对于多项目触发器，使用带有 CI_JOB_TOKEN 的 API 创建的。</td></tr><tr><td>pushes</td><td>管道由用户的 git push 触发。</td></tr><tr><td>schedules</td><td>用于计划的管道。</td></tr><tr><td>triggers</td><td>用于使用触发器标记创建的管道。</td></tr><tr><td>web</td><td>对于使用 Gitlab UI 中的 “运行管道” 按钮创建的管道（在项目的管道下）。</td></tr><tr><td>merge_requests</td><td>创建或更新合并请求时（有关合并请求，请参阅管道）。</td></tr><tr><td>chats</td><td>对于使用 gitlab chatops 命令创建的 job。</td></tr></tbody></table><p>在下面的示例中，job 将仅对以问题 - 开头的引用运行，鉴于将跳过所有分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  # use regexp</span><br><span class="line">  only:</span><br><span class="line">    - &#x2F;^issue-.*$&#x2F;</span><br><span class="line">  # use special keyword</span><br><span class="line">  except:</span><br><span class="line">    - branches</span><br></pre></td></tr></table></figure><p>默认情况下，模式匹配区分大小写。使用 i 标志修饰符，如 /pattern/i 使模式不区分大小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  # use regexp</span><br><span class="line">  only:</span><br><span class="line">    - &#x2F;^issue-.*$&#x2F;i</span><br><span class="line">  # use special keyword</span><br><span class="line">  except:</span><br><span class="line">    - branches</span><br></pre></td></tr></table></figure><p>在本例中，job 将仅对标记的引用运行，或者如果通过 API 触发器或管道计划显式请求生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  # use special keywords</span><br><span class="line">  only:</span><br><span class="line">    - tags</span><br><span class="line">    - triggers</span><br><span class="line">    - schedules</span><br></pre></td></tr></table></figure><p>存储库路径只能用于执行父存储库的 job，而不能用于分叉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  only:</span><br><span class="line">    - branches@gitlab-org&#x2F;gitlab-ce</span><br><span class="line">  except:</span><br><span class="line">    - master@gitlab-org&#x2F;gitlab-ce</span><br><span class="line">    - &#x2F;^release&#x2F;.*$&#x2F;@gitlab-org&#x2F;gitlab-ce</span><br></pre></td></tr></table></figure><p>上面的示例将为 gitlab-org/gitlab-ce 上的所有分支运行 job，master 和以 release / 作为前缀的分支除外。</p><p>only 默认值：’’branches’、’tags’]</p><p>except 默认值为空。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  script: echo &#39;test&#39;</span><br></pre></td></tr></table></figure><p>转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  script: echo &#39;test&#39;</span><br><span class="line">  only: [&#39;branches&#39;, &#39;tags&#39;]</span><br></pre></td></tr></table></figure><h4 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h4><p>因为 @用于表示引用存储库路径的开头，匹配正则表达式中包含 @字符的引用名称需要使用十六进制字符代码 match \x40。</p><p>只有标记或分支名称才能与正则表达式匹配。如果给定存储库路径，则始终按字面匹配。</p><p>如果使用正则表达式来匹配标记或分支名称，模式的整个引用名称部分必须是正则表达式，必须用 / 包围。（在结束 / 后附加正则表达式标志）因此，问题 -/.*/ 无法匹配所有标记名或分支名从问题开始。</p><blockquote><p>使用锚 ^ 和 $ 避免正则表达式只匹配标记名或分支名的子字符串。例如，/^issue-.$/ 等于 /^issue-/，而 just/issue/ 也将匹配一个称为严重问题的分支。</p></blockquote><p>Supported only/except regexp syntax</p><p>警告：警告：这是 Gitlab 11.9.4 引入的突破性变化。</p><p>在 Gitlab 11.9.4 中，Gitlab 开始内部转换使用的 regexp 仅限 RE2 和 RE2 的参数。</p><p>这意味着只有 RubyRegexp 提供的特性的子集支持。RE2 限制了功能集由于计算的复杂性，这意味着一些特性在 Gitlab 11.9.4 中变得不可用。例如，负数 lookaheads。</p><p>对于 11.9.7 到 Gitlab 12.0 的 Gitlab 版本，Gitlab 提供了一个可以由管理员启用，允许用户使用不安全的 regexp 语法。这带来了兼容性使用以前允许的语法版本，并允许用户优雅地迁移到新语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">Feature.enable(:allow_unsafe_ruby_regexp)</span><br></pre></td></tr></table></figure><h3 id="7-8-only-except-advanced-高级"><a href="#7-8-only-except-advanced-高级" class="headerlink" title="7.8. only/except (advanced) 高级"></a>7.8. only/except (advanced) 高级</h3><p>警告：警告：这是一个 alpha 功能，随时可能更改，恕不另行通知！</p><p>Gitlab 支持简单和复杂的策略，因此可以使用数组和哈希配置方案。</p><p>有四把钥匙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">refs</span><br><span class="line">variables</span><br><span class="line">changes</span><br><span class="line">kubernetes</span><br></pre></td></tr></table></figure><p>If you use multiple keys under only or except, they act as an AND. The logic is:</p><p>(any of refs) AND (any of variables) AND (any of changes) AND (if kubernetes is active)</p><h4 id="only-refs-except-refs"><a href="#only-refs-except-refs" class="headerlink" title="only:refs/except:refs"></a>only:refs/except:refs</h4><p>refs 策略可以采用与仅简化 / 例外配置相同的值。</p><p>在下面的示例中，只有在为主分支计划管道或运行管道时，才会创建部署 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy:</span><br><span class="line">  only:</span><br><span class="line">    refs:</span><br><span class="line">      - master</span><br><span class="line">      - schedules</span><br></pre></td></tr></table></figure><h4 id="only-kubernetes-except-kubernetes"><a href="#only-kubernetes-except-kubernetes" class="headerlink" title="only:kubernetes/except:kubernetes"></a>only:kubernetes/except:kubernetes</h4><p>kubernetes 策略只接受活动关键字。</p><p>在下面的示例中，只有当项目中的 kubernetes 服务处于活动状态时，才会创建部署 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy:</span><br><span class="line">  only:</span><br><span class="line">    kubernetes: active</span><br></pre></td></tr></table></figure><h4 id="only-variables-except-variables"><a href="#only-variables-except-variables" class="headerlink" title="only:variables/except:variables"></a>only:variables/except:variables</h4><p>variables 关键字用于定义变量表达式。换句话说，您可以使用预定义的变量 /project/group 或环境范围的变量来定义一个表达式 gitlab 将要评估，以决定是否应该创建一个 job。</p><p>使用变量表达式的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy:</span><br><span class="line">  script: cap staging deploy</span><br><span class="line">  only:</span><br><span class="line">    refs:</span><br><span class="line">      - branches</span><br><span class="line">    variables:</span><br><span class="line">      - $RELEASE &#x3D;&#x3D; &quot;staging&quot;</span><br><span class="line">      - $STAGING</span><br></pre></td></tr></table></figure><p>另一个用例是根据提交消息排除 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">end-to-end:</span><br><span class="line">  script: rake test:end-to-end</span><br><span class="line">  except:</span><br><span class="line">    variables:</span><br><span class="line">      - $CI_COMMIT_MESSAGE &#x3D;~ &#x2F;skip-end-to-end-tests&#x2F;</span><br></pre></td></tr></table></figure><p><a href="https://gitlab.com/help/ci/variables/README.md#environment-variables-expressions">Learn more about variables expressions.</a></p><h4 id="only-changes-except-changes"><a href="#only-changes-except-changes" class="headerlink" title="only:changes/except:changes"></a>only:changes/except:changes</h4><p>使用 changes 关键字 only 或 except 可以定义是否应基于 Git push 事件修改的文件创建 job。</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">docker build:</span><br><span class="line">  script: docker build -t my-image:$CI_COMMIT_REF_SLUG .</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - Dockerfile</span><br><span class="line">      - docker&#x2F;scripts&#x2F;*</span><br><span class="line">      - dockerfiles&#x2F;**&#x2F;*</span><br><span class="line">      - more_scripts&#x2F;*.&#123;rb,py,sh&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，将多个提交推送到 Gitlab 时，分支，Gitlab 创建并触发 Docker 构建 job，前提是提交包含对以下任一项的更改：</p><p>Dockerfile 文件。</p><p>docker/scripts/directory 中的任何文件。</p><p>dockerfiles 目录中的任何文件和子目录。</p><p>more_scripts 目录中任何具有 rb、py、sh 扩展名的文件。</p><p>您还可以使用 glob 模式来匹配 repo 根目录或 repo 中的任何目录中的多个文件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">test:</span><br><span class="line">  script: npm run test</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - &quot;*.json&quot;</span><br><span class="line">      - &quot;**&#x2F;*.sql&quot;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的示例中，表达式被双引号括起来，因为它们是全局模式。Gitlab 将无法解析带有未封装的 glob 模式的.gitlab-ci.yml 文件。</p></blockquote><p>如果在 repo 根目录下扩展名为.md 的任何文件中检测到更改，则以下示例将跳过 CIjob：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">build:</span><br><span class="line">  script: npm run build</span><br><span class="line">  except:</span><br><span class="line">    changes:</span><br><span class="line">      - &quot;*.md&quot;</span><br></pre></td></tr></table></figure><blockquote><p>警告：警告：在将此功能与新的分支和标记一起使用时，需要注意一些事项。请参阅下面的部分。</p></blockquote><p>使用带有新分支和标记的更改</p><p>在将新分支或新标记推送到 Gitlab 时，，策略的计算结果始终为 true，Gitlab 将创建 job。此功能尚未与合并请求连接，并且，由于 Gitlab 正在创建管道，用户才能创建合并请求，因此此时目标分支的位置未知。</p><p>对合并请求使用更改</p><p>对于合并请求的管道，可以根据合并请求中修改的文件定义要创建的 job。</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">docker build service one:</span><br><span class="line">  script: docker build -t my-service-one-image:$CI_COMMIT_REF_SLUG .</span><br><span class="line">  only:</span><br><span class="line">    refs:</span><br><span class="line">      - merge_requests</span><br><span class="line">    changes:</span><br><span class="line">      - Dockerfile</span><br><span class="line">      - service-one&#x2F;**&#x2F;*</span><br></pre></td></tr></table></figure><p>在上面的场景中，如果创建或更新合并请求以更改 service one 目录或 dockerfile 中的文件，那么 gitlab 将创建并触发 docker build service onejob。</p><h3 id="7-9-tags"><a href="#7-9-tags" class="headerlink" title="7.9. tags"></a>7.9. tags</h3><p>tags 用于从允许运行此项目的所有运行者列表中选择特定的运行者。</p><p>在注册运行程序期间，可以指定运行程序的 tags，例如 ruby、postgres、development。</p><p>tags 允许您使用分配了指定 tags 的运行者运行 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  tags:</span><br><span class="line">    - ruby</span><br><span class="line">    - postgres</span><br></pre></td></tr></table></figure><p>上面的规范将确保 job 由同时定义了 ruby 和 postgres 标记的运行程序构建。</p><p>标签也是在不同平台上运行不同 job 的好方法，例如，给定一个带有标签 OSX 的 OSX 运行程序和带有标签的 Windows 运行程序 Windows，以下 job 在各自的平台上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">windows job:</span><br><span class="line">  stage:</span><br><span class="line">    - build</span><br><span class="line">  tags:</span><br><span class="line">    - windows</span><br><span class="line">  script:</span><br><span class="line">    - echo Hello, %USERNAME%!</span><br><span class="line"></span><br><span class="line">osx job:</span><br><span class="line">  stage:</span><br><span class="line">    - build</span><br><span class="line">  tags:</span><br><span class="line">    - osx</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;Hello, $USER!&quot;</span><br></pre></td></tr></table></figure><h3 id="7-10-allow-failure"><a href="#7-10-allow-failure" class="headerlink" title="7.10. allow_failure"></a>7.10. allow_failure</h3><p>允许失败允许 job 失败而不影响 CI 套件的其余部分。默认值为假，手动 job 除外。</p><p>当启用并且 job 失败时，该 job 将在用户界面中显示橙色警告。但是，管道的逻辑流会将 job 视为成功 / 通过，并且不会被阻塞。</p><p>假设所有其他 job 都成功，则 job 的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记为 “通过”，没有警告。</p><p>在下面的示例中，job1 和 job2 将并行运行，但如果 job1 失败，则不会停止下一阶段的运行，因为它标记为 allow_failure:true:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job1:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - execute_script_that_will_fail</span><br><span class="line">  allow_failure: true</span><br><span class="line"></span><br><span class="line">job2:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - execute_script_that_will_succeed</span><br><span class="line"></span><br><span class="line">job3:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - deploy_to_staging</span><br></pre></td></tr></table></figure><h3 id="7-11-when"><a href="#7-11-when" class="headerlink" title="7.11. when"></a>7.11. when</h3><p>用于实现在失败或失败时运行的 job。</p><p>when 可以设置为以下值之一：</p><p>on_success - 仅当先前阶段的所有 job 成功时执行 job（或由于标记为 “允许失败” 而被视为成功）。这是默认设置。</p><p>on_failure - 仅当先前阶段中的至少一个 job 失败时才执行 job。</p><p>always - 执行 job，而不管先前阶段的 job 状态如何。</p><p>manual - 手动执行 job（在 Gitlab 8.10 中添加）。<a href="https://gitlab.com/help/ci/yaml/README.md#whenmanual">阅读下面的手动操作</a> 。</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - cleanup_build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line">  - cleanup</span><br><span class="line"></span><br><span class="line">build_job:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - make build</span><br><span class="line"></span><br><span class="line">cleanup_build_job:</span><br><span class="line">  stage: cleanup_build</span><br><span class="line">  script:</span><br><span class="line">    - cleanup build when failed</span><br><span class="line">  when: on_failure</span><br><span class="line"></span><br><span class="line">test_job:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - make test</span><br><span class="line"></span><br><span class="line">deploy_job:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - make deploy</span><br><span class="line">  when: manual</span><br><span class="line"></span><br><span class="line">cleanup_job:</span><br><span class="line">  stage: cleanup</span><br><span class="line">  script:</span><br><span class="line">    - cleanup after jobs</span><br><span class="line">  when: always</span><br></pre></td></tr></table></figure><p>上面的脚本将：</p><p>仅当 build_job 失败时才执行 cleanup_build_job。</p><p>始终在最后执行 cleanup_job 而不管成功或失败。</p><p>允许您从 Gitlab 的用户界面手动执行 Deploy_job。</p><h4 id="when-manual"><a href="#when-manual" class="headerlink" title="when:manual"></a>when:manual</h4><p>手动操作是一种特殊类型的 job，不能自动执行，需要由用户显式启动。手动操作的一个示例用法是部署到生产环境。可以从管道、job、环境和部署视图启动手动操作。<a href="https://gitlab.com/help/ci/environments.md#configuring-manual-deployments">Read more at the<br>environments documentation.</a></p><p>手动操作可以是可选的，也可以是阻塞的。阻止手动操作将在定义此操作的阶段阻止管道的执行。它是当有人通过单击播放按钮执行阻止手动操作时，可以恢复管道的执行。</p><p>当管道被阻塞时，如果设置了 “管道成功时合并”，则不会合并管道。阻塞的管道也有一个特殊的状态，称为手动。默认情况下，手动操作是非阻塞的。如果要进行手动操作阻止，则必须在.gitlab-ci.yml 中的 job 定义中添加 allow_failure:false。</p><p>可选的手动操作默认情况下 allow_failure: true，其状态不会影响整个管道状态。因此，如果手动操作失败，管道最终会成功。</p><p>手动操作被认为是写操作，因此当用户希望触发操作时，将使用受保护分支的权限。换句话说，为了触发分配给正在运行管道的分支的手动操作，用户需要能够合并到此分支。</p><h4 id="when-delayed"><a href="#when-delayed" class="headerlink" title="when:delayed"></a>when:delayed</h4><p>延迟 job 用于在一段时间后执行脚本。如果希望避免 job 立即进入挂起状态，则此操作非常有用。</p><p>您可以用 start_in 键设置周期。除非提供了一个单位，否则 start_in key 的值是以秒为单位的已用时间，并且时间必须小于或等于一小时。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">10 seconds</span><br><span class="line">30 minutes</span><br><span class="line">1 hour</span><br></pre></td></tr></table></figure><p>当某个阶段中存在延迟 job 时，管道将不会进行，直到延迟 job 完成。这意味着这个关键字也可以用于在不同阶段之间插入延迟。</p><p>延迟 job 的计时器在上一阶段完成后立即启动。与其他类型的 job 类似，延迟 job 的计时器将不会启动，除非上一阶段已通过。</p><p>下面的示例创建一个名为 Timed Rollow 10% 的 job，该 job 在上一阶段完成 30 分钟后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">timed rollout 10%:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: echo &#39;Rolling out 10% ...&#39;</span><br><span class="line">  when: delayed</span><br><span class="line">  start_in: 30 minutes</span><br></pre></td></tr></table></figure><p>通过单击 Unschedule 按钮，可以停止延迟 job 的活动计时器。除非手动执行该 job，否则将来永远不会执行该 job。</p><p>您可以通过单击 “播放” 按钮立即启动延迟的 job。Gitlab Runner 将很快选择您的工作并开始工作。</p><h3 id="7-12-environment"><a href="#7-12-environment" class="headerlink" title="7.12. environment"></a>7.12. environment</h3><p>environment 用于定义 job 部署到特定环境。如果指定了 environment，并且该名称下不存在任何环境，则将自动创建一个新的环境。</p><p>在其最简单的形式中，environment 关键字的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy to production:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: git push production HEAD:master</span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br></pre></td></tr></table></figure><p>在上面的示例中，部署到生产 job 将标记为对生产环境进行部署。</p><h4 id="environment-name"><a href="#environment-name" class="headerlink" title="environment:name"></a>environment:name</h4><p>The environment name can contain:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">letters</span><br><span class="line">digits</span><br><span class="line">spaces</span><br><span class="line">-</span><br><span class="line">_</span><br><span class="line">&#x2F;</span><br><span class="line">$</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见的名称有 qa, staging, and production，但是您可以将任何名称用于您的工作流。</p><p>除了在 environment 关键字后定义环境名称，还可以将其定义为单独的值。为此，请在环境下使用 name 关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy to production:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: git push production HEAD:master</span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br></pre></td></tr></table></figure><h4 id="environment-url"><a href="#environment-url" class="headerlink" title="environment:url"></a>environment:url</h4><p>这是一个可选值，设置后，它会在 Gitlab 中的不同位置显示按钮，单击该按钮会将您带到定义的 URL。</p><p>在下面的示例中，如果 job 成功完成，它将在合并请求和环境 / 部署页面中创建按钮，这些页面将指向 <a href="https://prod.example.com./">https://prod.example.com。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy to production:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: git push production HEAD:master</span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br><span class="line">    url: https:&#x2F;&#x2F;prod.example.com</span><br></pre></td></tr></table></figure><h4 id="environment-on-stop"><a href="#environment-on-stop" class="headerlink" title="environment:on_stop"></a>environment:on_stop</h4><p>关闭（停止）环境可以通过在 environment 下定义的 on-stop 关键字来实现。它声明了一个不同的 job，该 job 运行的目的是关闭环境。</p><p>例如，请阅读 environment:action 部分。</p><h4 id="environment-action"><a href="#environment-action" class="headerlink" title="environment:action"></a>environment:action</h4><p>action 关键字将与 on_stop 一起使用，并在调用以关闭环境的 job 中定义。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">review_app:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: make deploy-app</span><br><span class="line">  environment:</span><br><span class="line">    name: review</span><br><span class="line">    on_stop: stop_review_app</span><br><span class="line"></span><br><span class="line">stop_review_app:</span><br><span class="line">  stage: deploy</span><br><span class="line">  variables:</span><br><span class="line">    GIT_STRATEGY: none</span><br><span class="line">  script: make delete-app</span><br><span class="line">  when: manual</span><br><span class="line">  environment:</span><br><span class="line">    name: review</span><br><span class="line">    action: stop</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们设置了 review-appjob 以部署到 review 环境中，并且在 on-stop 下定义了一个新的 stop-review-appjob。一旦 review_app 完成，它将根据 “when” 下定义的内容触发 stop_review_app。在本例中，我们将其设置为手动，以便它需要通过 Gitlab 的 Web 界面进行手动操作才能运行。</p><p>同样在这个例子中，GIT_STRATEGY 被设置为 “none”，这样当自动触发 stop_review_app 时，Gitlab Runner 不会在删除分支后尝试 check out 代码。</p><p>stop_review_app 需要定义以下关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">when - reference</span><br><span class="line">environment:name</span><br><span class="line">environment:action</span><br><span class="line">stage应与review_app相同，以便在删除分支时环境自动停止。</span><br></pre></td></tr></table></figure><p>动态环境</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">deploy as review app:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: make deploy</span><br><span class="line">  environment:</span><br><span class="line">    name: review&#x2F;$CI_COMMIT_REF_NAME</span><br><span class="line">    url: https:&#x2F;&#x2F;$CI_ENVIRONMENT_SLUG.example.com&#x2F;</span><br></pre></td></tr></table></figure><p>deploy as review app 将标记为 deployment，以动态创建 review/$CI_COMMIT_REF_NAME 环境，其中 $CI_COMMIT_REF_NAME 是运行程序设置的环境变量。$CI_ENVIRONMENT_SLUG 变量基于环境名称，但适合包含在 URL 中。在这种情况下，如果在名为 pow 的分支中运行 deploy as review app，则可以使用类似 <a href="https://review/">https://review</a> pow.example.com/ 的 URL 访问此环境。</p><p>当然，这意味着承载应用程序的底层服务器配置正确。</p><p>常见的用例是为分支创建动态环境，并将它们用作审查应用程序。您可以在 <a href="https://gitlab.com/gitlab-examples/review-apps-nginx/%E4%B8%8A%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8review-apps%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%E3%80%82">https://gitlab.com/gitlab-examples/review-apps-nginx/ 上看到一个使用 review-apps 的简单示例。</a></p><h3 id="7-13-cache"><a href="#7-13-cache" class="headerlink" title="7.13. cache"></a>7.13. cache</h3><p><a href="https://gitlab.com/help/ci/caching/index.md">TIP: Learn more:Read how caching works and find out some good practices in the caching dependencies documentation.</a></p><p>cache 用于指定应在 job 之间缓存的文件和目录的列表。只能使用项目工作区内的路径。</p><p>如果 cache 是在 job 范围之外定义的，则意味着它是全局设置的，所有 job 都将使用该定义。</p><h4 id="cache-paths"><a href="#cache-paths" class="headerlink" title="cache:paths"></a>cache:paths</h4><p>使用 paths 指令选择将缓存哪些文件或目录。可以使用通配符跟踪 glob 模式和 filepath.match。</p><p>缓存以.apk 和.config 文件结尾的二进制文件中的所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  script: test</span><br><span class="line">  cache:</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;*.apk</span><br><span class="line">      - .config</span><br></pre></td></tr></table></figure><p>本地定义的缓存覆盖全局定义的选项。以下 rspecjob 将只缓存二进制文件 /：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">cache:</span><br><span class="line">  paths:</span><br><span class="line">    - my&#x2F;files</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  script: test</span><br><span class="line">  cache:</span><br><span class="line">    key: rspec</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，由于缓存是在 job 之间共享的，如果您对不同的 job 使用不同的路径，则还应设置不同的 cache:key，否则缓存内容会被覆盖。</p></blockquote><h4 id="cache-key"><a href="#cache-key" class="headerlink" title="cache:key"></a>cache:key</h4><p>由于缓存是在 job 之间共享的，如果您对不同的 job 使用不同的路径，则还应设置不同的 cache:key，否则缓存内容会被覆盖。</p><p>key 指令允许您定义 job 之间缓存的关联性，允许为所有 job 都有一个缓存、每个 job 缓存、每个分支缓存。或者其他适合您工作流程的方式。通过这种方式，您可以微调缓存，允许您在不同的 job 之间甚至不同的分支之间缓存数据。</p><p>cache:key 变量可以使用任何预定义的变量，如果没有设置默认键，则它只是文字默认值，这意味着默认情况下，从 gitlab 9.0 开始，每个管道和 job 之间共享所有内容。</p><blockquote><p>cache:key 变量不能包含 / 字符，或者编码为 %2f 的等效 URI；也禁止使用仅由点（.，%2e）构成的值。</p></blockquote><p>例如，要启用每个分支缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">cache:</span><br><span class="line">  key: &quot;$CI_COMMIT_REF_SLUG&quot;</span><br><span class="line">  paths:</span><br><span class="line">    - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>如果使用 Windows 批处理运行 shell 脚本，则需要将 $ 替换为 %：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">cache:</span><br><span class="line">  key: &quot;%CI_COMMIT_REF_SLUG%&quot;</span><br><span class="line">  paths:</span><br><span class="line">    - binaries&#x2F;</span><br></pre></td></tr></table></figure><h4 id="cache-untracked"><a href="#cache-untracked" class="headerlink" title="cache:untracked"></a>cache:untracked</h4><p>set untracked:true 缓存 Git 存储库中所有未跟踪的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  script: test</span><br><span class="line">  cache:</span><br><span class="line">    untracked: true</span><br></pre></td></tr></table></figure><p>缓存 binaries 下的所有 Git 未跟踪文件和文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  script: test</span><br><span class="line">  cache:</span><br><span class="line">    untracked: true</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><h4 id="cache-policy"><a href="#cache-policy" class="headerlink" title="cache:policy"></a>cache:policy</h4><p>缓存 job 的默认行为是在执行开始时下载文件，并在结束时重新上传文件。这允许为将来的运行保留 job 所做的任何更改，称为 pull-push 缓存策略。</p><p>如果知道 job 不会更改缓存文件，可以通过设置 policy:pull 来跳过上传步骤。通常，这将与早期阶段的普通缓存 job 成对出现，以确保缓存不时更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">stages:</span><br><span class="line">  - setup</span><br><span class="line">  - test</span><br><span class="line"></span><br><span class="line">prepare:</span><br><span class="line">  stage: setup</span><br><span class="line">  cache:</span><br><span class="line">    key: gems</span><br><span class="line">    paths:</span><br><span class="line">      - vendor&#x2F;bundle</span><br><span class="line">  script:</span><br><span class="line">    - bundle install --deployment</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  stage: test</span><br><span class="line">  cache:</span><br><span class="line">    key: gems</span><br><span class="line">    paths:</span><br><span class="line">      - vendor&#x2F;bundle</span><br><span class="line">    policy: pull</span><br><span class="line">  script:</span><br><span class="line">    - bundle exec rspec ...</span><br></pre></td></tr></table></figure><p>这有助于加快 job 执行速度并减少缓存服务器上的负载，特别是当您有大量的缓存使用并行执行的 job 时。</p><p>此外，如果有一个 job 无条件地重新创建缓存而不引用其先前的内容，则可以使用 policy: push 跳过下载步骤。</p><h3 id="7-14-artifacts"><a href="#7-14-artifacts" class="headerlink" title="7.14. artifacts"></a>7.14. artifacts</h3><p>artifacts 用于指定在 job 成功、失败或总是失败时应附加到该 job 的文件和目录列表。</p><p>artifacts 将在 job 完成后发送到 Gitlab，并可在 Gitlab UI 中下载。<br><a href="https://gitlab.com/help/user/project/pipelines/job_artifacts.md">Read more about artifacts.</a></p><h4 id="artifacts-paths"><a href="#artifacts-paths" class="headerlink" title="artifacts:paths"></a>artifacts:paths</h4><p>只能使用项目工作区内的路径。可以使用通配符跟踪 glob 模式和 filepath.match。</p><p>要在不同 job 之间传递 artifacts，see dependencies.。</p><p>发送 binaries and .config: 下所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">artifacts:</span><br><span class="line">  paths:</span><br><span class="line">    - binaries&#x2F;</span><br><span class="line">    - .config</span><br></pre></td></tr></table></figure><p>要禁用 artifacts 传递，请使用 dependencies: []</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  stage: build</span><br><span class="line">  script: make build</span><br><span class="line">  dependencies: []</span><br></pre></td></tr></table></figure><p>您可能希望只为 tags 的版本创建 artifacts，以避免用临时的 artifacts 填充构建服务器存储。</p><p>仅为 tags 创建 artifacts（default-job 不会创建 artifacts）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">default-job:</span><br><span class="line">  script:</span><br><span class="line">    - mvn test -U</span><br><span class="line">  except:</span><br><span class="line">    - tags</span><br><span class="line"></span><br><span class="line">release-job:</span><br><span class="line">  script:</span><br><span class="line">    - mvn package -U</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - target&#x2F;*.war</span><br><span class="line">  only:</span><br><span class="line">    - tags</span><br></pre></td></tr></table></figure><h4 id="artifacts-name"><a href="#artifacts-name" class="headerlink" title="artifacts:name"></a>artifacts:name</h4><p>name 指令允许您定义创建的 artifacts 存档的名称。这样，当您想从 Gitlab 下载归档文件时，每个归档文件都可以有一个唯一的名称。artifacts:name 变量可以使用任何预定义的变量。默认名称为 artifacts，下载时将变为 artifacts.zip。</p><blockquote><p>如果您的分支名称包含正斜杠（例如 feature/my feature），建议使用 $ci-commit-ref-slug 而不是 $ci-commit-ref-name 来正确命名 artifacts。</p></blockquote><p>要使用当前 job 的名称创建存档，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;$CI_JOB_NAME&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>要使用当前分支或标记的名称（仅包括 binaries 文件夹）创建存档，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;$CI_COMMIT_REF_NAME&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>要使用当前 job 的名称和当前分支或标记（仅包括 binaries 文件夹）创建存档，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;$CI_JOB_NAME-$CI_COMMIT_REF_NAME&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>要创建具有当前阶段名称和分支名称的存档，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;$CI_JOB_STAGE-$CI_COMMIT_REF_NAME&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>如果使用 Windows 批处理运行 shell 脚本，则需要将 $ 替换为 %：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;%CI_JOB_STAGE%-%CI_COMMIT_REF_NAME%&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><p>如果使用 Windows PowerShell 运行 shell 脚本，则需要将 $ 替换为 $env:：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    name: &quot;$env:CI_JOB_STAGE-$env:CI_COMMIT_REF_NAME&quot;</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br></pre></td></tr></table></figure><h4 id="artifacts-untracked"><a href="#artifacts-untracked" class="headerlink" title="artifacts:untracked"></a>artifacts:untracked</h4><p>artifacts:untracked 用于将所有 git 未跟踪文件添加为 artifacts（沿着 artifacts:paths 中定义的路径）。</p><blockquote><p>artifacts:untracked 忽略存储库的.gitignore 文件中的配置。</p></blockquote><p>发送所有 git 未跟踪文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">artifacts:</span><br><span class="line">  untracked: true</span><br></pre></td></tr></table></figure><p>发送所有 git 未跟踪文件和二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">artifacts:</span><br><span class="line">  untracked: true</span><br><span class="line">  paths:</span><br><span class="line">    - binaries&#x2F;</span><br></pre></td></tr></table></figure><h4 id="artifacts-when"><a href="#artifacts-when" class="headerlink" title="artifacts:when"></a>artifacts:when</h4><p>artifacts:when 用于在 job 失败或尽管失败时上载 artifacts 的时间。</p><p>artifacts:when 可以设置为以下值之一：</p><p>on_success - 仅当 job 成功时上载 artifacts。这是默认设置。</p><p>on_failure - 仅当 job 失败时才上载 artifacts。</p><p>always - 上载 artifacts，不管 job 状态如何。</p><p>仅当 job 失败时上载项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    when: on_failure</span><br></pre></td></tr></table></figure><h4 id="artifacts-expire-in"><a href="#artifacts-expire-in" class="headerlink" title="artifacts:expire_in"></a>artifacts:expire_in</h4><p>expire_-in 允许您指定 artifacts 在过期之前应该存在多长时间，从而从它们上传和存储到 Gitlab 的时间开始删除。如果未定义到期时间，则默认为实例范围的设置。（默认为 30 天，永远在 gitlab.com 上）。</p><p>您可以使用 “job” 页上的 “保留” 按钮来覆盖过期时间并永久保留项目。</p><p>过期后，artifacts 默认每小时删除一次（通过 cronjob），并且不再可访问。</p><p>expire_in 的值是以秒为单位的已用时间，除非提供了一个单位。可分析值示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">&#39;42&#39;</span><br><span class="line">&#39;3 mins 4 sec&#39;</span><br><span class="line">&#39;2 hrs 20 min&#39;</span><br><span class="line">&#39;2h20min&#39;</span><br><span class="line">&#39;6 mos 1 day&#39;</span><br><span class="line">&#39;47 yrs 6 mos and 4d&#39;</span><br><span class="line">&#39;3 weeks and 2 days&#39;</span><br></pre></td></tr></table></figure><p>要在上载后 1 周使项目过期，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job:</span><br><span class="line">  artifacts:</span><br><span class="line">    expire_in: 1 week</span><br></pre></td></tr></table></figure><h4 id="artifacts-reports"><a href="#artifacts-reports" class="headerlink" title="artifacts:reports"></a>artifacts:reports</h4><p>reports 关键字用于从 job 收集测试报告并在 Gitlab 的 UI（合并请求、管道视图）中公开它们。阅读如何将其与 JUnit 报告一起使用。</p><blockquote><p>无论 job 结果如何（成功或失败），都会收集测试报告。您可以使用 artifacts:expire\u 来设置其 artifacts 的到期日期。<br>如果还希望能够浏览报告输出文件，请包含 artifacts:paths 关键字。</p></blockquote><h4 id="artifacts-reports-junit"><a href="#artifacts-reports-junit" class="headerlink" title="artifacts:reports:junit"></a>artifacts:reports:junit</h4><p>JUnit 报告将 JUnit XML 文件收集为 artifacts。虽然 JUnit 最初是在爪哇开发的，但是有许多其他第三方端口，如 yml、Python、Ruby 等。</p><p>有关更多详细信息和示例，请参阅 JUnit 测试报告。下面是从 Ruby 的 rspec 测试工具收集 JUnit XML 文件的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">  - bundle install</span><br><span class="line">  - rspec --format RspecJunitFormatter --out rspec.xml</span><br><span class="line">  artifacts:</span><br><span class="line">    reports:</span><br><span class="line">      junit: rspec.xml</span><br></pre></td></tr></table></figure><p>收集到的 JUnit 报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求中。</p><p>如果 JUnit 工具使用导出到多个 XML 文件，则可以在一个 job 中指定多个测试报告路径，这些路径将自动连接到一个文件中。使用文件名模式（junit:rspec-<em>.xml）、文件名数组（junit:[rspec-1.xml、rspec-2.xml、rspec-3.xml]）或其组合（junit:[rspec.xml，测试结果 /test-</em>.xml]）。</p><h4 id="artifacts-reports-codequality-STARTER"><a href="#artifacts-reports-codequality-STARTER" class="headerlink" title="artifacts:reports:codequality (STARTER)"></a>artifacts:reports:codequality (STARTER)</h4><p>代码质量报告将代码质量问题收集为 artifacts。</p><p>收集的代码质量报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求中。</p><h4 id="artifacts-reports-sast-ULTIMATE-终极"><a href="#artifacts-reports-sast-ULTIMATE-终极" class="headerlink" title="artifacts:reports:sast (ULTIMATE) 终极"></a>artifacts:reports:sast (ULTIMATE) 终极</h4><p>sast 报告将 sast 漏洞收集为 artifacts。</p><p>收集的 SAST 报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p><h4 id="artifacts-reports-dependency-scanning-ULTIMATE-终极"><a href="#artifacts-reports-dependency-scanning-ULTIMATE-终极" class="headerlink" title="artifacts:reports:dependency_scanning (ULTIMATE) 终极"></a>artifacts:reports:dependency_scanning (ULTIMATE) 终极</h4><p>依赖项扫描报告将依赖项扫描漏洞收集为 artifacts。</p><p>收集到的依赖项扫描报告将作为 artifacts 上载到 Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表板提供数据。</p><h4 id="artifacts-reports-container-scanning-ULTIMATE"><a href="#artifacts-reports-container-scanning-ULTIMATE" class="headerlink" title="artifacts:reports:container_scanning (ULTIMATE)"></a>artifacts:reports:container_scanning (ULTIMATE)</h4><p>容器扫描报告将容器扫描漏洞收集为 artifacts。</p><p>收集的容器扫描报告将作为一个 artifacts 上载到 Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表板提供数据。</p><h4 id="artifacts-reports-dast-ULTIMATE"><a href="#artifacts-reports-dast-ULTIMATE" class="headerlink" title="artifacts:reports:dast (ULTIMATE)"></a>artifacts:reports:dast (ULTIMATE)</h4><p>DAST 报告将 DAST 漏洞收集为 artifacts。</p><p>收集的 DAST 报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p><h4 id="artifacts-reports-license-management-ULTIMATE"><a href="#artifacts-reports-license-management-ULTIMATE" class="headerlink" title="artifacts:reports:license_management (ULTIMATE)"></a>artifacts:reports:license_management (ULTIMATE)</h4><p>许可证管理报告将许可证作为 artifacts 收集。</p><p>收集的许可证管理报告将作为一个 artifacts 上载到 Gitlab，并将自动显示在合并请求、管道视图中，并为安全仪表盘提供数据。</p><h4 id="artifacts-reports-performance-PREMIUM"><a href="#artifacts-reports-performance-PREMIUM" class="headerlink" title="artifacts:reports:performance (PREMIUM)"></a>artifacts:reports:performance (PREMIUM)</h4><p>性能报告将性能指标收集为 artifacts。</p><p>收集到的性能报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求中。</p><h4 id="artifacts-reports-metrics-PREMIUM"><a href="#artifacts-reports-metrics-PREMIUM" class="headerlink" title="artifacts:reports:metrics (PREMIUM)"></a>artifacts:reports:metrics (PREMIUM)</h4><p>性能报告将性能指标收集为 artifacts。<br>收集到的性能报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求中。</p><h4 id="artifacts-reports-metrics-PREMIUM-1"><a href="#artifacts-reports-metrics-PREMIUM-1" class="headerlink" title="artifacts:reports:metrics (PREMIUM)"></a>artifacts:reports:metrics (PREMIUM)</h4><p>度量报告将度量收集为 artifacts。</p><p>收集的度量报告将作为 artifacts 上传到 Gitlab，并将自动显示在合并请求中。</p><h3 id="7-15-dependencies"><a href="#7-15-dependencies" class="headerlink" title="7.15. dependencies"></a>7.15. dependencies</h3><p>此功能应该与 artifacts 一起使用，并允许您定义要在不同 job 之间传递的 artifacts。</p><p>请注意，默认情况下，来自所有先前阶段的 artifacts 都会被传递。</p><p>若要使用此功能，请在 job 的上下文中定义依赖项，并传递一个列表，其中列出了应从中下载 artifacts 的所有先前 job。只能从当前 job 之前执行的阶段定义 job。如果从当前阶段或下一阶段定义 job，将显示一个错误。</p><p>定义空数组将跳过下载该 job 的任何 artifacts。使用依赖项时不考虑上一个 job 的状态，因此如果它失败或是未运行的手动 job，则不会发生错误。</p><p>在下面的示例中，我们用 artifacts 定义了两个 job，build:osx 和 build:linux。执行 test:osx 时，来自 build:osx 的 artifacts</p><p>将在生成上下文中下载和提取。对于 test:linux 和 build:linux 中的 artifacts 也是如此。</p><p>由于阶段优先，job 部署将从所有以前的 job 下载项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">build:osx:</span><br><span class="line">  stage: build</span><br><span class="line">  script: make build:osx</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br><span class="line"></span><br><span class="line">build:linux:</span><br><span class="line">  stage: build</span><br><span class="line">  script: make build:linux</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - binaries&#x2F;</span><br><span class="line"></span><br><span class="line">test:osx:</span><br><span class="line">  stage: test</span><br><span class="line">  script: make test:osx</span><br><span class="line">  dependencies:</span><br><span class="line">    - build:osx</span><br><span class="line"></span><br><span class="line">test:linux:</span><br><span class="line">  stage: test</span><br><span class="line">  script: make test:linux</span><br><span class="line">  dependencies:</span><br><span class="line">    - build:linux</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: make deploy</span><br></pre></td></tr></table></figure><h4 id="When-a-dependent-job-will-fail"><a href="#When-a-dependent-job-will-fail" class="headerlink" title="When a dependent job will fail"></a>When a dependent job will fail</h4><p>如果设置为依赖项的 job 的 artifacts 已过期或清除，则依赖 job 将失败。</p><blockquote><p>您可以要求管理员翻转此开关并恢复旧行为。</p></blockquote><h3 id="7-16-coverage"><a href="#7-16-coverage" class="headerlink" title="7.16. coverage"></a>7.16. coverage</h3><p>Coverage 允许您配置如何从 job 输出中提取代码覆盖率。</p><p>正则表达式是此处唯一有效的值类型。因此，为了一致和显式地表示正则表达式字符串，必须使用环绕 /。如果你想从字面上匹配特殊字符，你必须转义它们。</p><p>A simple example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">job1:</span><br><span class="line">  script: rspec</span><br><span class="line">  coverage: &#39;&#x2F;Code coverage: \d+\.\d+&#x2F;&#39;</span><br></pre></td></tr></table></figure><h3 id="7-17-retry"><a href="#7-17-retry" class="headerlink" title="7.17. retry"></a>7.17. retry</h3><p>重试” 允许您配置一个 job 在发生故障时将重试多少次。</p><p>当一个 job 失败并配置了重试时，它将被再次处理到 retry 关键字指定的次数。</p><p>如果 retry 设置为 2，并且 job 在第二次运行（第一次重试）中成功，则不会重试。</p><p>再一次。重试值必须是一个正整数，等于或大于 0，但小于或等于 2（最多两次重试，总共三次）。</p><p>在所有故障情况下重试的简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">test:</span><br><span class="line">  script: rspec</span><br><span class="line">  retry: 2</span><br></pre></td></tr></table></figure><p>默认情况下，将在所有失败情况下重试 job。要更好地控制重试失败的次数，retry 可以是具有以下键的哈希：</p><p>max：最大重试次数。</p><p>when：失败的案例要重试。</p><p>要最多重试两次运行程序系统故障，请执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">test:</span><br><span class="line">  script: rspec</span><br><span class="line">  retry:</span><br><span class="line">    max: 2</span><br><span class="line">    when: runner_system_failure</span><br></pre></td></tr></table></figure><p>如果存在除运行程序系统故障以外的其他故障，则不会重试 job。</p><p>要在多个故障情况下重试，时间也可以是一个故障数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">test:</span><br><span class="line">  script: rspec</span><br><span class="line">  retry:</span><br><span class="line">    max: 2</span><br><span class="line">    when:</span><br><span class="line">      - runner_system_failure</span><br><span class="line">      - stuck_or_timeout_failure</span><br></pre></td></tr></table></figure><p>Possible values for when are:</p><p>always：在出现任何故障时重试（默认）。</p><p>unknown_failure：失败原因未知时重试。</p><p>script_failure：当脚本失败时重试。</p><p>api_failure：在 api 失败时重试。</p><p>stuck_or_timeout_failure：当 job 卡住或超时时重试。</p><p>runner_system_failure：如果运行程序系统故障（例如设置 job 失败），请重试。</p><p>missing_dependency_failure：如果缺少依赖项，请重试。</p><p>runner_unsupported：如果运行程序不受支持，请重试。</p><h3 id="7-18-parallel"><a href="#7-18-parallel" class="headerlink" title="7.18. parallel"></a>7.18. parallel</h3><p>Parallel 允许您配置要并行运行的 job 实例数。该值必须大于或等于两（2）且小于或等于 50。</p><p>这将创建并行运行的同一 job 的 n 个实例。它们按顺序从 job_name 1/n 到 job_name n/n 命名。</p><p>对于每个 job，都会设置 CI_NODE_INDEX and CI_NODE_TOTAL environment variables。</p><p>一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">test:</span><br><span class="line">  script: rspec</span><br><span class="line">  parallel: 5</span><br></pre></td></tr></table></figure><blockquote><p>跨并行 job 并行化测试套件。不同的语言有不同的工具来促进这一点。</p></blockquote><h3 id="7-19-trigger-PREMIUM"><a href="#7-19-trigger-PREMIUM" class="headerlink" title="7.19. trigger (PREMIUM)"></a>7.19. trigger (PREMIUM)</h3><p>trigger 允许您定义下游管道 trigger。当从 trigger 定义创建的 job 由 Gitlab 启动时，将创建下游管道。<br><a href="https://gitlab.com/help/ci/multi_project_pipelines.md#creating-multi-project-pipelines-from-gitlab-ciyml">Learn more about multi-project pipelines.</a></p><p>简单触发器语法</p><p>配置下游触发器以使用具有下游项目完整路径的触发器关键字的最简单方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  stage: test</span><br><span class="line">  script: bundle exec rspec</span><br><span class="line"></span><br><span class="line">staging:</span><br><span class="line">  stage: deploy</span><br><span class="line">  trigger: my&#x2F;deployment</span><br></pre></td></tr></table></figure><p>复杂触发器语法</p><p>可以配置 Gitlab 用于创建下游管道的分支名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  stage: test</span><br><span class="line">  script: bundle exec rspec</span><br><span class="line"></span><br><span class="line">staging:</span><br><span class="line">  stage: deploy</span><br><span class="line">  trigger:</span><br><span class="line">    project: my&#x2F;deployment</span><br><span class="line">    branch: stable</span><br></pre></td></tr></table></figure><h3 id="7-20-include"><a href="#7-20-include" class="headerlink" title="7.20. include"></a>7.20. include</h3><p>使用 include 关键字，可以允许包含外部 yaml 文件。include 要求外部 yaml 文件具有扩展名.yml 或.yaml，否则将不包括外部文件。</p><p>include 中定义的文件包括：</p><p>–与.gitlab-ci.yml 中的合并。</p><p>–始终首先评估并与.gitlab-ci.yml 的内容合并，而不管 include 关键字的位置如何。</p><blockquote><p>使用合并可使用本地定义自定义和覆盖包含的 CI/CD 配置。<br>不支持跨 include 源的不同 yaml 文件使用 yaml 别名。您只能引用同一文件中的别名。您可以使用 extends 关键字，而不是使用 yaml 锚。</p></blockquote><p>包含支持四个包含方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">local</span><br><span class="line">file</span><br><span class="line">template</span><br><span class="line">remote</span><br></pre></td></tr></table></figure><p><a href="https://gitlab.com/help/ci/yaml/README.md#include-examples">See usage examples.</a></p><blockquote><p>所有方法包含的.gitlab-ci.yml 配置在管道创建时进行评估。配置是一个及时的快照，并持久存在于数据库中。在创建下一个管道之前，对引用的.gitlab-ci.yml 配置所做的任何更改都不会反映在 gitlab 中。</p></blockquote><h4 id="include-local"><a href="#include-local" class="headerlink" title="include:local"></a>include:local</h4><p>include:local 包含来自与.gitlab-ci.yml 相同存储库的文件。它是使用相对于根目录的完整路径来引用的（/）。</p><p>您只能在配置文件所在的分支上使用 Git 当前跟踪的文件。换句话说，当使用 include:local 时，请确保.gitlab-ci.yml 和本地文件都在同一个分支上。</p><p>所有嵌套的 include 都将在同一个项目的范围内执行，因此可以使用本地、项目、远程或模板 include。</p><blockquote><p>不支持通过 git 子模块路径包含本地文件。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - local: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br></pre></td></tr></table></figure><h4 id="include-file"><a href="#include-file" class="headerlink" title="include:file"></a>include:file</h4><p>要在同一 Gitlab 实例下包含来自另一个私有项目的文件，请使用 include:file。使用相对于根目录的完整路径（/）引用此文件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - project: &#39;my-group&#x2F;my-project&#39;</span><br><span class="line">    file: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br></pre></td></tr></table></figure><p>还可以指定 ref，默认值为项目的标题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - project: &#39;my-group&#x2F;my-project&#39;</span><br><span class="line">    ref: master</span><br><span class="line">    file: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br><span class="line"></span><br><span class="line">  - project: &#39;my-group&#x2F;my-project&#39;</span><br><span class="line">    ref: v1.0.0</span><br><span class="line">    file: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br><span class="line"></span><br><span class="line">  - project: &#39;my-group&#x2F;my-project&#39;</span><br><span class="line">    ref: 787123b47f14b552955ca2786bc9542ae66fee5b # Git SHA</span><br><span class="line">    file: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br></pre></td></tr></table></figure><p>所有嵌套的 include 都将在目标项目的范围内执行，因此可以使用本地（相对于目标项目）、项目、远程或模板 include。</p><h4 id="include-template"><a href="#include-template" class="headerlink" title="include:template"></a>include:template</h4><p>include:template 可用于包含随 Gitlab 一起提供的.gitlab-ci.yml 模板。</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line"># File sourced from GitLab&#39;s template collection</span><br><span class="line">include:</span><br><span class="line">  - template: Auto-DevOps.gitlab-ci.yml</span><br></pre></td></tr></table></figure><p>所有嵌套的 include 只能在用户的权限下执行，因此可以使用 project、remote 或 template include。</p><h4 id="include-remote"><a href="#include-remote" class="headerlink" title="include:remote"></a>include:remote</h4><p>nclude:remote 可用于包含来自不同位置的文件，使用 http/https，使用完整的 URL 引用。远程文件必须通过简单的 GET 请求公开访问，因为不支持远程 URL 中的身份验证架构。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - remote: &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.gitlab-ci-template.yml&#39;</span><br></pre></td></tr></table></figure><p>所有嵌套的 include 将作为公共用户在没有上下文的情况下执行，因此只允许使用其他远程、公共项目或模板。</p><h4 id="嵌套包含"><a href="#嵌套包含" class="headerlink" title="嵌套包含"></a>嵌套包含</h4><p>嵌套的 include 允许您组成一组 include。总共允许 50 个。</p><p>重复包含被视为配置错误。</p><p>包括示例</p><p>下面还有一些例子。</p><p>单个字符串或多个值的数组，您可以将额外的 yaml 文件作为单个字符串或多个值的数组包含在内。下面的例子都是有效的。</p><p>包含 include:local 方法的单个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include: &#39;&#x2F;templates&#x2F;.after-script-template.yml&#39;</span><br></pre></td></tr></table></figure><p>包含 include 方法的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br><span class="line">  - &#39;&#x2F;templates&#x2F;.after-script-template.yml&#39;</span><br></pre></td></tr></table></figure><p>显式指定包含方法的单个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  remote: &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br></pre></td></tr></table></figure><p>带有 include:remote 的数组是单个项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - remote: &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br></pre></td></tr></table></figure><p>具有多个包含方法的数组已明确指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - remote: &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br><span class="line">  - local: &#39;&#x2F;templates&#x2F;.after-script-template.yml&#39;</span><br><span class="line">  - template: Auto-DevOps.gitlab-ci.yml</span><br></pre></td></tr></table></figure><p>数组混合语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br><span class="line">  - &#39;&#x2F;templates&#x2F;.after-script-template.yml&#39;</span><br><span class="line">  - template: Auto-DevOps.gitlab-ci.yml</span><br><span class="line">  - project: &#39;my-group&#x2F;my-project&#39;</span><br><span class="line">    ref: master</span><br><span class="line">    file: &#39;&#x2F;templates&#x2F;.gitlab-ci-template.yml&#39;</span><br></pre></td></tr></table></figure><h4 id="重新使用前脚本模板"><a href="#重新使用前脚本模板" class="headerlink" title="重新使用前脚本模板"></a>重新使用前脚本模板</h4><p>在下面的示例中，.before-script-template.yml 的内容将与.gitlab-ci.yml 的内容一起自动获取和评估。</p><p><a href="https://gitlab.com/awesome">https://gitlab.com/awesome</a> project/raw/master/.before-script-template.yml 的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">before_script:</span><br><span class="line">  - apt-get update -qq &amp;&amp; apt-get install -y -qq sqlite3 libsqlite3-dev nodejs</span><br><span class="line">  - gem install bundler --no-document</span><br><span class="line">  - bundle install --jobs $(nproc)  &quot;$&#123;FLAGS[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p>Content of .gitlab-ci.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include: &#39;https:&#x2F;&#x2F;gitlab.com&#x2F;awesome-project&#x2F;raw&#x2F;master&#x2F;.before-script-template.yml&#39;</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  script:</span><br><span class="line">    - bundle exec rspec</span><br></pre></td></tr></table></figure><p>覆盖外部模板值以下示例显示了特定的 yaml 定义的变量以及在.gitlab-ci.yml 中自定义的 include 文件中生产 job 的详细信息。</p><p><a href="https://company.com/autodevops-template.yml%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">https://company.com/autodevops-template.yml 的内容：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  POSTGRES_USER: user</span><br><span class="line">  POSTGRES_PASSWORD: testing_password</span><br><span class="line">  POSTGRES_DB: $CI_ENVIRONMENT_SLUG</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  stage: production</span><br><span class="line">  script:</span><br><span class="line">    - install_dependencies</span><br><span class="line">    - deploy</span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br><span class="line">    url: https:&#x2F;&#x2F;$CI_PROJECT_PATH_SLUG.$KUBE_INGRESS_BASE_DOMAIN</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br></pre></td></tr></table></figure><p>Content of .gitlab-ci.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include: &#39;https:&#x2F;&#x2F;company.com&#x2F;autodevops-template.yml&#39;</span><br><span class="line"></span><br><span class="line">image: alpine:latest</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">  POSTGRES_USER: root</span><br><span class="line">  POSTGRES_PASSWORD: secure_password</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - production</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  environment:</span><br><span class="line">    url: https:&#x2F;&#x2F;domain.com</span><br></pre></td></tr></table></figure><p>在这种情况下，变量 postgres-user 和 postgres-password 以及 autodevops-template.yml 中定义的生产 job 的环境 url 已被.gitlab-ci.yml 中定义的新值覆盖。</p><p>合并允许扩展和重写字典映射，但不能向包含的数组添加或修改项。例如，要向生产 job 脚本添加其他项，必须重复现有的脚本项：</p><p><a href="https://company.com/autodevops-template.yml%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">https://company.com/autodevops-template.yml 的内容：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">production:</span><br><span class="line">  stage: production</span><br><span class="line">  script:</span><br><span class="line">    - install_dependencies</span><br><span class="line">    - deploy</span><br></pre></td></tr></table></figure><p>Content of .gitlab-ci.yml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include: &#39;https:&#x2F;&#x2F;company.com&#x2F;autodevops-template.yml&#39;</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - production</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line">  script:</span><br><span class="line">    - install_dependencies</span><br><span class="line">    - deploy</span><br><span class="line">    - notify_owner</span><br></pre></td></tr></table></figure><p>在这种情况下，如果在.gitlab-ci.yml 中不重复 install_dependencies 和 deploy，它们将不会成为组合 CI 配置中生产 job 脚本的一部分。</p><h4 id="使用嵌套的-include"><a href="#使用嵌套的-include" class="headerlink" title="使用嵌套的 include"></a>使用嵌套的 include</h4><p>下面的示例说明如何使用不同方法的组合从不同的源嵌套 include。</p><p>在本例中，.gitlab-ci.yml 包含本地文件 /.gitlab-ci/another-config.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - local: &#x2F;.gitlab-ci&#x2F;another-config.yml</span><br></pre></td></tr></table></figure><p>.gitlab ci/another-config.yml 包含一个模板和另一个项目的 /templates/docker-workflow.yml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - template: Bash.gitlab-ci.yml</span><br><span class="line">  - project: group&#x2F;my-project</span><br><span class="line">    file: &#x2F;templates&#x2F;docker-workflow.yml</span><br></pre></td></tr></table></figure><p>group/my 项目中的 /templates/docker-workflow.yml 包含 group/my 项目的两个本地文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include:</span><br><span class="line">  - local: &#x2F;templates&#x2F;docker-build.yml</span><br><span class="line">  - local: &#x2F;templates&#x2F;docker-testing.yml</span><br></pre></td></tr></table></figure><p>group/my 项目中的 /templates/docker-build.yml 添加了一个 docker 构建 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">docker-build:</span><br><span class="line">  script: docker build -t my-image .</span><br></pre></td></tr></table></figure><p>我们的第二个 /templates/docker-test.yml 出现在 group/my 项目中，它添加了一个 docker 测试 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">docker-test:</span><br><span class="line">  script: docker run my-image &#x2F;run&#x2F;tests.sh</span><br></pre></td></tr></table></figure><h3 id="7-21-extends"><a href="#7-21-extends" class="headerlink" title="7.21. extends"></a>7.21. extends</h3><p>扩展定义了使用扩展的 job 将从中继承的项名称。</p><p>它是使用 yaml 锚的替代方法，并且更灵活和易读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">.tests:</span><br><span class="line">  script: rake test</span><br><span class="line">  stage: test</span><br><span class="line">  only:</span><br><span class="line">    refs:</span><br><span class="line">      - branches</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  extends: .tests</span><br><span class="line">  script: rake rspec</span><br><span class="line">  only:</span><br><span class="line">    variables:</span><br><span class="line">      - $RSPEC</span><br></pre></td></tr></table></figure><p>在上面的示例中，rspecjob 继承自.tests 模板 job。Gitlab 将根据这些键执行反向深进。Gitlab 想要：</p><p>递归地将 rspec 内容放入.tests。</p><p>不去键的值。</p><p>这将导致以下 job：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  script: rake rspec</span><br><span class="line">  stage: test</span><br><span class="line">  only:</span><br><span class="line">    refs:</span><br><span class="line">      - branches</span><br><span class="line">    variables:</span><br><span class="line">      - $RSPEC</span><br></pre></td></tr></table></figure><blockquote><p>请注意，script:rake 测试已被 script:rake rspec 覆盖。</p></blockquote><p>如果您想包括 rake 测试，请参见之前的脚本和之后的脚本。</p><p>. 本例中的测试是隐藏的密钥，但也可以从常规 job 继承。扩展支持多级别继承，但不建议使用三个以上的级别。支持的最大嵌套级别为 10。</p><p>以下示例具有两个继承级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">.tests:</span><br><span class="line">  only:</span><br><span class="line">    - pushes</span><br><span class="line"></span><br><span class="line">.rspec:</span><br><span class="line">  extends: .tests</span><br><span class="line">  script: rake rspec</span><br><span class="line"></span><br><span class="line">rspec 1:</span><br><span class="line">  variables:</span><br><span class="line">    RSPEC_SUITE: &#39;1&#39;</span><br><span class="line">  extends: .rspec</span><br><span class="line"></span><br><span class="line">rspec 2:</span><br><span class="line">  variables:</span><br><span class="line">    RSPEC_SUITE: &#39;2&#39;</span><br><span class="line">  extends: .rspec</span><br><span class="line"></span><br><span class="line">spinach:</span><br><span class="line">  extends: .tests</span><br><span class="line">  script: rake spinach</span><br></pre></td></tr></table></figure><p>在 Gitlab 12.0 及更高版本中，也可以使用多个父级进行扩展。用于合并的算法是 “最近的作用域获胜”，因此来自最后一个成员的键将始终隐藏在其他级别上定义的任何内容。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">.only-important:</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">    - stable</span><br><span class="line">  tags:</span><br><span class="line">    - production</span><br><span class="line"></span><br><span class="line">.in-docker:</span><br><span class="line">  tags:</span><br><span class="line">    - docker</span><br><span class="line">  image: alpine</span><br><span class="line"></span><br><span class="line">rspec:</span><br><span class="line">  extends:</span><br><span class="line">    - .only-important</span><br><span class="line">    - .in-docker</span><br><span class="line">  script:</span><br><span class="line">    - rake rspec</span><br></pre></td></tr></table></figure><p>这将导致以下 RSPECjob：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">rspec:</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">    - stable</span><br><span class="line">  tags:</span><br><span class="line">    - docker</span><br><span class="line">  image: alpine</span><br><span class="line">  script:</span><br><span class="line">    - rake rspec</span><br></pre></td></tr></table></figure><h4 id="Using-extends-and-include-together"><a href="#Using-extends-and-include-together" class="headerlink" title="Using extends and include together"></a>Using extends and include together</h4><p>扩展配置文件和 include 的工作。</p><p>例如，如果您有本地 included.yml 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">.template:</span><br><span class="line">  script:</span><br><span class="line">    - echo Hello!</span><br></pre></td></tr></table></figure><p>然后，在.gitlab-ci.yml 中，您可以这样使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">include: included.yml</span><br><span class="line"></span><br><span class="line">useTemplate:</span><br><span class="line">  image: alpine</span><br><span class="line">  extends: .template</span><br></pre></td></tr></table></figure><p>这将运行一个名为 usetemplate 的 job，该 job 运行 echo hello！根据.templatejob 中的定义，并使用本地 job 中定义的 Alpine Docker 图像。</p><h3 id="7-22-pages"><a href="#7-22-pages" class="headerlink" title="7.22. pages"></a>7.22. pages</h3><p>页面是一项特殊的工作，用于将静态内容上载到 Gitlab，该工作可用于为您的网站提供服务。它有一个特殊的语法，所以这两个</p><p>必须满足以下要求：</p><p>任何静态内容都必须放在 public / 目录下。</p><p>必须定义具有公共 / 目录路径的项目。</p><p>下面的示例只是将所有文件从项目的根目录移动到 public/directory。.public 解决方案是这样的，cp 不会无限循环地将 public / 复制到自身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">pages:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script:</span><br><span class="line">    - mkdir .public</span><br><span class="line">    - cp -r * .public</span><br><span class="line">    - mv .public public</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - public</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br></pre></td></tr></table></figure><p><a href="https://gitlab.com/help/user/project/pages/index.md">Read more on GitLab Pages user documentation.</a></p><h3 id="7-23-variables"><a href="#7-23-variables" class="headerlink" title="7.23. variables"></a>7.23. variables</h3><p>&gt; 整数（以及字符串）对于变量的名称和值都是合法的。浮动不合法，不能使用。</p><p>Gitlab CI/CD 允许您在.gitlab-ci.yml 中定义变量，然后在 job 环境中传递这些变量。它们可以全局设置，也可以按 job 设置。</p><p>在 job 级别上使用 variables 关键字时，它将覆盖全局 yaml 变量和预定义变量。</p><p>它们存储在 Git 存储库中，用于存储非敏感项目配置，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  DATABASE_URL: &quot;postgres:&#x2F;&#x2F;postgres@postgres&#x2F;my_database&quot;</span><br></pre></td></tr></table></figure><p>这些变量稍后可以在所有执行的命令和脚本中使用。yaml 定义的变量也被设置为所有创建的服务容器，从而允许对它们进行微调。</p><p>除了用户定义的变量之外，还有运行程序本身设置的变量。一个例子是 ci-commit-ref-name，它具有为其构建项目的分支或标记名的值。除了可以在.gitlab-ci.yml 中设置的变量外，还可以在 gitlab 的用户界面中设置所谓的变量。<br><a href="https://gitlab.com/help/ci/variables/README.md">Learn more about variables and their priority.</a></p><h4 id="Git-strategy"><a href="#Git-strategy" class="headerlink" title="Git strategy"></a>Git strategy</h4><p>您可以在 “变量” 部分中设置用于获取最新应用程序代码的 Git_策略（全局或每个 job）。如果未指定，将使用项目设置中的默认值。</p><p>有三个可能的值：clone、fetch 和 none。</p><p>克隆是最慢的选项。它为每个 job 从头克隆存储库，确保项目工作空间始终是原始的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_STRATEGY: clone</span><br></pre></td></tr></table></figure><p>提取速度更快，因为它重新使用项目工作区（如果不存在则返回到克隆）。Git Clean 用于撤消上一个 job 所做的任何更改，Git Fetch 用于检索自上一个 job 运行以来所做的提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_STRATEGY: fetch</span><br></pre></td></tr></table></figure><p>也没有人会重新使用项目工作区，但会跳过所有 Git 操作（包括 Gitlab Runner 的预克隆脚本，如果存在的话）。它主要用于只在 artifacts 上操作的 job（例如部署）。Git 存储库数据可能存在，但它肯定是过时的，因此您应该只依赖从缓存或 artifacts 引入到项目工作区的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_STRATEGY: none</span><br></pre></td></tr></table></figure><blockquote><p>Kubernetes 的执行者不支持 Git_策略，但将来可能会支持。有关更新，请参阅支持带 kubernetes 执行器的 git 策略的特性建议。</p></blockquote><h4 id="Git-submodule-strategy"><a href="#Git-submodule-strategy" class="headerlink" title="Git submodule strategy"></a>Git submodule strategy</h4><p>Git_子模块_策略变量用于控制在生成前获取代码时是否包含 Git 子模块 / 如何包含 Git 子模块。您可以在 “变量” 部分中全局或按 job 设置它们。</p><p>有三个可能的值：无、正常和递归：</p><p>无表示在获取项目代码时不包括子模块。这是默认值，与 v1.10 之前的行为匹配。</p><p>正常意味着只包括顶级子模块。相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">git submodule sync</span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><p>递归意味着将包括所有子模块（包括子模块的子模块）。此功能需要 Git v1.8.1 及更高版本。当使用不基于 Docker 的执行器的 Gitlab 运行程序时，请确保 Git 版本满足该要求。相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">git submodule sync --recursive</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>请注意，要使此功能正常工作，子模块必须（在.gitmodules 中）配置为：</p><p>公共可访问存储库的 HTTP（S）URL，或指向同一 Gitlab 服务器上另一个存储库的相对路径。请参见 Git 子模块文档。</p><h4 id="Git-checkout"><a href="#Git-checkout" class="headerlink" title="Git checkout"></a>Git checkout</h4><p>当 git 策略设置为 clone 或 fetch 以指定是否应运行 git 签出时，可以使用 git 签出变量。如果未指定，则默认为 true。您可以在 “变量” 部分中全局或按 job 设置它们。如果设置为 false，则运行程序将：</p><p>执行提取时 - 更新存储库并将工作副本保留在当前版本上，执行克隆时 - 克隆存储库并将工作副本保留在默认分支上。</p><p>将此设置设置为 true 意味着对于克隆和获取策略，运行程序将签出工作副本到与 CI 管道相关的修订：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_STRATEGY: clone</span><br><span class="line">  GIT_CHECKOUT: &quot;false&quot;</span><br><span class="line">script:</span><br><span class="line">  - git checkout -B master origin&#x2F;master</span><br><span class="line">  - git merge $CI_COMMIT_SHA</span><br></pre></td></tr></table></figure><h4 id="Git-clean-flags"><a href="#Git-clean-flags" class="headerlink" title="Git clean flags"></a>Git clean flags</h4><p>git-clean-flags 变量用于控制签出源后 git-clean 的默认行为。您可以全局设置它，也可以在变量部分中为每个 job 设置它。</p><p>git_clean_标志接受 git clean 命令的所有可能选项。</p><p>如果指定了 git_checkout:false，则禁用 git clean。如果 git_clean_标志是：</p><p>未指定，git clean 标志默认为 - ffdx。</p><p>给定值 none，不执行 git clean。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_CLEAN_FLAGS: -ffdx -e cache&#x2F;</span><br><span class="line">script:</span><br><span class="line">  - ls -al cache&#x2F;</span><br></pre></td></tr></table></figure><h4 id="Job-stages-attempts"><a href="#Job-stages-attempts" class="headerlink" title="Job stages attempts"></a>Job stages attempts</h4><p>您可以设置正在运行的 job 将尝试执行以下每个阶段的尝试次数：</p><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td>GET_SOURCES_ATTEMPTS</td><td>尝试获取运行 job 的源的次数</td></tr><tr><td>ARTIFACT_DOWNLOAD_ATTEMPTS</td><td>尝试下载运行 job 的项目的次数</td></tr><tr><td>RESTORE_CACHE_ATTEMPTS</td><td>尝试还原运行 job 的缓存的次数</td></tr></tbody></table><p>默认为一次尝试。</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GET_SOURCES_ATTEMPTS: 3</span><br></pre></td></tr></table></figure><h4 id="Shallow-cloning"><a href="#Shallow-cloning" class="headerlink" title="Shallow cloning"></a>Shallow cloning</h4><p>可以使用 git_depth 指定提取和克隆的深度。这允许对存储库进行浅层克隆，这可以显著加快对具有大量提交或旧的大型二进制文件的存储库的克隆。价值是</p><p>传递给了 git fetch 和 git clone。</p><blockquote><p>如果使用深度 1 并有 job 队列或重试 job，则 job 可能会失败。</p></blockquote><p>因为 Git 获取和克隆是基于引用的，例如分支名称，所以运行者不能克隆特定的 commit SHA。如果队列中有多个 job，或者您正在重试一个旧 job，那么要测试的提交需要在克隆的 Git 历史记录中。为 GIT_DEPTH 设置的值太小可能导致无法运行这些旧提交。您将在中看到未解决的引用</p><p>job 日志。然后，您应该重新考虑将 GIT_DEPTH 更改为更高的值。</p><p>当设置 GIT_DEPTH 时，依赖于 Git 描述的 job 可能无法正常工作，因为 Git 历史只有一部分存在。</p><p>要仅获取或克隆最后 3 个提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YML</span><br><span class="line">variables:</span><br><span class="line">  GIT_DEPTH: &quot;3&quot;</span><br></pre></td></tr></table></figure><p>您可以全局设置它，也可以在变量部分中为每个 job 设置它。</p><h3 id="8-不推荐使用的参数-见原文"><a href="#8-不推荐使用的参数-见原文" class="headerlink" title="8. 不推荐使用的参数 (见原文)"></a>8. 不推荐使用的参数 (见原文)</h3><p>以下参数已弃用。……</p><blockquote><p> <strong>文章作者:</strong> <a href="mailto:undefined">雪人</a></p><p><strong>文章链接:</strong> <a href="https://www.webq.top/2020/11/19/doc/ci/">https://www.webq.top/2020/11/19/doc/ci/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;Gitlab-CI-CD-管道配置参考&quot;&gt;&lt;a href=&quot;#Gitlab-CI-CD-管道配置参考&quot; class=&quot;headerlink&quot; title=&quot;Gitlab CI/CD 管道配置参考&quot;&gt;&lt;/a&gt;Gitlab CI/CD 管道配</summary>
      
    
    
    
    <category term="Gitlab" scheme="https://blog.zhimma.com/categories/Gitlab/"/>
    
    <category term="DevOps" scheme="https://blog.zhimma.com/categories/Gitlab/DevOps/"/>
    
    
    <category term="Gitlab" scheme="https://blog.zhimma.com/tags/Gitlab/"/>
    
    <category term="DevOps" scheme="https://blog.zhimma.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>gitlab搭建及DevOps初探</title>
    <link href="https://blog.zhimma.com/2021/08/12/gitlab%E6%90%AD%E5%BB%BA%E5%8F%8ADevOps%E5%88%9D%E6%8E%A2/"/>
    <id>https://blog.zhimma.com/2021/08/12/gitlab%E6%90%AD%E5%BB%BA%E5%8F%8ADevOps%E5%88%9D%E6%8E%A2/</id>
    <published>2021-08-12T09:39:47.000Z</published>
    <updated>2021-08-12T10:05:10.572Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="gitlab搭建及DevOps初探"><a href="#gitlab搭建及DevOps初探" class="headerlink" title="gitlab搭建及DevOps初探"></a>gitlab搭建及DevOps初探</h1><h2 id="docker搭建gitlab和gitlab-runner"><a href="#docker搭建gitlab和gitlab-runner" class="headerlink" title="docker搭建gitlab和gitlab-runner"></a>docker搭建gitlab和gitlab-runner</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  gitlab-test:</span><br><span class="line">      image: gitlab&#x2F;gitlab-ce:latest</span><br><span class="line">      container_name: gitlab-test</span><br><span class="line">      restart: always</span><br><span class="line">      hostname: &#39;**you ip**&#39;</span><br><span class="line">      environment:</span><br><span class="line">        GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">          external_url &#39;http:&#x2F;&#x2F;**you ip**:32189&#39;</span><br><span class="line">          gitlab_rails[&#39;gitlab_ssh_host&#39;] &#x3D; &#39;**you ip**&#39;</span><br><span class="line">          gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 22220</span><br><span class="line">          gitlab_rails[&#39;smtp_enable&#39;] &#x3D; true</span><br><span class="line">          gitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.exmail.qq.com&quot;</span><br><span class="line">          gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465</span><br><span class="line">          gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;xxx@xxx.com&quot;</span><br><span class="line">          gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;xxx&quot;</span><br><span class="line">          gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; &quot;login&quot;</span><br><span class="line">          gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; true</span><br><span class="line">          gitlab_rails[&#39;smtp_tls&#39;] &#x3D; true</span><br><span class="line">          gitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &#39;xxx&#39;</span><br><span class="line">      ports:</span><br><span class="line">        - &#39;32189:32189&#39; &#x2F;&#x2F; 80:80</span><br><span class="line">        - &#39;4430:443&#39; &#x2F;&#x2F; 443:443</span><br><span class="line">        - &#39;22220:22&#39; &#x2F;&#x2F; 22:22</span><br><span class="line">      volumes:</span><br><span class="line">        - &#39;.&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab&#39;</span><br><span class="line">        - &#39;.gitlab-runner&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab&#39;</span><br><span class="line">        - &#39;.&#x2F;gitlab-runner&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab&#39;</span><br><span class="line">      privileged: true</span><br><span class="line">  gitlab-runner:</span><br><span class="line">      image: gitlab&#x2F;gitlab-runner:latest</span><br><span class="line">      restart: always</span><br><span class="line">      container_name: gitlab-runner</span><br><span class="line">      privileged: true</span><br><span class="line">      # depends_on:</span><br><span class="line">      #   - gitlab-test</span><br><span class="line">      ports:</span><br><span class="line">       - &#39;28093:8093&#39;</span><br><span class="line">      volumes:</span><br><span class="line">          - &#39;.&#x2F;gitlab-runner&#x2F;config:&#x2F;etc&#x2F;gitlab-runner&#39;</span><br><span class="line">          - &#39;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&#39;</span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>理论上上面的脚本改一改自己的一些配置，就可以跑起来最新版本的gitlab和gitlab-runner。</p><p>说一下有以下几点需要注意下：</p><ol><li><p>external_url，一般情况下如果80端口没有被占用，最好使用80端口 ，如果被占用了，那么就需要更换端口，这里有个坑，也是卡了我很久，最后在这篇文章里面找到了解决方法 <a href="https://www.jianshu.com/p/d707f70c60d2">点击查看</a></p><p>—– <strong>原文如下</strong>：</p><p>为什么我在external_url设置ip+port却无法访问到GitLab，如果直接设置成ip地址在项目的checkout地址一栏，其git地址却不包含端口号，导致http的checkout地址不可用。</p><p><img src="https://upload-images.jianshu.io/upload_images/3610588-dc84dd3abf7bf0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/875/format/webp" alt="img"></p><p> 问题的原因就出在external_url地址设置上。<br> GitLab默认的http访问端口号为80端口，如果想更改端口号，一般是通过docker run时设置端口映射，将80端口映射为其他端口。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname gitlab.example.com \</span><br><span class="line">    --publish <span class="number">8443</span>:<span class="number">443</span> --publish <span class="number">8080</span>:<span class="number">80</span> --publish <span class="number">8022</span>:<span class="number">22</span> \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume /srv/gitlab/config:<span class="regexp">/etc/gi</span>tlab \</span><br><span class="line">    --volume /srv/gitlab/logs:<span class="regexp">/var/</span>log/gitlab \</span><br><span class="line">    --volume /srv/gitlab/data:<span class="regexp">/var/</span>opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest  </span><br></pre></td></tr></table></figure><p>这里将GitLab的http端口改为8080，如果你这时修改external_url地址为<a href="https://link.jianshu.com/?t=http://ip:8080">http://ip:8080</a>，那GitLab肯定访问不了，因为你已经将内部的端口号修改为8080端口了，而你通过docker run映射出来的端口号是80端口，所以不可能访问到。那该怎么办？<br> 既然你已经将内部的端口号由80端口改为8080端口，这时候你就将容器停止并删除，但是不要将映射的配置文件删除(gitlab.rb文件)，docker在删除容器的时候不会将映射的文件删除。在此运行docker run命令，如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">    --hostname gitlab.example.com \</span><br><span class="line">    --publish <span class="number">8443</span>:<span class="number">443</span> --publish <span class="number">8080</span>:<span class="number">8080</span> --publish <span class="number">8022</span>:<span class="number">22</span> \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    --volume /srv/gitlab/config:<span class="regexp">/etc/gi</span>tlab \</span><br><span class="line">    --volume /srv/gitlab/logs:<span class="regexp">/var/</span>log/gitlab \</span><br><span class="line">    --volume /srv/gitlab/data:<span class="regexp">/var/</span>opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest  </span><br></pre></td></tr></table></figure><h4 id="注意这里映射的端口为8080端口，根据自己设置的external-url端口号进行调整"><a href="#注意这里映射的端口为8080端口，根据自己设置的external-url端口号进行调整" class="headerlink" title="注意这里映射的端口为8080端口，根据自己设置的external_url端口号进行调整"></a>注意这里映射的端口为8080端口，根据自己设置的external_url端口号进行调整</h4><p>接下来就能访问GitLab了，并且在checkout检出地址栏中，http地址端口号也正确了。</p><p><img src="https://upload-images.jianshu.io/upload_images/3610588-ecec7ca28c1d939e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/821/format/webp" alt="img"></p><ol start="2"><li>gitlab_rails[‘gitlab_shell_ssh_port’]，这个对应的是checkout克隆代码的时候的端口，记得放行出来</li></ol></li></ol><h2 id="gitlab初始化配置及gitlab初始化"><a href="#gitlab初始化配置及gitlab初始化" class="headerlink" title="gitlab初始化配置及gitlab初始化"></a>gitlab初始化配置及gitlab初始化</h2><h3 id="gitlab密码重置"><a href="#gitlab密码重置" class="headerlink" title="gitlab密码重置"></a>gitlab密码重置</h3><p>可以参考这里：<a href="https://www.cnblogs.com/Cryan/p/15060207.html">Docker 下安装gitlab 密码 重置 - 无小空空 - 博客园 (cnblogs.com)</a></p><p>具体步骤也可以看下面几条命令</p><h4 id="进入docker-gitlab-容器中"><a href="#进入docker-gitlab-容器中" class="headerlink" title="进入docker gitlab 容器中"></a>进入docker gitlab 容器中</h4><p>​    <code>docker exec -it gitlab（容器名字） bash</code></p><h4 id="进入gitlab-控制台"><a href="#进入gitlab-控制台" class="headerlink" title="进入gitlab 控制台"></a>进入gitlab 控制台</h4><p>​    <code>gitlab-rails console -e production   #可能会等好几秒钟 </code></p><h4 id="搜索用户"><a href="#搜索用户" class="headerlink" title="搜索用户"></a>搜索用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这里提供两种搜索方式  通过id</span></span><br><span class="line">user = User.where(id:1).first</span><br><span class="line"><span class="meta">#</span><span class="bash">或者 通过电子邮件搜索  或者用户名</span></span><br><span class="line">user = User.find_by(email:&#x27;admin@example.com&#x27;)</span><br></pre></td></tr></table></figure><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意  这两个选项都得设置，  pass  为你要设置的密码</span></span><br><span class="line">user.password =&#x27;pass&#x27;</span><br><span class="line">user.password_confirmation =&#x27;pass&#x27;</span><br></pre></td></tr></table></figure><h4 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h4><p>​    <code>user.save</code></p><h3 id="gitlab-runner-注册"><a href="#gitlab-runner-注册" class="headerlink" title="gitlab-runner 注册"></a>gitlab-runner 注册</h3><p>可以参考这里：<a href="https://zhuanlan.zhihu.com/p/109820989">gitlab-ci&amp;gitlab-runner完整自动化部署过程 - 知乎 (zhihu.com)</a></p><p>这里就不写具体注册流程了，记录一下有几点需要注意的地方：</p><h4 id="runner的配置-etc-gitlab-runner目录下config-toml文件"><a href="#runner的配置-etc-gitlab-runner目录下config-toml文件" class="headerlink" title="runner的配置(etc/gitlab-runner目录下config.toml文件)"></a>runner的配置(<code>etc/gitlab-runner目录下config.toml文件</code>)</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[[runners]]</span><br><span class="line">  name = &quot;xx&quot;</span><br><span class="line">  url = &quot;http://ip:32189/&quot;</span><br><span class="line">  token = &quot;xx&quot;</span><br><span class="line">  executor = &quot;docker&quot; // 直接使用docker image</span><br><span class="line">  [runners.custom_build_dir]</span><br><span class="line">  [runners.cache]</span><br><span class="line">    [runners.cache.s3]</span><br><span class="line">    [runners.cache.gcs]</span><br><span class="line">    [runners.cache.azure]</span><br><span class="line">  [runners.docker]</span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = &quot;docker&quot;</span><br><span class="line">    privileged = false</span><br><span class="line">    disable_entrypoint_overwrite = false</span><br><span class="line">    oom_kill_disable = false</span><br><span class="line">    disable_cache = false</span><br><span class="line">    volumes = [&quot;/cache&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;] // 就是这里需要volumes docker</span><br><span class="line">    pull_policy = [&quot;if-not-present&quot;]</span><br><span class="line">    shm_size = 0</span><br></pre></td></tr></table></figure><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><p>接下来就可以在项目中些.gitlab-ci.yml文件了</p><p>可以参考这里：<a href="https://www.webq.top/2020/11/19/doc/ci/">Gitlab CI/CD管道配置参考 | 雪人 (webq.top)</a></p><p>我也再次复制一遍：</p><h3 id="一、什么Gitlab-CI"><a href="#一、什么Gitlab-CI" class="headerlink" title="一、什么Gitlab CI"></a>一、什么Gitlab CI</h3><p>GitLab CI 是 GitLab 为了提升其在软件开发工程中作用，完善 DevOPS 理念所加入的 CI/CD 基础功能。可以便捷的融入软件开发环节中。通过 GitLab CI 可以定义完善的 CI/CD Pipeline。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>GitLab CI 是默认包含在 GitLab 中的，我们的代码使用 GitLab 进行托管，这样可以很容易的进行集成</li><li>GitLab CI 的前端界面比较美观，容易被人接受</li><li>包含实时构建日志，容易追踪</li><li>采用 C/S 的架构，可方面的进行横向扩展，性能上不会有影响</li><li>使用 YAML 进行配置，任何人都可以很方便的使用。</li></ul><h3 id="二、环境安装"><a href="#二、环境安装" class="headerlink" title="二、环境安装"></a>二、环境安装</h3><h4 id="1、安装gitlab（docker版）——管理员管理"><a href="#1、安装gitlab（docker版）——管理员管理" class="headerlink" title="1、安装gitlab（docker版）——管理员管理"></a>1、安装gitlab（docker版）——管理员管理</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br><span class="line">sudo docker run -d  \</span><br><span class="line">-p 443:443 -p 80:80 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --hostname sgitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    -v /data/gitlab/config:/etc/gitlab \</span><br><span class="line">    -v /data/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">    -v /data/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><ul><li><p><strong>配置</strong></p><p>按上面的方式，gitlab容器运行没问题，但在gitlab上创建项目的时候，生成项目的URL访问地址是按容器的hostname来生成的，也就是容器的id。作为gitlab服务器，我们需要一个固定的URL访问地址，于是需要配置<code>gitlab.rb</code>（宿主机路径：/data/gitlab/config/gitlab.rb）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /data/gitlab/config/gitlab.rb</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置http协议所使用的访问地址,不加端口号默认为80</span></span><br><span class="line">external_url <span class="string">&#x27;http://192.168.199.115&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ssh协议所使用的访问地址和端口</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_ssh_host&#x27;</span>] = <span class="string">&#x27;192.168.199.115&#x27;</span></span><br><span class="line">gitlab_rails[<span class="string">&#x27;gitlab_shell_ssh_port&#x27;</span>] = 222 <span class="comment"># 此端口是run时22端口映射的222端口</span></span><br></pre></td></tr></table></figure></li></ul><p>启动成功后，访问gitlab会强制修改root密码。</p><h4 id="2、安装Gitlab-runner——开发人员管理"><a href="#2、安装Gitlab-runner——开发人员管理" class="headerlink" title="2、安装Gitlab runner——开发人员管理"></a>2、安装Gitlab runner——开发人员管理</h4><h5 id="2-1、docker版"><a href="#2-1、docker版" class="headerlink" title="2.1、docker版"></a>2.1、docker版</h5><p>原文：<a href="https://gitlab.com/gitlab-org/gitlab-runner/blob/master/docs/install/osx.md">https://gitlab.com/gitlab-org/gitlab-runner/blob/master/docs/install/osx.md</a></p><p><strong>gitlab runner为ci / cd提供运行环境</strong>， GitLab Runner可以跑在一个单独的机子上，只需要这个机器需要能够访问GitLab服务本身</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull  gitlab/gitlab-runner</span><br><span class="line"><span class="comment"># 必须将docker.sock挂载进runner容器</span></span><br><span class="line">sudo docker run -d \</span><br><span class="line">--name gitlab-runner \</span><br><span class="line">--restart always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v /data/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">gitlab/gitlab-runner</span><br></pre></td></tr></table></figure><h5 id="2-2、主机版"><a href="#2-2、主机版" class="headerlink" title="2.2、主机版"></a>2.2、主机版</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install gitlab-runner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用命令启动Runner</span></span><br><span class="line">sudo gitlab-runner run</span><br></pre></td></tr></table></figure><h5 id="2-3、问题记录"><a href="#2-3、问题记录" class="headerlink" title="2.3、问题记录"></a>2.3、问题记录</h5><p>gitlab-runner版本问题导致，使用gitlab-runner 12以上即可解决</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104437196-1862786793.png" alt="img"></p><h4 id="3、gitlab-runner关联gitlab（gitlab上注册runner）"><a href="#3、gitlab-runner关联gitlab（gitlab上注册runner）" class="headerlink" title="3、gitlab runner关联gitlab（gitlab上注册runner）"></a>3、gitlab runner关联gitlab（gitlab上注册runner）</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104447853-212621954.png" alt="img"></p><ul><li><p>获取注册runner时使用的URL与Token，进入项目仓库，<code>Settings</code> –&gt; <code>CI/CD</code> –&gt; <code>Runners</code> –&gt; <code>Specific runners</code> –&gt; <code>URL 、token</code></p></li><li><p><strong>启动并注册到gitlab</strong></p><ul><li><p>直接执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url是上图中的url， token是上图中的token</span></span><br><span class="line">docker run --rm -t -i -v `<span class="built_in">pwd</span>`/gitlab-runner:/etc/gitlab-runner --name gitlab-runner gitlab/gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor <span class="string">&quot;docker&quot;</span> \</span><br><span class="line">  --docker-privileged \ </span><br><span class="line">  --docker-image nginx:1.19.2 \</span><br><span class="line">  --url <span class="string">&quot;http://10.0.2.91/&quot;</span> \</span><br><span class="line">  --registration-token <span class="string">&quot;Ys7zVmpsxtqDxf79Xupv&quot;</span> \</span><br><span class="line">  --description <span class="string">&quot;shared-docker-runner&quot;</span> \</span><br><span class="line">  --tag-list <span class="string">&quot;shared_docker&quot;</span> \</span><br><span class="line">  --run-untagged \</span><br><span class="line">  --locked=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>进入runner容器执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it gitlab-runner /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行以下注册命令</span></span><br><span class="line">gitlab-runner register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入Gitlab实例的地址</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">http://10.0.2.11  <span class="comment"># 端口采用默认的80，否则需要加上端口，比如 http://10.0.2.11:8090</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入token</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">VobqwqSTYvm69Ln3sVcm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入描述信息</span></span><br><span class="line">Enter a description <span class="keyword">for</span> the runner:</span><br><span class="line">[2f5631485bf3]: this is the description</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入tag</span></span><br><span class="line">Enter tags <span class="keyword">for</span> the runner (comma-separated):</span><br><span class="line">test_tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入Ruuner的执行者</span></span><br><span class="line">Enter an executor: docker-ssh, ssh, virtualbox, docker-ssh+machine, kubernetes, custom, docker, parallels, shell, docker+machine:</span><br><span class="line">shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上面executor为docker，需要你在后续项目根部的.gitlab-ci.yml中  指定具体docker版本</span></span><br><span class="line"><span class="comment">#Enter the default Docker image (for example, ruby:2.6):</span></span><br><span class="line"><span class="comment">#alpine:latest</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4、创建共享runner"><a href="#4、创建共享runner" class="headerlink" title="4、创建共享runner"></a>4、创建共享runner</h4><p>共享runner的url与token，在root账户下可见，其余同指定runner相同</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104502906-755150128.png" alt="img"></p><h4 id="5、激活runner（已激活则忽略）"><a href="#5、激活runner（已激活则忽略）" class="headerlink" title="5、激活runner（已激活则忽略）"></a>5、激活runner（已激活则忽略）</h4><p>绿色表示已激活</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104514417-847480449.png" alt="img"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner verify</span><br><span class="line">sudo gitlab-runner restart</span><br></pre></td></tr></table></figure><h4 id="6、注册成功"><a href="#6、注册成功" class="headerlink" title="6、注册成功"></a>6、注册成功</h4><ul><li>注册成功，在<code>/etc/gitlab-runner/config.toml</code>中可查看已注册的所有runner</li></ul><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104523415-1802423125.png" alt="img"></p><h4 id="7、避免重复拉取镜像"><a href="#7、避免重复拉取镜像" class="headerlink" title="7、避免重复拉取镜像"></a>7、避免重复拉取镜像</h4><p>在<code>/etc/gitlab-runner/config.toml</code>的<code>runners.docker</code>中添加<code>pull_policy = &quot;if-not-present&quot;</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104531377-1198675510.png" alt="img"></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104539545-166699232.png" alt="img"></p><h3 id="三、概念"><a href="#三、概念" class="headerlink" title="三、概念"></a>三、概念</h3><h4 id="1、Pipeline"><a href="#1、Pipeline" class="headerlink" title="1、Pipeline"></a>1、Pipeline</h4><p>Pipeline 相当于一个构建任务，里面可以包含多个stage(流程)，如依赖安装、编译、测试、部署等。<br>任何提交或者 Merge Request 的合并都可以触发 Pipeline</p><h4 id="2、stages"><a href="#2、stages" class="headerlink" title="2、stages"></a>2、stages</h4><p>Stage 表示构建的阶段，即上面提到的流程.</p><ul><li>所有 Stages 按顺序执行，即当一个 Stage 完成后，下一个 Stage 才会开始</li><li>任一 Stage 失败，后面的 Stages 将永不会执行，Pipeline 失败</li><li>只有当所有 Stages 完成后，Pipeline 才会成功</li></ul><h4 id="3、Jobs"><a href="#3、Jobs" class="headerlink" title="3、Jobs"></a>3、Jobs</h4><p>Job 是 Stage 中的任务.</p><ul><li>相同 Stage 中的 Jobs 会<strong>并行</strong>执行</li><li>任一 Job 失败，那么 Stage 失败，Pipeline 失败</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 成功</li></ul><h3 id="四、主机、runner、executor关系"><a href="#四、主机、runner、executor关系" class="headerlink" title="四、主机、runner、executor关系"></a>四、主机、runner、executor关系</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104552283-580444647.png" alt="img"></p><ul><li><p>每个excutor中的环境在创建runner时指定，可以包括以下的环境（使用docker时需要指定默认镜像）：</p><p><code>docker-ssh, ssh, virtualbox, docker-ssh+machine, kubernetes, custom, docker, parallels, shell, docker+machine</code></p></li><li><p>如果executor不使用docker，那么会使用runner所在的环境</p></li></ul><h3 id="五、yml配置文件"><a href="#五、yml配置文件" class="headerlink" title="五、yml配置文件"></a>五、yml配置文件</h3><p>官方文档： <a href="https://docs.gitlab.com/ee/ci/yaml/README.html">https://docs.gitlab.com/ee/ci/yaml/README.html</a></p><h4 id="1、yml示例"><a href="#1、yml示例" class="headerlink" title="1、yml示例"></a>1、yml示例</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104600676-241634217.png" alt="img"></p><p>在项目根目录下创建<code>.gitlab-ci.yml</code>，这里的demo对应上图配置的runner</p><ul><li>gitlab-runner使用docker安装</li><li>容器中手动安装<code>python3</code>、<code>zip</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker_runner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python3</span> <span class="string">test_py.py</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">tttt:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker_runner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python3</span> <span class="string">test_file.py</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pack:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker_runner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zip</span> <span class="string">aaa.zip</span> <span class="string">b.txt</span></span><br></pre></td></tr></table></figure><h4 id="2、关键字"><a href="#2、关键字" class="headerlink" title="2、关键字"></a>2、关键字</h4><ul><li><code>test</code>、<code>tttt</code>、<code>pack</code>是Job名字</li><li><code>script</code>是要执行的脚本，每个job中必须包含</li><li><code>tags</code>是指定需要在哪些tag对应的runner中执行</li></ul><table><thead><tr><th>关键字</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>script</td><td>yes</td><td>Runner执行的命令或脚本。可以包含多条命令</td></tr><tr><td>image</td><td>no</td><td>使用的docker镜像。<a href="https://links.jianshu.com/go?to=https://docs.gitlab.com/ce/ci/docker/README.html">详见</a></td></tr><tr><td>services</td><td>no</td><td>使用的docker服务。<a href="https://links.jianshu.com/go?to=https://docs.gitlab.com/ce/ci/docker/README.html">详见</a></td></tr><tr><td>stage</td><td>no</td><td>定义job stage（默认：test）</td></tr><tr><td>type</td><td>no</td><td>stage的别名（已弃用）</td></tr><tr><td>variables</td><td>no</td><td>定义job级别的变量</td></tr><tr><td>only</td><td>no</td><td>定义一列git分支，并为其创建job</td></tr><tr><td>except</td><td>no</td><td>定义一列git分支，不创建job</td></tr><tr><td>tags</td><td>no</td><td>定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags）</td></tr><tr><td>allow_failure</td><td>no</td><td>允许job失败。失败的job不影响commit状态</td></tr><tr><td>when</td><td>no</td><td>定义何时开始job。可以是on_success，on_failure，always或者manual</td></tr><tr><td>dependencies</td><td>no</td><td>定义job依赖关系，这样他们就可以互相传递artifacts</td></tr><tr><td>cache</td><td>no</td><td>定义应在后续运行之间缓存的文件列表</td></tr><tr><td>before_script</td><td>no</td><td>重写一组在作业前执行的命令</td></tr><tr><td>after_script</td><td>no</td><td>重写一组在作业后执行的命令</td></tr><tr><td>environment</td><td>no</td><td>定义此作业完成部署的环境名称</td></tr><tr><td>coverage</td><td>no</td><td>定义给定作业的代码覆盖率设置</td></tr></tbody></table><ul><li><p><strong>only 和 except中关键字</strong></p><ul><li>only：定义一列git分支，并为其创建job</li><li>except：定义一列git分支，不创建job</li></ul><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>branches</td><td>当一个分支被push上来</td></tr><tr><td>tags</td><td>当一个打了tag的分支被push上来</td></tr><tr><td>api</td><td>当一个pipline被piplines api所触发调起，详见piplines api</td></tr><tr><td>external</td><td>当使用了GitLab以外的CI服务</td></tr><tr><td>pipelines</td><td>针对多项目触发器而言，当使用CI_JOB_TOKEN并使用gitlab所提供的api创建多个pipelines的时候</td></tr><tr><td>pushes</td><td>当pipeline被用户的git push操作所触发的时候</td></tr><tr><td>schedules</td><td>针对预定好的pipline而言（每日构建一类）</td></tr><tr><td>triggers</td><td>用token创建piplines的时候</td></tr><tr><td>web</td><td>在GitLab页面上Pipelines标签页下，你按了run pipline的时候</td></tr></tbody></table></li></ul><h4 id="3、关键字解析"><a href="#3、关键字解析" class="headerlink" title="3、关键字解析"></a>3、关键字解析</h4><h5 id="3-1、script"><a href="#3-1、script" class="headerlink" title="3.1、script"></a>3.1、script</h5><p>这里不需要使用<code>git clone ....</code>克隆当前的项目，来进行操作，因为在流水线中，每一个的job的执行都会将项目下载，恢复缓存这些流程，不需要你再使用脚本恢复。</p><ul><li><strong>script</strong>的工作目录就是当前项目的根目录</li><li><strong>script</strong>是一个job的必填内容，不可或缺。一个job最少有二个属性，一个是job name</li></ul><h5 id="3-2、after-script"><a href="#3-2、after-script" class="headerlink" title="3.2、after_script"></a>3.2、after_script</h5><p><code>before_script</code> 和 <code>script</code> 在一个上下文中是<strong>串行</strong>执行的，<code>after_script</code> 是独立执行的。所以根据执行器(在runner注册的时候，可以选择执行器，docker,shell 等)的不同，工作树之外的变化可能不可见，例如，在before_script中执行软件的安装。</p><p>你可以在任务中定义 <code>before_script</code>，<code>after_script</code>，也可以将其定义为顶级元素，定义为顶级元素将为每一个任务都执行相应阶段的脚本或命令。</p><h5 id="3-3、variables"><a href="#3-3、variables" class="headerlink" title="3.3、variables"></a>3.3、variables</h5><p>GitLab CI允许你为<code>.gitlab-ci.yml</code>增加变量，该变量将会被设置入<strong>任务环境</strong>。这些变量是你存储在git仓库里，并且非敏感的项目配置</p><h5 id="3-4、script"><a href="#3-4、script" class="headerlink" title="3.4、script"></a>3.4、script</h5><p>script是一段由Runner执行的shell脚本</p><ul><li>script命令包含了YAML中的语法时需要被单引号或者双引号所包裹。例如：当命令中包涵冒号的时候，该命令需要被引号所包裹。</li><li>当命令中包涵以下字符时需要注意打引号: <code>: &#123; &#125; [ ] , &amp; * # ? | - &lt; &gt; = ! % @</code></li></ul><h5 id="3-5、only-与-except"><a href="#3-5、only-与-except" class="headerlink" title="3.5、only 与 except"></a>3.5、only 与 except</h5><ul><li>only：定义了job需要执行的所在branch或者tag</li><li>except：定义了job不会执行的所在branch或者tag<ul><li>only和except如果都存在在一个job声明中，则所需引用将会被only和except所定义的分支过滤.</li><li>only和except允许使用正则</li><li>only和except允许使用指定仓库地址，但是不forks仓库</li></ul></li></ul><p><strong>例如：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">    <span class="comment"># 使用正则</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/^issue-.*$/</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">branches</span></span><br></pre></td></tr></table></figure><h5 id="3-6、artifacts"><a href="#3-6、artifacts" class="headerlink" title="3.6、artifacts"></a>3.6、artifacts</h5><p><code>artifacts</code> 被用于在 job 作业成功后将制定列表里的文件或文件夹附加到 job 上，传递给下一个 job ，如果要在两个 job 之间传递 artifacts，你必须设置dependencies。</p><p><code>artifacts</code>则是将某个<code>文件</code>上传到GitLab提供下载或后续操作使用。<code>artifacts</code>会先传到GitLab服务器，然后需要时再重新下载，所以这部分也可以在GitLab下载和浏览。</p><ul><li><p><strong>例子</strong></p><ul><li><p>传递所有文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test_ci</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zip</span> <span class="string">aaa.zip</span> <span class="string">./*</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">aaa.zip</span></span><br></pre></td></tr></table></figure></li><li><p>传递所有git没有追踪的文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">untracked:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>关键字</strong></p><ul><li><p><strong>name</strong></p><p>name指令允许你对<code>artifacts压缩包</code>重命名，你可以为每个artifect压缩包都指定一个特别的名字，这样对你在gitlab上下载artifect的压缩包有用。下载时默认是<code>artifact.zip</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">    <span class="attr">artifacts:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;upgrade&quot;</span>   <span class="comment"># 下载时文件名为 upgrade.zip</span></span><br></pre></td></tr></table></figure></li><li><p><strong>when</strong></p><p>用于job失败或者未失败时使用。</p><p>artifacts:when能设置以下值：</p><ol><li><code>on_success</code> 这个值是<strong>默认</strong>的，当job成功时，上传artifacts</li><li><code>on_failure</code> 当job执行失败时，上传artifacts</li><li><code>always</code> 不管失败与否，都上传</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">    <span class="attr">artifacts:</span></span><br><span class="line">        <span class="attr">when:</span> <span class="string">on_failure</span>    <span class="comment">#当失败时上传artifacts</span></span><br></pre></td></tr></table></figure></li><li><p><strong>expire_in</strong></p><p><code>expire_in</code> 用于设置 artifacts 上传包的失效时间。如果不设置，artifacts 的打包是永远存在于 gitlab上 的。当指定 artifacts 过期时间的时候, 在该期间内，artifacts 包将储存在 gitLab 上。并且你可以在 job 页面找到一个 keep 按钮，按了以后可以覆盖过期时间，让 artifacts 永远存在。<strong>过期之后，用户将无法访问到 artifacts 包</strong></p><p>时间格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;3 mins 4 sec&#39;</span><br><span class="line">&#39;2 hrs 20 min&#39;</span><br><span class="line">&#39;2h20min&#39;</span><br><span class="line">&#39;6 mos 1 day&#39;</span><br><span class="line">&#39;47 yrs 6 mos and 4d&#39;</span><br><span class="line">&#39;3 weeks and 2 days&#39;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line">    <span class="attr">artifacts:</span></span><br><span class="line">        <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">day</span> <span class="comment"># 一天后过期</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>如下图所示，如果配置了<code>artifacts</code>，那么在gitlab的pipelines中可以下载对应pipeline生成的文件。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/1461466-20210427104621738-1860578421.png" alt="img"></p><h5 id="3-7、image"><a href="#3-7、image" class="headerlink" title="3.7、image"></a>3.7、image</h5><p>指定一个基础Docker镜像作为基础运行环境，经常用到的镜像有<code>node</code>、 <code>nginx</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">python3</span></span><br></pre></td></tr></table></figure><h5 id="3-8、tags"><a href="#3-8、tags" class="headerlink" title="3.8、tags"></a>3.8、tags</h5><p>用于指定Runner,tags的取值范围是在该项目可见的runner tags中，可以在<code>Setting --&gt; CI/CD --&gt; Runner</code> 中查看的到。</p><p>如果不设置，则默认使用公有Runner去执行流水线</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello-vue</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">config</span> <span class="string">set</span> <span class="string">sass_binary_site</span> <span class="string">https://npm.taobao.org/mirrors/node-sass/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--registry=http://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><h5 id="3-9、cache"><a href="#3-9、cache" class="headerlink" title="3.9、cache"></a>3.9、cache</h5><p><code>cache</code>是将<strong>当前工作环境目录</strong>中的一些文件/文件夹存储起来，用于在各个任务初始化的时候恢复。避免多个下载同样的包，能够大大优化流水线效率。</p><p>在java项目中经常把maven下载的包缓存起来。在python中经常将依赖包缓存起来。</p><p>例如，缓存所有binaries目录下以.apk结尾的文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rspec:</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">binaries/*.apk</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.config</span></span><br></pre></td></tr></table></figure><h5 id="3-10、variables"><a href="#3-10、variables" class="headerlink" title="3.10、variables"></a>3.10、variables</h5><p>自定义变量，如果该变量位于最高级别，则该变量在全局范围内可用，并且所有job都可以使用它。如果是在job中定义的，则只有该job可以使用它</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">TEST_VAR:</span> <span class="string">&quot;All jobs can use this variable&#x27;s value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="attr">variables:</span></span><br><span class="line">    <span class="attr">TEST_VAR:</span> <span class="string">&quot;Only job  can use this variable&#x27;s value&quot;</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$TEST_VAR</span> <span class="string">and</span> <span class="string">$TEST_VAR_JOB</span></span><br></pre></td></tr></table></figure><h4 id="4、CI已定义变量"><a href="#4、CI已定义变量" class="headerlink" title="4、CI已定义变量"></a>4、CI已定义变量</h4><table><thead><tr><th align="center">Variable</th><th align="center">GitLab</th><th align="center">Runner</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"><strong>CI</strong></td><td align="center">all</td><td align="center">0.4</td><td align="center">标识该job是在CI环境中执行</td></tr><tr><td align="center"><strong>CI_COMMIT_REF_NAME</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">用于构建项目的分支或tag名称</td></tr><tr><td align="center"><strong>CI_COMMIT_REF_SLUG</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">先将<code>$CI_COMMIT_REF_NAME</code>的值转换成小写，最大不能超过63个字节，然后把除了<code>0-9</code>和<code>a-z</code>的其他字符转换成<code>-</code>。在URLs和域名名称中使用。</td></tr><tr><td align="center"><strong>CI_COMMIT_SHA</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">commit的版本号</td></tr><tr><td align="center"><strong>CI_COMMIT_TAG</strong></td><td align="center">9.0</td><td align="center">0.5</td><td align="center">commit的tag名称。只有创建了tags才会出现。</td></tr><tr><td align="center"><strong>CI_DEBUG_TRACE</strong></td><td align="center">9.0</td><td align="center">1.7</td><td align="center"><a href="https://docs.gitlab.com/ce/ci/variables/README.html#debug-tracing">debug tracing</a>开启时才生效</td></tr><tr><td align="center"><strong>CI_ENVIRONMENT_NAME</strong></td><td align="center">8.15</td><td align="center">all</td><td align="center">job的环境名称</td></tr><tr><td align="center"><strong>CI_ENVIRONMENT_SLUG</strong></td><td align="center">8.15</td><td align="center">all</td><td align="center">环境名称的简化版本，适用于DNS，URLs，Kubernetes labels等</td></tr><tr><td align="center"><strong>CI_JOB_ID</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">GItLab CI内部调用job的一个唯一ID</td></tr><tr><td align="center"><strong>CI_JOB_MANUAL</strong></td><td align="center">8.12</td><td align="center">all</td><td align="center">表示job启用的标识</td></tr><tr><td align="center"><strong>CI_JOB_NAME</strong></td><td align="center">9.0</td><td align="center">0.5</td><td align="center"><code>.gitlab-ci.yml</code>中定义的job的名称</td></tr><tr><td align="center"><strong>CI_JOB_STAGE</strong></td><td align="center">9.0</td><td align="center">0.5</td><td align="center"><code>.gitlab-ci.yml</code>中定义的stage的名称</td></tr><tr><td align="center"><strong>CI_JOB_TOKEN</strong></td><td align="center">9.0</td><td align="center">1.2</td><td align="center">用于同GitLab容器仓库验证的token</td></tr><tr><td align="center"><strong>CI_REPOSITORY_URL</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">git仓库地址，用于克隆</td></tr><tr><td align="center"><strong>CI_RUNNER_DESCRIPTION</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">GitLab中存储的Runner描述</td></tr><tr><td align="center"><strong>CI_RUNNER_ID</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">Runner所使用的唯一ID</td></tr><tr><td align="center"><strong>CI_RUNNER_TAGS</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">Runner定义的tags</td></tr><tr><td align="center"><strong>CI_PIPELINE_ID</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">GitLab CI 在内部使用的当前pipeline的唯一ID</td></tr><tr><td align="center"><strong>CI_PIPELINE_TRIGGERED</strong></td><td align="center">all</td><td align="center">all</td><td align="center">用于指示该job被触发的标识</td></tr><tr><td align="center"><strong>CI_PROJECT_DIR</strong></td><td align="center">all</td><td align="center">all</td><td align="center">仓库克隆的完整地址和job允许的完整地址</td></tr><tr><td align="center"><strong>CI_PROJECT_ID</strong></td><td align="center">all</td><td align="center">all</td><td align="center">GitLab CI在内部使用的当前项目的唯一ID</td></tr><tr><td align="center"><strong>CI_PROJECT_NAME</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">当前正在构建的项目名称（事实上是项目文件夹名称）</td></tr><tr><td align="center"><strong>CI_PROJECT_NAMESPACE</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">当前正在构建的项目命名空间（用户名或者是组名称）</td></tr><tr><td align="center"><strong>CI_PROJECT_PATH</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">命名空间加项目名称</td></tr><tr><td align="center"><strong>CI_PROJECT_PATH_SLUG</strong></td><td align="center">9.3</td><td align="center">all</td><td align="center"><code>$CI_PROJECT_PATH</code>小写字母、除了<code>0-9</code>和<code>a-z</code>的其他字母都替换成<code>-</code>。用于地址和域名名称。</td></tr><tr><td align="center"><strong>CI_PROJECT_URL</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">项目的访问地址（http形式）</td></tr><tr><td align="center"><strong>CI_REGISTRY</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">如果启用了Container Registry，则返回GitLab的Container Registry的地址</td></tr><tr><td align="center"><strong>CI_REGISTRY_IMAGE</strong></td><td align="center">8.10</td><td align="center">0.5</td><td align="center">如果为项目启用了Container Registry，它将返回与特定项目相关联的注册表的地址</td></tr><tr><td align="center"><strong>CI_REGISTRY_PASSWORD</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">用于push containers到GitLab的Container Registry的密码</td></tr><tr><td align="center"><strong>CI_REGISTRY_USER</strong></td><td align="center">9.0</td><td align="center">all</td><td align="center">用于push containers到GItLab的Container Registry的用户名</td></tr><tr><td align="center"><strong>CI_SERVER</strong></td><td align="center">all</td><td align="center">all</td><td align="center">标记该job是在CI环境中执行</td></tr><tr><td align="center"><strong>CI_SERVER_NAME</strong></td><td align="center">all</td><td align="center">all</td><td align="center">用于协调job的CI服务器名称</td></tr><tr><td align="center"><strong>CI_SERVER_REVISION</strong></td><td align="center">all</td><td align="center">all</td><td align="center">用于调度job的GitLab修订版</td></tr><tr><td align="center"><strong>CI_SERVER_VERSION</strong></td><td align="center">all</td><td align="center">all</td><td align="center">用于调度job的GItLab版本</td></tr><tr><td align="center"><strong>ARTIFACT_DOWNLOAD_ATTEMPTS</strong></td><td align="center">8.15</td><td align="center">1.9</td><td align="center">尝试运行下载artifacts的job的次数</td></tr><tr><td align="center"><strong>GET_SOURCES_ATTEMPTS</strong></td><td align="center">8.15</td><td align="center">1.9</td><td align="center">尝试运行获取源的job次数</td></tr><tr><td align="center"><strong>GITLAB_CI</strong></td><td align="center">all</td><td align="center">all</td><td align="center">用于指示该job是在GItLab CI环境中运行</td></tr><tr><td align="center"><strong>GITLAB_USER_ID</strong></td><td align="center">8.12</td><td align="center">all</td><td align="center">开启该job的用户ID</td></tr><tr><td align="center"><strong>GITLAB_USER_EMAIL</strong></td><td align="center">8.12</td><td align="center">all</td><td align="center">开启该job的用户邮箱</td></tr><tr><td align="center"><strong>RESTORE_CACHE_ATTEMPTS</strong></td><td align="center">8.15</td><td align="center">1.9</td><td align="center">尝试运行存储缓存的job的次数</td></tr></tbody></table><p><strong>推荐博文：</strong></p><p>GitLab-CI中的artifacts使用研究：<a href="http://zacksleo.top/archives/">http://zacksleo.top/archives/</a></p><p>Gitlab CI 使用高级技巧：<a href="https://www.jianshu.com/p/3c0cbb6c2936">https://www.jianshu.com/p/3c0cbb6c2936</a></p><p>一文搞定gitlab的环境搭建、配置CI/CD、自动构建docker镜像：<a href="https://www.cnblogs.com/hzhhhbb/p/13966904.html?share_token=4dfe4dbe-caac-4437-b2b4-ea59b03c67d1">https://www.cnblogs.com/hzhhhbb/p/13966904.html?share_token=4dfe4dbe-caac-4437-b2b4-ea59b03c67d1</a></p><h2 id="另外一篇gitlab-ci关键字的文章"><a href="#另外一篇gitlab-ci关键字的文章" class="headerlink" title="另外一篇gitlab-ci关键字的文章"></a>另外一篇gitlab-ci关键字的文章</h2><p><a href="https://www.webq.top/2020/11/19/doc/ci/">Gitlab CI/CD管道配置参考 | 雪人 (webq.top)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;gitlab搭建及DevOps初探&quot;&gt;&lt;a href=&quot;#gitlab搭建及DevOps初探&quot; class=&quot;headerlink&quot; title=&quot;gitlab搭建及DevOps初探&quot;&gt;&lt;/a&gt;gitlab搭建及DevOps初探&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Gitlab" scheme="https://blog.zhimma.com/categories/Gitlab/"/>
    
    <category term="DevOps" scheme="https://blog.zhimma.com/categories/Gitlab/DevOps/"/>
    
    
    <category term="Gitlab" scheme="https://blog.zhimma.com/tags/Gitlab/"/>
    
    <category term="DevOps" scheme="https://blog.zhimma.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>laravel/lumen中自定义日志(json)和processor</title>
    <link href="https://blog.zhimma.com/2021/03/22/laravel-lumen%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97-json-%E5%92%8Cprocessor/"/>
    <id>https://blog.zhimma.com/2021/03/22/laravel-lumen%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97-json-%E5%92%8Cprocessor/</id>
    <published>2021-03-22T03:58:43.000Z</published>
    <updated>2021-03-23T10:08:23.573Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>项目上线后,有一些场景需要收集日志进行业务分析或者进行业务监控用，通常需要将日志转为<code>json</code>的格式，这里记录下laravel框架中如何最小化改动进行日志格式化，完成收集</p> <span id="more"></span><p>先看一下最终收集的数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">调用：</span><br><span class="line">Log::info(&quot;code登陆后解析返回的数据&quot;, is_array($result) ? $result : [$result]);</span><br><span class="line">日志记录：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot;:&quot;2021-03-22T14:42:44.538683+08:00&quot;,</span><br><span class="line">    &quot;@version&quot;:1,</span><br><span class="line">    &quot;host&quot;:&quot;7468a43f9a91&quot;,</span><br><span class="line">    &quot;message&quot;:&quot;code登陆后解析返回的数据&quot;,</span><br><span class="line">    &quot;type&quot;:&quot;legendage&quot;,</span><br><span class="line">    &quot;channel&quot;:&quot;prod&quot;,</span><br><span class="line">    &quot;level&quot;:&quot;INFO&quot;,</span><br><span class="line">    &quot;monolog_level&quot;:200,</span><br><span class="line">    &quot;extra&quot;:&#123;</span><br><span class="line">        &quot;request_id&quot;:&quot;e5031cbd2ea6f3a86c8a9c41a1d637b827171&quot;,</span><br><span class="line">        &quot;process_id&quot;:89,</span><br><span class="line">        &quot;memory_usage&quot;:&quot;2 MB&quot;,</span><br><span class="line">        &quot;url&quot;:&quot;&#x2F;api&#x2F;auth&#x2F;login?code&#x3D;023A051w37kB4W2GNn3w3hueAU2A0516&quot;,</span><br><span class="line">        &quot;ip&quot;:&quot;1.85.216.155&quot;,</span><br><span class="line">        &quot;http_method&quot;:&quot;GET&quot;,</span><br><span class="line">        &quot;server&quot;:&quot;api.domain.cn&quot;,</span><br><span class="line">        &quot;referrer&quot;:&quot;https:&#x2F;&#x2F;servicewechat.com&#x2F;appid&#x2F;devtools&#x2F;page-frame.html&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;context&quot;:&#123;</span><br><span class="line">        &quot;session_key&quot;:&quot;SuW7afBI0sYjOHmExBwIMw&#x3D;&#x3D;&quot;,</span><br><span class="line">        &quot;openid&quot;:&quot;o9GF_5dZ5ZS1-wLyx4ziY1z2Shds&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般说来除了<code>extra</code>可以进行自定义添加附加的数据，其他的数据均由框架自动生成，原有的日志生成方法不变，接下来演示下如何配置：</p><h1 id="logging文件修改"><a href="#logging文件修改" class="headerlink" title="logging文件修改"></a>logging文件修改</h1><p>找到<code>src/config/logging.php</code>文件，进行下列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use App\Logging\LogstashJsonFormatter;</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line">    &#39;default&#39; &#x3D;&gt; env(&#39;LOG_CHANNEL&#39;, &#39;stack&#39;),</span><br><span class="line">    &#39;channels&#39; &#x3D;&gt; [</span><br><span class="line">        &#39;stack&#39; &#x3D;&gt; [</span><br><span class="line">            &#39;driver&#39; &#x3D;&gt; &#39;stack&#39;,</span><br><span class="line">            &#39;channels&#39; &#x3D;&gt; [&#39;daily&#39;],</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &#39;single&#39; &#x3D;&gt; [</span><br><span class="line">            &#39;driver&#39; &#x3D;&gt; &#39;single&#39;,</span><br><span class="line">            &#39;path&#39; &#x3D;&gt; storage_path(&#39;logs&#x2F;lumen.log&#39;),</span><br><span class="line">            &#39;level&#39; &#x3D;&gt; &#39;debug&#39;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &#39;daily&#39; &#x3D;&gt; [</span><br><span class="line">            &#39;driver&#39; &#x3D;&gt; &#39;daily&#39;,</span><br><span class="line">            &#39;path&#39; &#x3D;&gt; storage_path(&#39;logs&#x2F;app&#x2F;&#39; . date(&#39;Y&#x2F;m&#x2F;d&#x2F;\h-H&#39;, time()) . &#39;.log&#39;),</span><br><span class="line">            &#39;level&#39; &#x3D;&gt; &#39;debug&#39;,</span><br><span class="line">            &#39;days&#39; &#x3D;&gt; 14,</span><br><span class="line">            &#39;permission&#39; &#x3D;&gt; 0755,</span><br><span class="line">            &#39;tap&#39; &#x3D;&gt; [LogstashJsonFormatter::class,], &#x2F;&#x2F; 重点是这一句</span><br><span class="line">        ],</span><br><span class="line">  ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>具体说明可参考官方文档：<a href="https://learnku.com/docs/laravel/8.x/logging/9376#customizing-monolog-for-channels">https://learnku.com/docs/laravel/8.x/logging/9376#customizing-monolog-for-channels</a></p></blockquote><h1 id="实现自定义格式化日志类"><a href="#实现自定义格式化日志类" class="headerlink" title="实现自定义格式化日志类"></a>实现自定义格式化日志类</h1><p>官方的自定义格式化类示例是在<code>App\Logging</code>命名空间下，所以我们在app目录下创建我们的自定义格式化类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Logging;</span><br><span class="line"></span><br><span class="line">use App\Logging\Formatter\LogStashFormatter as CustomerLogstashFormatter;</span><br><span class="line">use Illuminate\Log\Logger;</span><br><span class="line">use Monolog\Formatter\LogstashFormatter as MonoLogstashFormatter;</span><br><span class="line">use Monolog\Processor\MemoryUsageProcessor;</span><br><span class="line">use Monolog\Processor\ProcessIdProcessor;</span><br><span class="line">use Monolog\Processor\WebProcessor;</span><br><span class="line"></span><br><span class="line">class LogstashJsonFormatter</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义给定的日志实例</span><br><span class="line">     *</span><br><span class="line">     * @param Logger $logger</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function __invoke(Logger $logger)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach ($logger-&gt;getHandlers() as $handler) &#123;</span><br><span class="line">            $handler-&gt;setFormatter(new CustomerLogstashFormatter(env(&quot;APP_NAME&quot;)));</span><br><span class="line">            $handler-&gt;pushProcessor(new WebProcessor());</span><br><span class="line">            $handler-&gt;pushProcessor(new MemoryUsageProcessor());</span><br><span class="line">            $handler-&gt;pushProcessor(new ProcessIdProcessor());</span><br><span class="line">            &#x2F;&#x2F; 进行额外扩展数据的添加</span><br><span class="line">            $handler-&gt;pushProcessor(</span><br><span class="line">                function ($record) &#123;</span><br><span class="line">                    $record[&#39;extra&#39;][&#39;request_id&#39;] &#x3D; REQUEST_ID;</span><br><span class="line">                    return $record;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考上面的实现就可以完成上面说的<code>json</code>格式的日志</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>Using Monolog:<a href="http://seldaek.github.io/monolog/doc/01-usage.html">http://seldaek.github.io/monolog/doc/01-usage.html</a></p><p>[Proposal] Add processors option to monolog:<a href="https://github.com/laravel/ideas/issues/1796">https://github.com/laravel/ideas/issues/1796</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;项目上线后,有一些场景需要收集日志进行业务分析或者进行业务监控用，通常需要将日志转为&lt;code&gt;json&lt;/code&gt;的格式，这里记录下laravel框架中如何最小化改动进行日志格式化，完成收集&lt;/p&gt;</summary>
    
    
    
    <category term="Laravel" scheme="https://blog.zhimma.com/categories/Laravel/"/>
    
    
    <category term="Laravel" scheme="https://blog.zhimma.com/tags/Laravel/"/>
    
    <category term="log" scheme="https://blog.zhimma.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Consul初体验</title>
    <link href="https://blog.zhimma.com/2020/03/20/Consul%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://blog.zhimma.com/2020/03/20/Consul%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-03-20T02:50:39.000Z</published>
    <updated>2021-03-23T10:06:54.029Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d xhyve nginx</span><br><span class="line">docker-machine create -d xhyve consul</span><br><span class="line">docker-machine create -d xhyve work1</span><br><span class="line">docker-machine create -d xhyve work2</span><br><span class="line">docker-machine ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-machine ls</span><br><span class="line">NAME     ACTIVE   DRIVER    STATE     URL                         SWARM   DOCKER     ERRORS</span><br><span class="line">consul   -        xhyve     Running   tcp://192.168.64.15:2376            v19.03.5</span><br><span class="line">nginx    -        xhyve     Running   tcp://192.168.64.14:2376            v19.03.5</span><br><span class="line">work1    -        xhyve     Running   tcp://192.168.64.16:2376            v19.03.5</span><br><span class="line">work2    -        xhyve     Running   tcp://192.168.64.17:2376            v19.03.5</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h3><h4 id="进入consul机器"><a href="#进入consul机器" class="headerlink" title="进入consul机器"></a>进入consul机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh consul</span><br></pre></td></tr></table></figure><h4 id="运行consul节点容器"><a href="#运行consul节点容器" class="headerlink" title="运行consul节点容器"></a>运行consul节点容器</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -d \</span><br><span class="line">    -v /data:/data \</span><br><span class="line">    -p 8500:8500 \</span><br><span class="line">    -p 8600:8600/udp \</span><br><span class="line">    --name=consul \</span><br><span class="line">    consul agent -server -ui -node=server1 -bootstrap-expect=1 -client=0.0.0.0</span><br></pre></td></tr></table></figure><h4 id="查看容器启动情况"><a href="#查看容器启动情况" class="headerlink" title="查看容器启动情况"></a>查看容器启动情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@consul:&#x2F;home&#x2F;docker# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                    NAMES</span><br><span class="line">2d9d0cdd3f13        consul              &quot;docker-entrypoint.s…&quot;   3 minutes ago       Up 3 minutes        8300-8302&#x2F;tcp, 8600&#x2F;tcp, 8301-8302&#x2F;udp, 0.0.0.0:8500-&gt;8500&#x2F;tcp, 0.0.0.0:8600-&gt;8600&#x2F;udp   consul</span><br></pre></td></tr></table></figure><h4 id="访问web页面"><a href="#访问web页面" class="headerlink" title="访问web页面"></a>访问web页面</h4><p><a href="http://192.168.64.15:8500/ui/dc1/services![image-20210322151230731](https://zhimma.oss-cn-beijing.aliyuncs.com/md/J8i5ww.png)">http://192.168.64.15:8500/ui/dc1/services![image-20210322151230731](https://zhimma.oss-cn-beijing.aliyuncs.com/md/J8i5ww.png)</a></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/008eGmZEly1gospazlry2j31wg0qotbi.png" alt="image-20200203183743444"></p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><h4 id="进入nginx节点机器"><a href="#进入nginx节点机器" class="headerlink" title="进入nginx节点机器"></a>进入nginx节点机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh nginx</span><br></pre></td></tr></table></figure><h4 id="consul-template配置"><a href="#consul-template配置" class="headerlink" title="consul-template配置"></a>consul-template配置</h4><h5 id="安装consul-template"><a href="#安装consul-template" class="headerlink" title="安装consul-template"></a>安装consul-template</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/consul-template/0.24.1/consul-template_0.24.1_linux_amd64.tgz </span><br><span class="line"></span><br><span class="line">tar -zxf consul-template_0.24.1_linux_amd64.tgz</span><br><span class="line"></span><br><span class="line">mv consul-template /usr/bin/</span><br></pre></td></tr></table></figure><h5 id="创建nginx-ctmpl模板"><a href="#创建nginx-ctmpl模板" class="headerlink" title="创建nginx.ctmpl模板"></a>创建nginx.ctmpl模板</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">mkdir /data/nginx</span><br><span class="line"></span><br><span class="line">vi /data/nginx/nginx.ctmpl</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> http_backend &#123;</span><br><span class="line">    &#123;&#123;range service &quot;nginx&quot;&#125;&#125;</span><br><span class="line">    server &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8000</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://http_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动consul-template服务"><a href="#启动consul-template服务" class="headerlink" title="启动consul-template服务"></a>启动consul-template服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template --consul-addr 192.168.64.15:8500 --template &quot;.&#x2F;nginx.ctmpl:vhost.conf:docker exec nginx nginx -s reload&quot; --log-level&#x3D;info</span><br></pre></td></tr></table></figure><blockquote><p>–consul-addr：指定consul服务的ip和端口；<br>./nginx.ctmpl：这是用nginx.ctmpl这个模板来启动进程，这是写的相对路径，也可以写绝对路径；<br>vhost.conf：nginx.ctmpl模板生成后的文件名，这也可以写绝对路径，如果不写绝对路径，这个文件就在当前目录生成（/usr/local/nginx/consul/）</p></blockquote><h5 id="验证consul-template服务状态"><a href="#验证consul-template服务状态" class="headerlink" title="验证consul-template服务状态"></a>验证consul-template服务状态</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep consul-template</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/image-20200203185856803.png" alt="image-20200203185856803"></p><p>我们看到在本目录下生成了vhost.conf</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/image-20200203190041025.png" alt="image-20200203190041025"></p><blockquote><p>由于我们是容器启动的nginx，所以需要挂载当前目录将这个加载在容器里面的nginx配置里面运行</p></blockquote><h4 id="运行nginx容器"><a href="#运行nginx容器" class="headerlink" title="运行nginx容器"></a>运行nginx容器</h4><h5 id="创建nginx-conf和conf-d目录"><a href="#创建nginx-conf和conf-d目录" class="headerlink" title="创建nginx.conf和conf.d目录"></a>创建nginx.conf和conf.d目录</h5><blockquote><ol><li>先运行一个nginx容器，随便挂载一个目录，拷贝出来nginx官方镜像生成的容器里面的conf.d目录和nginx.conf</li><li>再删除这个容器，重新运行并且挂载nginx.conf和conf.d目录到新容器</li><li>重新运行consul-template 并且重新指定vhost.conf的生成目录</li></ol></blockquote><p><strong>运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name&#x3D;nginx_tmp -v &#x2F;zhimma:&#x2F;zhimma -d nginx</span><br></pre></td></tr></table></figure><p><strong>进入容器并拷贝目录</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/data/nginx<span class="comment"># docker exec -it nginx_tmp bash</span></span><br><span class="line">root@49762af8ada3:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  devetc  home  liblib64  media  mnt  optproc  root  run  sbin  srv  sys  tmp  usr  varzhimma</span><br><span class="line"></span><br><span class="line">root@49762af8ada3:/<span class="comment"># cd /etc/nginx/</span></span><br><span class="line">root@49762af8ada3:/etc/nginx<span class="comment"># cp -r conf.d/ nginx.conf  /zhimma/</span></span><br><span class="line">root@49762af8ada3:/etc/nginx<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f nginx_tmp</span><br></pre></td></tr></table></figure><p><strong>放置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/data/nginx<span class="comment"># pwd</span></span><br><span class="line">/data/nginx</span><br><span class="line">root@nginx:/data/nginx<span class="comment"># ls</span></span><br><span class="line">nginx.ctmpl  vhost.conf</span><br><span class="line"></span><br><span class="line">root@nginx:/data/nginx<span class="comment"># mv /zhimma/conf.d/ /zhimma/nginx.conf ./</span></span><br><span class="line">root@nginx:/data/nginx<span class="comment"># ls</span></span><br><span class="line">conf.d       nginx.conf   nginx.ctmpl  vhost.conf</span><br></pre></td></tr></table></figure><h5 id="运行新容器"><a href="#运行新容器" class="headerlink" title="运行新容器"></a>运行新容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name&#x3D;nginx -p 8000:8000 -p 80:80 -v &#x2F;data&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;data&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d -d nginx</span><br></pre></td></tr></table></figure><blockquote><p>此步完成后可以去容器里面看看挂载是否成功</p></blockquote><h5 id="重新运行consul-template"><a href="#重新运行consul-template" class="headerlink" title="重新运行consul-template"></a>重新运行consul-template</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template --consul-addr 192.168.64.15:8500 --template <span class="string">&quot;./nginx.ctmpl:./conf.d/vhost.conf:docker exec nginx nginx -s reload&quot;</span> --log-level=info</span><br></pre></td></tr></table></figure><blockquote><p>此步完成后可以去容器里面看看挂载是否成功</p><p><code>-template</code>参数来指定模板的解析，规则是：冒号第一段是模板文件路径，第二段是生成的配置文件路径，第三段是额外指令（<strong>这里特别重要：如果我们没有nginx -s reload这个，配置更新之后，无法自动生效。这个代表每次配置改变之后，都会自动执行此指令，用来reload nginx的配置，以便自动生效</strong>）</p></blockquote><h3 id="work1"><a href="#work1" class="headerlink" title="work1"></a>work1</h3><h4 id="进入work1机器"><a href="#进入work1机器" class="headerlink" title="进入work1机器"></a>进入work1机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh work1</span><br></pre></td></tr></table></figure><h4 id="创建registrator容器"><a href="#创建registrator容器" class="headerlink" title="创建registrator容器"></a>创建registrator容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name registrator --network&#x3D;host -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;tmp&#x2F;docker.sock --restart&#x3D;always gliderlabs&#x2F;registrator:latest --ip 192.168.64.16 consul:&#x2F;&#x2F;192.168.64.15:8500</span><br></pre></td></tr></table></figure><h5 id="创建nginx容器并修改index-html内容"><a href="#创建nginx容器并修改index-html内容" class="headerlink" title="创建nginx容器并修改index.html内容"></a>创建nginx容器并修改index.html内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name work_81  -p 81:80 -v /data/www/81/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;work1_81&quot;</span> &gt;&gt; /data/www/81/index.html</span><br><span class="line"></span><br><span class="line">docker run -itd --name work_82  -p 82:80 -v /data/www/82/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;work1_82&quot;</span> &gt;&gt; /data/www/82/index.html</span><br></pre></td></tr></table></figure><h3 id="Work2"><a href="#Work2" class="headerlink" title="Work2"></a>Work2</h3><h4 id="进入work2机器"><a href="#进入work2机器" class="headerlink" title="进入work2机器"></a>进入work2机器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh work2</span><br></pre></td></tr></table></figure><h4 id="创建registrator容器-1"><a href="#创建registrator容器-1" class="headerlink" title="创建registrator容器"></a>创建registrator容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name registrator --network&#x3D;host -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;tmp&#x2F;docker.sock --restart&#x3D;always gliderlabs&#x2F;registrator:latest --ip 192.168.64.17 consul:&#x2F;&#x2F;192.168.64.15:8500</span><br></pre></td></tr></table></figure><h5 id="创建nginx容器并修改index-html内容-1"><a href="#创建nginx容器并修改index-html内容-1" class="headerlink" title="创建nginx容器并修改index.html内容"></a>创建nginx容器并修改index.html内容</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name work_83  -p 83:80 -v /data/www/83/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;work2_83&quot;</span> &gt;&gt; /data/www/83/index.html</span><br><span class="line"></span><br><span class="line">docker run -itd --name work_84  -p 84:80 -v /data/www/84/:/usr/share/nginx/html nginx</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;work2_84&quot;</span> &gt;&gt; /data/www/84/index.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker-machine create -d xhyve nginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-machine create -d xhyve consul&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-machine create -d xhyve work1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-machine create -d xhyve work2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-machine ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-machine ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NAME     ACTIVE   DRIVER    STATE     URL                         SWARM   DOCKER     ERRORS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consul   -        xhyve     Running   tcp://192.168.64.15:2376            v19.03.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nginx    -        xhyve     Running   tcp://192.168.64.14:2376            v19.03.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;work1    -        xhyve     Running   tcp://192.168.64.16:2376            v19.03.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;work2    -        xhyve     Running   tcp://192.168.64.17:2376            v19.03.5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Consul" scheme="https://blog.zhimma.com/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq名称解释</title>
    <link href="https://blog.zhimma.com/2020/03/17/Rabbitmq%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A/"/>
    <id>https://blog.zhimma.com/2020/03/17/Rabbitmq%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A/</id>
    <published>2020-03-17T07:28:45.000Z</published>
    <updated>2021-03-23T10:09:50.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="1、基础模块"><a href="#1、基础模块" class="headerlink" title="1、基础模块"></a>1、基础模块</h2><p>要熟练使用Rabbitmq就必须知道其名词含义和工作机制</p><blockquote><p>基本流程</p></blockquote><p>基本的工作流程是这样的：生产者，就是你的发送程序，通过TCP连接，创建channel(通道)向指定的exchange(交换机)发送一个消息，exchange再将消息下发到binding(绑定)的queue(队列)中，然后消费者(处理程序)监听接收queue中的消息进行处理。</p><p>这是google的一张流程图</p> <span id="more"></span><p><a href="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><blockquote><p>生产者，消费者</p></blockquote><p>即发送消息和接收处理消息的逻辑程序</p><blockquote><p>Channel</p></blockquote><p>通道，rabbitmq的本质是tcp通信，利用tcp连接创建内部的逻辑连接，注意，此通道不是tcp本身通道(tcp一个连接就是一个通道)，而是共享一个tcp连接的其内部实现的连接，至于rabbitmq内部如何实现的我也没吃透，应该是用到了多路复用，总之rabbitmq一切收发都是通过channel实现的，避免了重复连接tcp产生的资源消耗。</p><blockquote><p>Exchange</p></blockquote><p>交换机，相当于是一个消息中转控制中心，负责接收消息然后根据路由规则将消息下发到指定的queue。</p><blockquote><p>Queue</p></blockquote><p>队列，即存放消息的地方，消费的时候直接从队列里取。</p><h2 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h2><blockquote><p>Routing Key</p></blockquote><p>路由键，是exchange跟queue之间的桥梁，exchange根据绑定的routing key下发消息到对应的queue中，决定了消息的流向，键名可以自定义。</p><blockquote><p>Type</p></blockquote><p>exchange的类型，有’fanout’、’direct’、’topic’、’headers’四个类型。</p><ul><li><strong>fanout</strong>：不需要指定路由键，直接将消息发送给exchange中的所有queue，类似于广播。</li><li><strong>direct</strong>：将消息发给exchange中指定路由键的queue中，相当于精准投放。</li><li><strong>topic</strong>：匹配模式，消息下发到匹配规则的routing key的queue中，有’<em>‘与’#’两个通配符，’</em>‘表示只匹配一个词，’#’表示匹配多个，比如’user.*‘只能匹配到’user.name’而不能匹配到’user.name.wang’，’user.#’则都可以匹配到。</li><li><strong>headers</strong>：根据消息体的headers匹配，这种用到的比较少，绑定的时候指定相关header参数即可。</li></ul><blockquote><p>Durable</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，表示是否持久化。</p><blockquote><p>Auto delete</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，我试了一下，当exchange绑定的queue全都解绑的时候exchange会自动删除，queue好像没什么影响。</p><blockquote><p>Internal</p></blockquote><p>exchange有这个参数，类型为boolean，内部的，意味着不能对这个exchange发送消息，通过管理后台还是可以发送消息的。</p><blockquote><p>noWait</p></blockquote><p>几乎每个步骤都有这个参数，类型为boolean，不需要服务器任何返回值的意思，指服务端创建队列发送消息等，rabbitmq不需要这个返回状态即可进行下一步，正常来说不会用到这个参数，容易报异常。</p><blockquote><p>Exclusive</p></blockquote><p>queue有这个参数，类型为boolean，排他队列，只对创建该队列的用户可见，其它用户无法访问。</p><blockquote><p>延伸扩展</p></blockquote><p>rabbitmq还提供了很多扩展参数，比如’x-message-ttl’给消息设置过时时间，’x-max-length-bytes’设置消息最大长度，’x-dead-letter-exchange’设置消息过时后推送到的exchange等等，具体的官方文档也提供了，也可以看管理后台创建exchange、queue的时候会有提示的额外参数。</p><p><a href="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>引用这里：<a href="https://shuangdeyu.gitee.io/2019/04/16/%E5%9F%BA%E4%BA%8EGo%E7%9A%84Rabbitmq%E5%AE%9E%E8%B7%B5/">https://shuangdeyu.gitee.io/2019/04/16/%E5%9F%BA%E4%BA%8EGo%E7%9A%84Rabbitmq%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;&lt;h2 id=&quot;1、基础模块&quot;&gt;&lt;a href=&quot;#1、基础模块&quot; class=&quot;headerlink&quot; title=&quot;1、基础模块&quot;&gt;&lt;/a&gt;1、基础模块&lt;/h2&gt;&lt;p&gt;要熟练使用Rabbitmq就必须知道其名词含义和工作机制&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本的工作流程是这样的：生产者，就是你的发送程序，通过TCP连接，创建channel(通道)向指定的exchange(交换机)发送一个消息，exchange再将消息下发到binding(绑定)的queue(队列)中，然后消费者(处理程序)监听接收queue中的消息进行处理。&lt;/p&gt;
&lt;p&gt;这是google的一张流程图&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="https://blog.zhimma.com/categories/MQ/"/>
    
    
    <category term="Rabbitmq" scheme="https://blog.zhimma.com/tags/Rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>项目LNMP环境搭建</title>
    <link href="https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AELNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AELNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-02T06:08:28.000Z</published>
    <updated>2021-03-23T10:06:33.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3> <span id="more"></span><p><a href="https://www.daehub.com/archives/2254.html">https://www.daehub.com/archives/2254.html</a></p><ol><li>为了能够安装PHP7，需要安装<strong>EPEL</strong>和<strong>Remi</strong>的软件源，执行如下命令安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;epel-release-latest-7.noarch.rpm</span><br><span class="line">yum install http:&#x2F;&#x2F;rpms.remirepo.net&#x2F;enterprise&#x2F;remi-release-7.rpm</span><br></pre></td></tr></table></figure><ol><li>现在需要安装<strong>yum-utils</strong>工具，这个一个yum工具的增强工具，可以更加方便的管理yum软件源：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-utils</span><br></pre></td></tr></table></figure><ol><li>yum-utils的提供了一个yum-config-manager程序，它可以将<strong>Remi</strong>软件包作为默认源来安装PHP7：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php70   [安装 PHP 7.0]</span><br></pre></td></tr></table></figure><p>如果想在CentOS 7系统中安装PHP 7.1或PHP 7.2，则使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php71   [安装 PHP 7.1]</span><br><span class="line">yum-config-manager --enable remi-php72   [安装 PHP 7.2]</span><br></pre></td></tr></table></figure><ol><li>最后，使用如下命令将PHP及常的扩展安装至系统：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php php-mcrypt php-cli php-gd php-curl php-mysql php-ldap php-zip php-fileinfo php-devel php-mbstring php-simplexml php-dom php-common php-fpm</span><br></pre></td></tr></table></figure><p>最后，可以使用php -v命令来检查PHP是否正确的安装至CentOS 7系统中。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7">https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7</a></p><h4 id="添加-yum-源"><a href="#添加-yum-源" class="headerlink" title="添加 yum 源"></a>添加 yum 源</h4><p>Nginx 不在默认的 yum 源中，可以使用 epel 或者官网的 yum 源，本例使用官网的 yum 源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;7&#x2F;noarch&#x2F;RPMS&#x2F;nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装完 yum 源之后，可以查看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">repo id                          repo name                          status</span><br><span class="line">base&#x2F;7&#x2F;x86_64                    CentOS-7 - Base                    9,911</span><br><span class="line">extras&#x2F;7&#x2F;x86_64                  CentOS-7 - Extras                    368</span><br><span class="line">nginx&#x2F;x86_64                     nginx repo                           108</span><br><span class="line">updates&#x2F;7&#x2F;x86_64                 CentOS-7 - Updates                 1,041</span><br><span class="line">repolist: 11,428</span><br></pre></td></tr></table></figure><p>可以发现 <code>nginx repo</code> 已经安装到本机了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>yum 安装 Nginx，非常简单，一条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install nginx</span><br></pre></td></tr></table></figure><h4 id="配置-Nginx-服务"><a href="#配置-Nginx-服务" class="headerlink" title="配置 Nginx 服务"></a>配置 Nginx 服务</h4><h5 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="https://juejin.im/post/5c088b066fb9a049d4419985">https://juejin.im/post/5c088b066fb9a049d4419985</a></p><h4 id="添加Mysql5-7仓库"><a href="#添加Mysql5-7仓库" class="headerlink" title="添加Mysql5.7仓库"></a>添加Mysql5.7仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="确认Mysql仓库成功添加"><a href="#确认Mysql仓库成功添加" class="headerlink" title="确认Mysql仓库成功添加"></a>确认Mysql仓库成功添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist all | grep mysql | grep enabled</span><br></pre></td></tr></table></figure><p>如果展示像下面,则表示成功添加仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql-connectors-community&#x2F;x86_64  MySQL Connectors Community    enabled:     51</span><br><span class="line">mysql-tools-community&#x2F;x86_64       MySQL Tools Community         enabled:     63</span><br><span class="line">mysql57-community&#x2F;x86_64           MySQL 5.7 Community Server    enabled:    267</span><br></pre></td></tr></table></figure><h4 id="开始安装Mysql5-7"><a href="#开始安装Mysql5-7" class="headerlink" title="开始安装Mysql5.7"></a>开始安装Mysql5.7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><h4 id="启动Mysql"><a href="#启动Mysql" class="headerlink" title="启动Mysql"></a>启动Mysql</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure><h5 id="设置系统启动时自动启动"><a href="#设置系统启动时自动启动" class="headerlink" title="设置系统启动时自动启动"></a>设置系统启动时自动启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mysqld</span><br></pre></td></tr></table></figure><h5 id="查看启动状态"><a href="#查看启动状态" class="headerlink" title="查看启动状态"></a>查看启动状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure><h5 id="Mysql的安全设置"><a href="#Mysql的安全设置" class="headerlink" title="Mysql的安全设置"></a>Mysql的安全设置</h5><p>CentOS上的root默认密码可以在文件/var/log/mysqld.log找到，通过下面命令可以打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep -i &#39;temporary password&#39;</span><br></pre></td></tr></table></figure><p>执行下面命令进行安全设置，这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation     (Prod@Mysql@Passw0rd)</span><br></pre></td></tr></table></figure><h5 id="设置数据库编码为utf8"><a href="#设置数据库编码为utf8" class="headerlink" title="设置数据库编码为utf8"></a>设置数据库编码为utf8</h5><ol><li>打开配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;my.cnf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>在[mysqld]，[client]，[mysql]节点下添加编码设置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">collation-server &#x3D; utf8_unicode_ci</span><br><span class="line">init-connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server &#x3D; utf8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>重启Mysql即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/">https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/</a></p><h4 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h4><ol><li><p>Add the EPEL repository, and update YUM to confirm your change:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li><li><p>Install Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install redis</span><br></pre></td></tr></table></figure></li><li><p>Start Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis</span><br></pre></td></tr></table></figure><p><strong>Optional</strong>: To automatically start Redis on boot:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable redis</span><br></pre></td></tr></table></figure></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>Verify that Redis is running with <code>redis-cli</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>If Redis is running, it will return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https:&#x2F;&#x2F;getcomposer.org&#x2F;installer | php</span><br><span class="line">mv composer.phar  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;composer</span><br></pre></td></tr></table></figure><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer -V</span><br><span class="line">Composer version 1.9.1 2019-11-01 17:20:17</span><br></pre></td></tr></table></figure><h4 id="设置镜像地址"><a href="#设置镜像地址" class="headerlink" title="设置镜像地址"></a>设置镜像地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;PHP&quot;&gt;&lt;a href=&quot;#PHP&quot; class=&quot;headerlink&quot; title=&quot;PHP&quot;&gt;&lt;/a&gt;PHP&lt;/h3&gt;</summary>
    
    
    
    
    <category term="CentOS" scheme="https://blog.zhimma.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>项目压测及调优</title>
    <link href="https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AE%E5%8E%8B%E6%B5%8B%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AE%E5%8E%8B%E6%B5%8B%E5%8F%8A%E8%B0%83%E4%BC%98/</id>
    <published>2019-12-02T03:56:48.000Z</published>
    <updated>2021-03-23T10:06:25.358Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="性能概念TPS、QPS、RPS"><a href="#性能概念TPS、QPS、RPS" class="headerlink" title="性能概念TPS、QPS、RPS"></a>性能概念TPS、QPS、RPS</h2><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p>TPS：Transactions Per Second（每秒事务处理数），指服务器每秒处理的事务次数。一般用于评估数据库、交易系统的基准性能。</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>QPS：Queries Per Second（查询量/秒），是服务器每秒能够处理的查询次数，例如域名服务器、Mysql查询性能。</p><h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS：Request Per Second（请求数/秒）RPS（Request Per Second）和QPS可以认为是一回事。RT：Response Time（响应时间）：客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。也叫Think Time。</p><h3 id="并发数与TPS-QPS的关系"><a href="#并发数与TPS-QPS的关系" class="headerlink" title="并发数与TPS/QPS的关系"></a>并发数与TPS/QPS的关系</h3><p>QPS（TPS）= 并发数/平均响应时间这里的并发数如果为事务处理请求数，则为TPS，如果为查询请求数，则为QPS。</p> <span id="more"></span><h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><p><a href="https://blog.csdn.net/u011636440/article/details/78611838">https://blog.csdn.net/u011636440/article/details/78611838</a></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>查看当前操作系统发行版信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]#  cat &#x2F;etc&#x2F;redhat-release</span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    8</span><br><span class="line">座：                 1</span><br><span class="line">NUMA 节点：         1</span><br><span class="line">厂商 ID：           GenuineIntel</span><br><span class="line">CPU 系列：          6</span><br><span class="line">型号：              79</span><br><span class="line">型号名称：        Intel(R) Xeon(R) CPU E5-26xx v4</span><br><span class="line">步进：              1</span><br><span class="line">CPU MHz：             2394.446</span><br><span class="line">BogoMIPS：            4788.89</span><br><span class="line">超管理器厂商：  KVM</span><br><span class="line">虚拟化类型：     完全</span><br><span class="line">L1d 缓存：          32K</span><br><span class="line">L1i 缓存：          32K</span><br><span class="line">L2 缓存：           4096K</span><br><span class="line">NUMA 节点0 CPU：    0-7</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch bmi1 avx2 bmi2 rdseed adx xsaveopt</span><br></pre></td></tr></table></figure><h4 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line">cpu cores: 8</span><br></pre></td></tr></table></figure><h4 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="查看概要内存使用情况"><a href="#查看概要内存使用情况" class="headerlink" title="查看概要内存使用情况"></a>查看概要内存使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# free -g</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:             15           1           9           0           4          13</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><blockquote><p>-g是以GB为单位；也可以使用-m，即以MB为单位</p></blockquote><h2 id="压测和优化"><a href="#压测和优化" class="headerlink" title="压测和优化"></a>压测和优化</h2><h3 id="未优化压测"><a href="#未优化压测" class="headerlink" title="未优化压测"></a>未优化压测</h3><h4 id="压测结果预览"><a href="#压测结果预览" class="headerlink" title="压测结果预览"></a>压测结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/php-fpm%E6%9C%AA%E4%BC%98%E5%8C%96.gif"></p><h4 id="PHP-FPM配置"><a href="#PHP-FPM配置" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96php-fpm%E9%85%8D%E7%BD%AE.png"></p><h4 id="wrk压测结果"><a href="#wrk压测结果" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><h4 id="Nginx报错"><a href="#Nginx报错" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png"></p><h3 id="优化PHP-FPM"><a href="#优化PHP-FPM" class="headerlink" title="优化PHP-FPM"></a>优化PHP-FPM</h3><h4 id="PHP-FPM优化-示例：这是另一台服务器"><a href="#PHP-FPM优化-示例：这是另一台服务器" class="headerlink" title="PHP-FPM优化(示例：这是另一台服务器)"></a>PHP-FPM优化(示例：这是另一台服务器)</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/psaux.png"></p><p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><p> 格式说明：</p><p>USER: 行程拥有者</p><p>PID: pid</p><p>%CPU: 占用的 CPU 使用率</p><p>%MEM: 占用的记忆体使用率</p><p>VSZ: 占用的虚拟记忆体大小</p><p>RSS: 占用的记忆体大小</p><p>TTY: 终端的次要装置号码 (minor device number of tty)</p><p>STAT: 该行程的状态，linux的进程有5种状态：</p><p>​    D 不可中断 uninterruptible sleep (usually IO)</p><p>​    R 运行 runnable (on run queue)</p><p>​    S 中断 sleeping</p><p>​    T 停止 traced or stopped</p><p>​    Z 僵死 a defunct (”zombie”) process</p><p>注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p><p>START: 行程开始时间</p><p>TIME: 执行的时间</p><p>COMMAND:所执行的指令</p><h4 id="查看进程的消息"><a href="#查看进程的消息" class="headerlink" title="查看进程的消息"></a>查看进程的消息</h4><p><code>ps auxf | grep php | grep -v grep</code></p><blockquote><p>grep -v grep 过滤当前命令grep</p></blockquote><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/ps.png" alt="image-20191016153558487"></p><h4 id="占用的内存数量"><a href="#占用的内存数量" class="headerlink" title="占用的内存数量"></a><code>占用的内存数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | awk &#39;&#123;sum+&#x3D;$6&#125; END &#123;print sum&#125;&#39;</span><br><span class="line"></span><br><span class="line">18207120</span><br></pre></td></tr></table></figure><h4 id="查看进程数量"><a href="#查看进程数量" class="headerlink" title="查看进程数量"></a><code>查看进程数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | wc -l</span><br><span class="line"></span><br><span class="line">800</span><br></pre></td></tr></table></figure><p>可以看到第6列，每一个子进程的内存占用大概在22M之间（单位为KB）。平均的内存占用为<code>18207120KB/800/1024 = 22.2M</code>。</p><h5 id="进程数限制"><a href="#进程数限制" class="headerlink" title="进程数限制"></a>进程数限制</h5><p>此时如果我们分配全部的内存给<code>PHP-FPM</code>使用，那么进程数可以限制在`16*1000/22 = 744,但是由于我们的服务器同时服务了很多内容，所以我们可以向下调整到256个进程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.max &#x3D; 700</span><br><span class="line">pm &#x3D; dynamic</span><br><span class="line">pm.max_children &#x3D; 700</span><br><span class="line">pm.start_servers &#x3D; 450</span><br><span class="line">pm.min_spare_servers &#x3D; 200</span><br><span class="line">pm.max_spare_servers &#x3D; 700</span><br></pre></td></tr></table></figure><h5 id="max-children"><a href="#max-children" class="headerlink" title="max_children"></a>max_children</h5><ul><li><strong>这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。</strong></li><li>设置”max_children”也需要根据服务器的性能进行设定</li><li>一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右</li><li>假设“max_children”设置成100个，20M*100=2000M</li><li>也就是说在峰值的时候所有PHP-CGI所耗内存在2000M以内。</li><li>假设“max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。</li><li>如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。</li></ul><h5 id="start-servers"><a href="#start-servers" class="headerlink" title="start_servers"></a>start_servers</h5><ul><li>pm.start_servers的默认值为2。并且php-fpm中给的计算方式也为：<br>{（cpu空闲时等待连接的php的最小子进程数） + （cpu空闲时等待连接的php的最大子进程数 - cpu空闲时等待连接的php的最小子进程数）/ 2}；</li><li>用配置表示就是：min_spare_servers + (max_spare_servers - min_spare_servers) / 2；</li><li>一般而言，设置成10-20之间的数据足够满足需求了。</li></ul><h5 id="max-requests（最大请求数）"><a href="#max-requests（最大请求数）" class="headerlink" title="max_requests（最大请求数）"></a>max_requests（最大请求数）</h5><blockquote><p>最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn一个新的。<br>这个配置的主要目的是避免php解释器或程序引用的第三方库造成的内存泄露。<br>pm.max_requests = 10240</p></blockquote><ul><li>当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，自动重启该进程。</li><li>502，是后端 PHP-FPM 不可用造成的，间歇性的502一般认为是由于 PHP-FPM 进程重启造成的.</li><li>但是为什么要重启进程呢？</li><li>如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长（比如第三方库有问题等）。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长。</li><li>正是因为这个机制，在高并发中，经常导致 502 错误</li><li>目前我们解决方案是把这个值尽量设置大些，减少 PHP-CGI 重新 SPAWN 的次数，同时也能提高总体性能。PS：刚开始我们是500导致内存飙高，现在改成5120，当然可以再大一些，10240等，这个主要看测试结果，如果没有内存泄漏等问题，可以再大一些。</li></ul><h5 id="request-terminate-timeout（最长执行时间）"><a href="#request-terminate-timeout（最长执行时间）" class="headerlink" title="request_terminate_timeout（最长执行时间）"></a>request_terminate_timeout（最长执行时间）</h5><p><strong>max_execution_time</strong>和<strong>request_terminate_timeout</strong></p><blockquote><p>; The timeout for serving a single request after which the worker process will<br>; be killed. This option should be used when the ‘max_execution_time’ ini option<br>; does not stop script execution for some reason. A value of ‘0’ means ‘off’.<br>; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)<br>; Default Value: 0<br>;request_terminate_timeout = 0<br>＝＝＝＝＝＝＝＝＝＝＝＝<br>设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。</p></blockquote><ul><li>这两项都是用来配置一个PHP脚本的最大执行时间的。当超过这个时间时，PHP-FPM不只会终止脚本的执行，还会终止执行脚本的Worker进程。</li><li>Nginx会发现与自己通信的连接断掉了，就会返回给客户端502错误。</li></ul><h3 id="优化PHP-FPM压测"><a href="#优化PHP-FPM压测" class="headerlink" title="优化PHP-FPM压测"></a>优化PHP-FPM压测</h3><h4 id="优化PHP-FPM结果预览"><a href="#优化PHP-FPM结果预览" class="headerlink" title="优化PHP-FPM结果预览"></a>优化PHP-FPM结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/php-fpm%E4%BC%98%E5%8C%96.gif"></p><h4 id="PHP-FPM配置-1"><a href="#PHP-FPM配置-1" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96php-fpm.png"></p><h4 id="wrk压测结果-1"><a href="#wrk压测结果-1" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png"></p><h4 id="Nginx报错-1"><a href="#Nginx报错-1" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png"></p><h3 id="优化Nginx压测"><a href="#优化Nginx压测" class="headerlink" title="优化Nginx压测"></a>优化Nginx压测</h3><p><a href="https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/">https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/</a></p><p><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/">http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/</a></p><h4 id="错误：24-Too-many-open-files"><a href="#错误：24-Too-many-open-files" class="headerlink" title="错误：24: Too many open files"></a>错误：<code>24: Too many open files</code></h4><h5 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h5><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/nginx%E6%8A%A5%E9%94%99.png" alt="image-20191113164407658"> </p><h5 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h5><p>Linux / UNIX对文件句柄和打开文件的数量设置了软限制和硬限制。您可以使用ulimit命令查看这些限制</p><p>查看硬值和软值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>在Linux OS级别上增加开放FD限制</p><p>编辑文件/etc/sysctl.conf，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><p>追加/修改以下行：<br><code>fs.file-max = 100000</code></p><p>保存并关闭文件。编辑/etc/security/limits.conf，输入：<br><code># vi /etc/security/limits.conf</code></p><p>Set soft and hard limit for all users or nginx user as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx       soft    nofile   100000</span><br><span class="line">nginx       hard    nofile  100000</span><br></pre></td></tr></table></figure><p>保存并并关闭文件输入下面命令使之生效<br><code>sysctl -p</code></p><h4 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h4><p><a href="https://www.mtyun.com/library/how-to-optimize-nginx">https://www.mtyun.com/library/how-to-optimize-nginx</a></p><p><a href="https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html">https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html</a></p><p>对于Nginx的调优，可以大致从如下指令着手</p><ol><li>worker_processes </li><li>worker_connections</li><li>Buffers</li><li>Timeouts</li><li>Gzip Compression</li><li>Static File Caching</li><li>logging</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">8</span>;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="attribute">accept_mutex</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">accept_mutex_delay</span> <span class="number">500ms</span>;</span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>     <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">10</span>;</span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">crit</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> any;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">gzip_types</span><br><span class="line">text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">text/javascript application/javascript application/x-javascript</span><br><span class="line">text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">text/css text/plain text/x-component</span><br><span class="line">font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">image/x-icon;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE [1-6]\.(?!.*SV1)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">100000</span> inactive=<span class="number">20s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">30s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">12</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####worker_processes-配置工作进程数量</p><p><code>worker_processes</code>表示工作进程的数量，一般情况设置成CPU核的数量即可，一个cpu配置多于一个worker数，对Nginx而言没有任何益处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep processor &#x2F;proc&#x2F;cpuinfo | wc -l</span><br></pre></td></tr></table></figure><p>这个命令会告诉你当前机器是多少核，输出为8即表示8核。</p><h5 id="worker-cpu-affinity-配置cpu亲和性"><a href="#worker-cpu-affinity-配置cpu亲和性" class="headerlink" title="worker_cpu_affinity-配置cpu亲和性"></a>worker_cpu_affinity-配置cpu亲和性</h5><p>设置<code>worker_cpu_affinity</code>，这个配置用于将worker process与指定cpu核绑定，降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。 </p><h5 id="worker-rlimit-nofile-配置-worker-进程的最大打开文件数"><a href="#worker-rlimit-nofile-配置-worker-进程的最大打开文件数" class="headerlink" title="worker_rlimit_nofile-配置 worker 进程的最大打开文件数"></a>worker_rlimit_nofile-配置 worker 进程的最大打开文件数</h5><p>调整配置 Nginx worker 进程的最大打开文件数，这个控制连接数的参数为<code> worker_rlimit_nofile</code>。该参数的实际配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure><p>可设置为系统优化后的 <code>ulimit -HSn</code> 的结果</p><h5 id="events块-配置事件处理模型的优化"><a href="#events块-配置事件处理模型的优化" class="headerlink" title="events块-配置事件处理模型的优化"></a>events块-配置事件处理模型的优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="comment"># accept_mutex off;</span></span><br><span class="line"><span class="comment"># accept_mutex_delay 500ms;</span></span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>use epoll</strong></p><p>Nginx 的连接处理机制在不同的操作系统中会采用不同的 I/O 模型，在 linux 下，Nginx 使用 epoll 的 I/O 多路复用模型，在 Freebsd 中使用 kqueue 的 I/O 多路复用模型，在 Solaris 中使用 /dev/poll 方式的 I/O 多路复用模型，在 Windows 中使用 icop，等等。</p><p><code>events</code> 指令是设定 Nginx 的工作模式及连接数上限。<code>use</code>指令用来指定 Nginx 的工作模式。Nginx 支持的工作模式有 select、 poll、 kqueue、 epoll 、 rtsig 和/ dev/poll。当然，也可以不指定事件处理模型，Nginx 会自动选择最佳的事件处理模型。</p><p><strong>accept_mutex off/on ?</strong></p><p><a href="https://blog.huoding.com/2013/08/24/281">https://blog.huoding.com/2013/08/24/281</a></p><p><a href="https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a>    </p><p>关闭 accept_mutex ，请求在多个 worker 间的分配更均衡</p><h5 id="accept-mutex-delay"><a href="#accept-mutex-delay" class="headerlink" title="accept_mutex_delay"></a>accept_mutex_delay</h5><p>当accept_mutex功能启用后，只有一个持有mutex锁的worker进程会接受并处理请求，其他worker进程等待。accept_mutex_delay指定的时间就是这些worker进程的等待时间，过了等待时间下一个worker进程便取得mutex锁，处理请求。accept_mutex_delay在events模块中指定，默认的值为500ms。</p><h5 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h5><p>通过调整控制连接数的参数来调整 Nginx 单个进程允许的客户端最大连接数。    </p><p><code>worker_connections</code> 也是个事件模块指令，用于定义 Nginx 每个进程的最大连接数，默认是 1024。</p><p>最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections;</span><br></pre></td></tr></table></figure><p>如果作为反向代理，因为浏览器默认会开启 2 个连接到 server，而且 Nginx 还会使用fds（file descriptor）从同一个连接池建立连接到 upstream 后端。则最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients &#x3D; worker_processes * worker_connections &#x2F; 4;</span><br></pre></td></tr></table></figure><p>另外，<strong>进程的最大连接数受 Linux 系统进程的最大打开文件数限制</strong>，在执行操作系统命令 <code>ulimit -HSn 65535</code>或配置相应文件后， <code>worker_connections</code> 的设置才能生效。</p><p><strong>multi_accept</strong></p><p>默认情况下，Nginx 进程只会在一个时刻接收一个新的连接，我们可以配置<code>multi_accept</code> 为 <code>on</code>，实现在一个时刻内可以接收多个新的连接，提高处理效率。该参数默认是 <code>off</code>，建议开启。</p><h5 id="tcp优化"><a href="#tcp优化" class="headerlink" title="tcp优化"></a>tcp优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">  <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendfile</strong></p><p>第一行的 <code>sendfile</code> 配置可以提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。</p><p><strong>tcp_nopush</strong></p><p>TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 <code>tcp_nopush</code> 来控制它，并且只有在启用了 <code>sendfile</code> 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。</p><p><strong>keepalive_timeout</strong></p><p>Nginx 使用 keepalive_timeout 来指定 KeepAlive 的超时时间（timeout）。指定每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以可以设定为 60 秒。若将它设置为 0，就禁止了 keepalive 连接。</p><p><strong>keepalive_requests</strong></p><p>keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100。</p><p>这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。<br>大多数情况下当QPS(每秒请求数)不是很高时，默认值100凑合够用。但是，对于一些QPS比较高（比如超过10000QPS，甚至达到30000,50000甚至更高) 的场景，默认的100就显得太低。<br>简单计算一下，QPS=10000时，客户端每秒发送10000个请求(通常建立有多个长连接)，每个连接只能最多跑100次请求，意味着平均每秒钟就会有100个长连接因此被nginx关闭。同样意味着为了保持QPS，客户端不得不每秒中重新新建100个连接。因此，就会发现有大量的TIME_WAIT的socket连接(即使此时keep alive已经在client和nginx之间生效)。因此对于QPS较高的场景，非常有必要加大这个参数，以避免出现大量连接被生成再抛弃的情况，减少TIME_WAIT。</p><p><strong>tcp_nodelay</strong></p><p>TCP_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 <code>tcp_nodelay</code>。</p><h5 id="优化连接参数"><a href="#优化连接参数" class="headerlink" title="优化连接参数"></a>优化连接参数</h5><p>这部分更多是更具业务场景来决定的。例如<code>client_max_body_size</code>用来决定请求体的大小，用来限制上传文件的大小。上面列出的参数可以作为起始参数。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">  <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line">  <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Buffers：另一个很重要的参数为buffer，如果buffer太小，Nginx会不停的写一些临时文件，这样会导致磁盘不停的去读写，现在我们先了解设置buffer的一些相关参数：</p></blockquote><p><strong>client_body_buffer_size</strong></p><p>允许客户端请求的最大单个文件字节数</p><p><strong>client_header_buffer_size</strong></p><p>用于设置客户端请求的Header头缓冲区大小，大部分情况1KB大小足够</p><p><strong>client_max_body_size</strong></p><p>设置客户端能够上传的文件大小，默认为1m</p><p><strong>large_client_header_buffers</strong></p><p>该指令用于设置客户端请求的Header头缓冲区大小</p><h5 id="超时时间优化"><a href="#超时时间优化" class="headerlink" title="超时时间优化"></a>超时时间优化</h5><p><strong>client_body_timeout</strong></p><p>设定客户端与服务器建立连接后发送request body的超时时间。如果客户端在此时间内没有发送任何内容，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http, server 和 location模块中定义。</p><p><strong>client_header_timeout</strong></p><p>设定客户端向服务器发送一个完整的request header的超时时间。如果客户端在此时间内没有发送一个完整的request header，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http 和 server模块中定义。</p><p><strong>send_timeout</strong></p><p>指定了向客户端传输数据的超时时间。默认值为60秒，可以在http, server 和 location模块中定义</p><h5 id="压缩优化"><a href="#压缩优化" class="headerlink" title="压缩优化"></a>压缩优化</h5><p><strong>Gzip 压缩</strong></p><p>开启Gzip，gzip可以帮助Nginx减少大量的网络传输工作，另外要注意<code>gzip_comp_level</code>的设置，太高的话，Nginx服务会浪费CPU的执行周期。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">  <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">gzip_proxied</span> any;</span><br><span class="line">  <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">  gzip_types</span><br><span class="line">    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">    text/javascript application/javascript application/x-javascript</span><br><span class="line">    text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">    text/css text/plain text/x-component</span><br><span class="line">    font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">    image/x-icon;</span><br><span class="line">  <span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE [1-6]\.(?!.*SV1)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(jpg|jpeg|png|gif|ico|css|js)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">365d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测总结"><a href="#压测总结" class="headerlink" title="压测总结"></a>压测总结</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E5%8E%8B%E6%B5%8Bcupp.png">服务器负载已达到最大，php-fpm+nginx模式进行优化不能再明显的提高PRS</p><h2 id="Swoole"><a href="#Swoole" class="headerlink" title="Swoole"></a>Swoole</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1024</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">&quot;msie6&quot;</span>;</span><br><span class="line"><span class="attribute">upstream</span> swoole &#123;</span><br><span class="line">    <span class="comment"># 通过 IP:Port 连接</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:5200</span> weight=<span class="number">5</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="comment"># 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能</span></span><br><span class="line">    <span class="comment">#server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.2:5200 backup;</span></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> dabao.zhimma.com;</span><br><span class="line">    <span class="attribute">index</span>       index.php index.html index default;</span><br><span class="line">    <span class="attribute">root</span> /data/wwwroot/dabao/api/public;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/$server_name.access.log  main;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># Nginx处理静态资源(建议开启gzip)，LaravelS处理动态资源。</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> $uri @laravels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 当请求PHP文件时直接响应404，防止暴露public/*.php</span></span><br><span class="line">    <span class="comment">#location ~* \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    return 404;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="attribute">location</span> @laravels &#123;</span><br><span class="line">        <span class="comment"># proxy_connect_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_send_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_read_timeout 120s;</span></span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-PORT $remote_port;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Scheme $scheme;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Protocol $server_protocol;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Name $server_name;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Addr $server_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Port $server_port;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">&quot;HttpOnly&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">&quot;Secure&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Frame-Options <span class="string">&quot;SAMEORIGIN&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://swoole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /backend &#123;</span><br><span class="line">        <span class="attribute">alias</span> /data/wwwroot/dabao/web/;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> @router &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole1.gif"></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole2.gif"></p><h2 id="php-fpm-配置文件解读"><a href="#php-fpm-配置文件解读" class="headerlink" title="php-fpm 配置文件解读"></a>php-fpm 配置文件解读</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid</span> = /usr/local/var/run/php-fpm.pid</span><br><span class="line"><span class="comment">#pid设置，一定要开启,上面是Mac平台的。默认在php安装目录中的var/run/php-fpm.pid。比如centos的在: /usr/local/php/var/run/php-fpm.pid</span></span><br><span class="line"><span class="attr">error_log</span>  = /usr/local/var/log/php-fpm.log</span><br><span class="line"><span class="comment">#错误日志，上面是Mac平台的，默认在php安装目录中的var/log/php-fpm.log，比如centos的在: /usr/local/php/var/log/php-fpm.log</span></span><br><span class="line"><span class="attr">log_level</span> = notice</span><br><span class="line"><span class="comment">#错误级别. 上面的php-fpm.log纪录的登记。可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</span></span><br><span class="line"><span class="attr">emergency_restart_threshold</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">emergency_restart_interval</span> = <span class="number">60</span>s</span><br><span class="line"><span class="comment">#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。0 表示 &#x27;关闭该功能&#x27;. 默认值: 0 (关闭).</span></span><br><span class="line"><span class="attr">process_control_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</span></span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="comment">#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: &#x27;ip:port&#x27;, &#x27;port&#x27;, &#x27;/path/to/unix/socket&#x27;. 每个进程池都需要设置。如果nginx和php在不同的机器上，分布式处理，就设置ip这里就可以了。</span></span><br><span class="line"><span class="attr">listen.backlog</span> = -<span class="number">1</span></span><br><span class="line"><span class="comment">#backlog数，设置 listen 的半连接队列长度，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41</span></span><br><span class="line"><span class="attr">listen.allowed_clients</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment">#允许访问FastCGI进程的IP白名单，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接。</span></span><br><span class="line"><span class="attr">listen.owner</span> = www</span><br><span class="line"><span class="attr">listen.group</span> = www</span><br><span class="line"><span class="attr">listen.mode</span> = <span class="number">0666</span></span><br><span class="line"><span class="comment">#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</span></span><br><span class="line"><span class="attr">user</span> = www</span><br><span class="line"><span class="attr">group</span> = www</span><br><span class="line"><span class="comment">#启动进程的用户和用户组，FPM 进程运行的Unix用户, 必须要设置。用户组，如果没有设置，则默认用户的组被使用。</span></span><br><span class="line"><span class="attr">pm</span> = dynamic </span><br><span class="line"><span class="comment">#php-fpm进程启动模式，pm可以设置为static和dynamic和ondemand</span></span><br><span class="line"><span class="comment">#如果选择static，则进程数就数固定的，由pm.max_children指定固定的子进程数。</span></span><br><span class="line"><span class="comment">#如果选择dynamic，则进程数是动态变化的,由以下参数决定：</span></span><br><span class="line"><span class="attr">pm.max_children</span> = <span class="number">50</span> <span class="comment">#子进程最大数</span></span><br><span class="line"><span class="attr">pm.start_servers</span> = <span class="number">2</span> <span class="comment">#启动时的进程数，默认值为: min_spare_servers + (max_spare_servers - min_spare_servers) / 2</span></span><br><span class="line"><span class="attr">pm.min_spare_servers</span> = <span class="number">1</span> <span class="comment">#保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</span></span><br><span class="line"><span class="attr">pm.max_spare_servers</span> = <span class="number">3</span> <span class="comment">#，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</span></span><br><span class="line"><span class="attr">pm.max_requests</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 &#x27;0&#x27; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span></span><br><span class="line"><span class="attr">pm.status_path</span> = /status</span><br><span class="line"><span class="comment">#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</span></span><br><span class="line"><span class="attr">ping.path</span> = /ping</span><br><span class="line"><span class="comment">#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</span></span><br><span class="line"><span class="attr">ping.response</span> = pong</span><br><span class="line"><span class="comment">#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</span></span><br><span class="line"><span class="attr">access.log</span> = log/<span class="variable">$pool</span>.access.log</span><br><span class="line"><span class="comment">#每一个请求的访问日志，默认是关闭的。</span></span><br><span class="line"><span class="attr">access.format</span> = <span class="string">&quot;%R - %u %t \&quot;%m %r%Q%q\&quot; %s %f %&#123;mili&#125;d %&#123;kilo&#125;M %C%%&quot;</span></span><br><span class="line"><span class="comment">#设定访问日志的格式。</span></span><br><span class="line"><span class="attr">slowlog</span> = log/<span class="variable">$pool</span>.log.slow</span><br><span class="line"><span class="comment">#慢请求的记录日志,配合request_slowlog_timeout使用，默认关闭</span></span><br><span class="line"><span class="attr">request_slowlog_timeout</span> = <span class="number">10</span>s</span><br><span class="line"><span class="comment">#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 &#x27;0&#x27; 表示 &#x27;Off&#x27;</span></span><br><span class="line"><span class="attr">request_terminate_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的&#x27;max_execution_time&#x27;因为某些特殊原因没有中止运行的脚本有用. 设置为 &#x27;0&#x27; 表示 &#x27;Off&#x27;.当经常出现502错误时可以尝试更改此选项。</span></span><br><span class="line"><span class="attr">rlimit_files</span> = <span class="number">1024</span></span><br><span class="line"><span class="comment">#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</span></span><br><span class="line"><span class="attr">rlimit_core</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置核心rlimit最大限制值. 可用值: &#x27;unlimited&#x27; 、0或者正整数. 默认值: 系统定义值.</span></span><br><span class="line">chroot =</span><br><span class="line"><span class="comment">#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</span></span><br><span class="line">chdir =</span><br><span class="line"><span class="comment">#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</span></span><br><span class="line"><span class="attr">catch_workers_output</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Nginx错误日志说明"><a href="#Nginx错误日志说明" class="headerlink" title="Nginx错误日志说明"></a>Nginx错误日志说明</h2><table><thead><tr><th>错误信息</th><th>错误说明</th></tr></thead><tbody><tr><td>upstream prematurely（过早的） closed connection</td><td>请求uri的时候出现的异常，是由于upstream还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略</td></tr><tr><td>recv() failed (104: Connection reset by peer)</td><td>（1）服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉； （2）客户关掉了浏览器，而服务器还在给客户端发送数据； （3）浏览器端按了Stop</td></tr><tr><td>(111: Connection refused) while connecting to upstream</td><td>用户在连接时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while reading response header from upstream</td><td>用户在连接成功后读取数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while sending request to upstream</td><td>Nginx和upstream连接成功后发送数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(110: Connection timed out) while connecting to upstream</td><td>nginx连接后面的upstream时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(110: Connection timed out) while reading response header from upstream</td><td>nginx读取来自upstream的响应头时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(104: Connection reset by peer) while connecting to upstream</td><td>upstream发送了RST，将连接重置</td></tr><tr><td>upstream sent invalid header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>upstream sent no valid HTTP/1.0 header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>client intended to send too large body</td><td>用于设置允许接受的客户端请求内容的最大值，默认值是1M，client发送的body超过了设置值</td></tr><tr><td>reopening logs</td><td>用户发送kill  -WINCH命令</td></tr><tr><td>no servers are inside upstream</td><td>upstream下未配置server</td></tr><tr><td>no live upstreams while connecting to upstream</td><td>upstream下的server全都挂了</td></tr><tr><td>SSL_do_handshake() failed</td><td>SSL握手失败</td></tr><tr><td>SSL_write() failed (SSL:) while sending to client</td><td></td></tr><tr><td>(13: Permission denied) while reading upstream</td><td></td></tr><tr><td>(98: Address already in use) while connecting to upstream</td><td></td></tr><tr><td>(99: Cannot assign requested address) while connecting to upstream</td><td></td></tr><tr><td>ngx_slab_alloc() failed: no memory in SSL session shared cache</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>could not add new SSL session to the session cache while SSL handshaking</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>send() failed (111: Connection refused)</td><td></td></tr></tbody></table><h3 id="错误日志类型"><a href="#错误日志类型" class="headerlink" title="错误日志类型"></a>错误日志类型</h3><ul><li>类型1: upstream timed out</li><li>类型2: connect() failed</li><li>类型3: no live upstreams</li><li>类型4: upstream prematurely closed connection</li><li>类型5: 104: Connection reset by peer</li><li>类型6: client intended to send too large body</li><li>类型7: upstream sent no valid HTTP/1.0 header</li></ul><table><thead><tr><th>类型</th><th>错误日志</th><th>原因</th><th>解决办法</th></tr></thead><tbody><tr><td>1</td><td>upstream timed out (110: Connection timed out) while connecting to upstream</td><td>nginx与upstream建立tcp连接超时，nginx默认连接建立超时为200ms</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>1</td><td>upstream timed out (110: Connection timed out) while reading response header from upstream</td><td>nginx从upstream读取响应时超时，nginx默认的读超时为20s，读超时不是整体读的时间超时，而是指两次读操作之间的超时，整体读耗时有可能超过20s</td><td>排查upstream响应请求为什么过于缓慢</td></tr><tr><td>2</td><td>connect() failed (104: Connection reset by peer) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被reset</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>2</td><td>connect() failed (111: Connection refused) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被拒</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td><strong>3</strong></td><td><strong>no live upstreams while connecting to upstream</strong></td><td><strong>nginx向upstream转发请求时发现upstream状态全都为down</strong></td><td><strong>排查nginx的upstream的健康检查为什么失败</strong></td></tr><tr><td>4</td><td>upstream prematurely closed connection</td><td>nginx在与upstream建立完tcp连接之后，试图发送请求或者读取响应时，连接被upstream强制关闭</td><td>排查upstream程序是否异常，是否能正常处理http请求</td></tr><tr><td>5</td><td>recv() failed (104: Connection reset by peer) while reading response header from upstream</td><td>nginx从upstream读取响应时连接被对方reset</td><td>排查upstream应用已经tcp连接状态是否异常</td></tr><tr><td>6</td><td>client intended to send too large body</td><td>客户端试图发送过大的请求body，nginx默认最大允许的大小为1m，超过此大小，客户端会受到http 413错误码</td><td>调整请求客户端的请求body大小；调大相关域名的nginx配置：client_max_body_size；</td></tr><tr><td>7</td><td>upstream sent no valid HTTP/1.0 header</td><td>nginx不能正常解析从upstream返回来的请求行</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;性能概念TPS、QPS、RPS&quot;&gt;&lt;a href=&quot;#性能概念TPS、QPS、RPS&quot; class=&quot;headerlink&quot; title=&quot;性能概念TPS、QPS、RPS&quot;&gt;&lt;/a&gt;性能概念TPS、QPS、RPS&lt;/h2&gt;&lt;h3 id=&quot;TPS&quot;&gt;&lt;a href=&quot;#TPS&quot; class=&quot;headerlink&quot; title=&quot;TPS&quot;&gt;&lt;/a&gt;TPS&lt;/h3&gt;&lt;p&gt;TPS：Transactions Per Second（每秒事务处理数），指服务器每秒处理的事务次数。一般用于评估数据库、交易系统的基准性能。&lt;/p&gt;
&lt;h3 id=&quot;QPS&quot;&gt;&lt;a href=&quot;#QPS&quot; class=&quot;headerlink&quot; title=&quot;QPS&quot;&gt;&lt;/a&gt;QPS&lt;/h3&gt;&lt;p&gt;QPS：Queries Per Second（查询量/秒），是服务器每秒能够处理的查询次数，例如域名服务器、Mysql查询性能。&lt;/p&gt;
&lt;h3 id=&quot;RPS&quot;&gt;&lt;a href=&quot;#RPS&quot; class=&quot;headerlink&quot; title=&quot;RPS&quot;&gt;&lt;/a&gt;RPS&lt;/h3&gt;&lt;p&gt;RPS：Request Per Second（请求数/秒）RPS（Request Per Second）和QPS可以认为是一回事。RT：Response Time（响应时间）：客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。也叫Think Time。&lt;/p&gt;
&lt;h3 id=&quot;并发数与TPS-QPS的关系&quot;&gt;&lt;a href=&quot;#并发数与TPS-QPS的关系&quot; class=&quot;headerlink&quot; title=&quot;并发数与TPS/QPS的关系&quot;&gt;&lt;/a&gt;并发数与TPS/QPS的关系&lt;/h3&gt;&lt;p&gt;QPS（TPS）= 并发数/平均响应时间这里的并发数如果为事务处理请求数，则为TPS，如果为查询请求数，则为QPS。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
    <category term="PHP-FPM" scheme="https://blog.zhimma.com/categories/Nginx/PHP-FPM/"/>
    
    
    <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
    <category term="PHP-FPM" scheme="https://blog.zhimma.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>Lumen接入Azure的blob存储配置</title>
    <link href="https://blog.zhimma.com/2019/08/16/Lumen%E6%8E%A5%E5%85%A5Azure%E7%9A%84blob%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.zhimma.com/2019/08/16/Lumen%E6%8E%A5%E5%85%A5Azure%E7%9A%84blob%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2019-08-16T06:42:41.000Z</published>
    <updated>2021-03-23T10:08:28.335Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近在做的一个项目使用的是Azure服务器，其中数据库、redis、和对象存储和国内厂商都有不同，最直观的区别就是Azure基本都是SSL方式进行连接，相对国内云服务器厂商的服务接入没有那么无脑，今天简单记录下Azure提供的blob存储在lumen框架的接入</p><h3 id="几个轮子"><a href="#几个轮子" class="headerlink" title="几个轮子"></a>几个轮子</h3> <span id="more"></span><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer require league/flysystem</span><br><span class="line">composer require league/flysystem-azure-blob-storage</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Laravel/Lumen 提供了很强大的文件管理系统和云存储功能的集成</p><p><code>/Users/zhimma/Data/www/lumen/vendor/laravel/lumen-framework/config</code>目录复制一份到项目根目录下,主要检查<code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code>这个文件是否存在</p><p>下面进行配置：</p><ol><li><p><code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code></p><p>在配置s3下方添加如下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">&#x27;azure&#x27;</span> =&gt; [</span><br><span class="line">    <span class="string">&#x27;driver&#x27;</span>    =&gt; <span class="string">&#x27;azure&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>      =&gt; env(<span class="string">&#x27;AZURE_STORAGE_NAME&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span>       =&gt; env(<span class="string">&#x27;AZURE_STORAGE_KEY&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;container&#x27;</span> =&gt; env(<span class="string">&#x27;AZURE_STORAGE_CONTAINER&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p><code>/Users/zhimma/Data/www/lumen/bootstrap/app.php</code></p><ol><li>添加<code>$app-&gt;configure(&#39;filesystems&#39;);</code>表示加载该配置文件项</li><li>添加<code>$app-&gt;register(\Illuminate\Filesystem\FilesystemServiceProvider::class);</code>加载该服务提供者</li></ol></li><li><p><code>/Users/zhimma/Data/www/lumen/app/Providers/AppServiceProvider.php</code></p><p>新增下面的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Storage::extend(<span class="string">&#x27;azure&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$app</span>, <span class="variable">$config</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$endpoint</span> = sprintf(<span class="string">&#x27;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=%s;EndpointSuffix=core.chinacloudapi.cn&#x27;</span>,</span><br><span class="line">            <span class="variable">$config</span>[<span class="string">&#x27;name&#x27;</span>], <span class="variable">$config</span>[<span class="string">&#x27;key&#x27;</span>], <span class="variable">$config</span>[<span class="string">&#x27;url&#x27;</span>] ?? <span class="literal">null</span>, <span class="variable">$config</span>[<span class="string">&#x27;prefix&#x27;</span>] ?? <span class="literal">null</span>);</span><br><span class="line">        <span class="variable">$client</span> = BlobRestProxy::createBlobService(<span class="variable">$endpoint</span>);</span><br><span class="line">        <span class="variable">$adapter</span> = <span class="keyword">new</span> AzureBlobStorageAdapter(<span class="variable">$client</span>, <span class="variable">$config</span>[<span class="string">&#x27;container&#x27;</span>], <span class="variable">$config</span>[<span class="string">&#x27;prefix&#x27;</span>] ?? <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filesystem(<span class="variable">$adapter</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems">https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems</a></p></li></ol><h3 id="上传测试"><a href="#上传测试" class="headerlink" title="上传测试"></a>上传测试</h3><p>新增好路由后，我们进行上传测试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>  zhimma</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>    2019/5/27 12:00 PM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">Request <span class="variable">$request</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable">$request</span>-&gt;hasFile(<span class="string">&#x27;file&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$file</span> = <span class="variable">$request</span>-&gt;file(<span class="string">&#x27;file&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable">$file</span>-&gt;isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="variable">$file</span>-&gt;getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$path</span> = Storage::put(date(<span class="string">&#x27;Ymd&#x27;</span>), <span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$url</span> = env(<span class="string">&#x27;AZURE_BLOB_URL&#x27;</span>).<span class="string">&#x27;/&#x27;</span>.env(<span class="string">&#x27;AZURE_STORAGE_CONTAINER&#x27;</span>).<span class="string">&#x27;/&#x27;</span>.<span class="variable">$path</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success([<span class="string">&#x27;url&#x27;</span> =&gt; <span class="variable">$url</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;httpCode&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;statusCode&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://xxx.blob.core.chinacloudapi.cn/xxx/20190816/FKRJQXqo1Rdm77mAW2biuBSaVx12mH4U52NtKlZI.png&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此配置完成</p><p>参考</p><blockquote><p><a href="https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/">https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</a></p><p><a href="https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen">https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近在做的一个项目使用的是Azure服务器，其中数据库、redis、和对象存储和国内厂商都有不同，最直观的区别就是Azure基本都是SSL方式进行连接，相对国内云服务器厂商的服务接入没有那么无脑，今天简单记录下Azure提供的blob存储在lumen框架的接入&lt;/p&gt;
&lt;h3 id=&quot;几个轮子&quot;&gt;&lt;a href=&quot;#几个轮子&quot; class=&quot;headerlink&quot; title=&quot;几个轮子&quot;&gt;&lt;/a&gt;几个轮子&lt;/h3&gt;</summary>
    
    
    
    <category term="Azure" scheme="https://blog.zhimma.com/categories/Azure/"/>
    
    
    <category term="Azure" scheme="https://blog.zhimma.com/tags/Azure/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins初始化及常见问题整理</title>
    <link href="https://blog.zhimma.com/2019/06/19/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>https://blog.zhimma.com/2019/06/19/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2019-06-19T02:21:41.000Z</published>
    <updated>2021-03-23T10:08:17.090Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="错误异常处理"><a href="#错误异常处理" class="headerlink" title="错误异常处理"></a>错误异常处理</h2><h3 id="1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h"><a href="#1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h" class="headerlink" title="1. Failed to connect to repository : Error performing command: git ls-remote -h"></a>1. Failed to connect to repository : Error performing command: git ls-remote -h</h3><p><strong>产生原因:</strong> </p><p>Jenkins服务器没有安装git</p> <span id="more"></span><p><strong>解决方式：</strong></p><p><strong>1. Jenkins服务器上查看git是否已安装及安装位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ci ~]<span class="comment"># git version</span></span><br><span class="line">-bash: git: <span class="built_in">command</span> not found</span><br><span class="line">[root@ci ~]<span class="comment"># yum install git -y</span></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line">[root@ci ~]<span class="comment"># whereis git</span></span><br><span class="line">git: /usr/bin/git</span><br></pre></td></tr></table></figure><p><strong>2. 打开Jenkins的 主页面 &gt; 系统管理 &gt; Global Tool Configuration</strong></p><p>配置下git 的path   </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs1.gif"></p><h3 id="2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists."></a>2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.</h3><p><strong>产生原因:</strong> </p><p>代码仓库没有添加允许jenkins服务器用户拉取代</p><p><strong>解决方式：</strong></p><blockquote><p>创建秘钥可以参考第三个错误的解决步骤</p></blockquote><ul><li><p>检查jenkins服务器ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="comment"># cd .ssh</span></span><br><span class="line">[jenkins@ci ~]<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 1675 Jun 19 11:06 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  389 Jun 19 11:06 id_rsa.pub</span><br></pre></td></tr></table></figure><p>如果没有文件，则使用下面命令进行创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="variable">$ssh</span>-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/var/lib/jenkins/.ssh/id_rsa):</span><br><span class="line">// 一路回车即可</span><br></pre></td></tr></table></figure></li><li><p>在代码仓库添加jenkins服务器用户的公钥</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic3.png"></p></li><li><p>在jenkins管理端创建全局凭证并使用</p><ul><li><p>创建全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs2.gif"></p></li><li><p>使用全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic4.gif"></p></li></ul></li></ul><h3 id="3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied"><a href="#3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied" class="headerlink" title="3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied"></a>3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied</h3><p><a href="https://blog.csdn.net/cdnight/article/details/81078191">参考1</a></p><p>这里需要对Jenkins密钥进行配置</p><h4 id="3-1-切换jenkins用户不成功"><a href="#3-1-切换jenkins用户不成功" class="headerlink" title="3-1 切换jenkins用户不成功"></a>3-1 切换jenkins用户不成功</h4><p>jenkins系统本身有bug的，下面切换用户会失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su jenkins</span><br></pre></td></tr></table></figure><p>解决办法如下：</p><p><code>/etc/passwd</code>文件中的<code>/bin/bash</code>被yum安装的时候变成了<code>/bin/false</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic5.png"></p><p>然后我执行<code>cat /etc/passwd</code>命令，果然被改成了<code>/bin/false</code></p><p><code>cat /etc/passwd</code></p><p>接着执行<code>sudo vim /etc/passwd</code>命令,把<code>false</code>改为<code>bash</code></p><p><code>sudo vim /etc/passwd</code></p><p>改完后使用<code> grep jenkins /etc/passwd</code> 查看下是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins:x:997:995:Jenkins Automation Server:&#x2F;var&#x2F;lib&#x2F;jenkins:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="3-2-su-jenkins-bash-4-2问题"><a href="#3-2-su-jenkins-bash-4-2问题" class="headerlink" title="3-2 su jenkins  bash-4.2问题"></a>3-2 su jenkins  bash-4.2问题</h4><p>当我们切换到jenkins用户后，命令提示符的用户名不是jenkins而变成了<br><code>-bash-4.2#</code></p><p>网上一查，原因是在安装jenkins时，jenkins只是创建了jenkins用户，并没有为其创建home目录。所以系统就不会在创建用户的时候，自动拷贝/etc/skel目录下的用户环境变量文件到用户家目录，也就导致这些文件不存在，出现-bash-4.2#的问题了<br>以下命令是在切换到jenkins用户下执行的！（只是用户现在显示的是-bash-4.2）</p><p>这个时候呢，参考网上的做法我执行下面步骤： </p><ol><li><p>vim ~/.bash_profile<br>执行上面的命令，即使没有.bash_profile文件，linux会自动创建。 </p></li><li><p>然后再添加这句</p><p><code>export PS1=&#39;[\u@\h \W]\$&#39;</code></p></li><li><p>我们最后再刷新.bash_profile文件，使其起作用</p><p><code>source ~/.bash_profile</code></p></li></ol><h4 id="3-2-su-jenkins-bash-4-2再解决"><a href="#3-2-su-jenkins-bash-4-2再解决" class="headerlink" title="3-2 su jenkins  bash-4.2再解决"></a>3-2 su jenkins  bash-4.2再解决</h4><p><a href="https://www.mgchen.com/227.html">参考</a></p><p>在上面操作后，我使用su jenkins 还是会有bash-4.2界面，只需把命令变为su - jenkins可以解决，同事给了一个其他的方法</p><p>​    将/etc/skel/目录下 .bashrc和 .bash_profile 文件拷贝到用户的家目录下，然后对复制过去的文件授予该用户、用户组权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;skel&#x2F;.bashrc &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;</span><br><span class="line">cp &#x2F;etc&#x2F;skel&#x2F;.bash_profile &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;</span><br><span class="line">chown jenkins.jenkins &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;.bashrc</span><br><span class="line">chown jenkins.jenkins &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>​    然后退出重新登录，就恢复正常了。</p><p><strong>/etc/skel/目录作用：</strong></p><p>​       用来存放新用户环境变量文件，添加新用户时，将该目录下文件拷贝到新用户家目录中。</p><p>​       默认情况下该目录下都是隐藏文件（以.点开头的文件）；</p><p>​       通过修改、添加、删除该目录下的文件，可为新添加的用户提供统一的、标准的、初始化用户环境。</p><p>####3-3 su jenkins  需要输密码</p><p>上面我们解决了bash-4.2，下次从root切换jenkins用户的时候，发现需要输入密码，下面解决下这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>添加<code>jenkins ALL=(ALL) NOPASSWD: ALL</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic6.png"></p><p>然后执行<code>/etc/init.d/jenkins restart</code></p><h4 id="3-4-Jenkins密钥配置"><a href="#3-4-Jenkins密钥配置" class="headerlink" title="3-4 Jenkins密钥配置"></a>3-4 Jenkins密钥配置</h4><p><code>su - jenkins</code>切换到jenkins用户后，使用下面命令生成秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]$ssh-keygen</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;.ssh&#x2F;id_rsa):</span><br><span class="line">&#x2F;&#x2F; 一路回车即可</span><br></pre></td></tr></table></figure><p>生成后，</p><ol><li>把公钥添加到代码管理工具gitlab或者其他平台，使得jenkins用户有权限拉取代码</li><li>把公钥添加到需要发布代码的服务器，使得jenkins所在服务器有权限进行scp 或 ssh操作</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;错误异常处理&quot;&gt;&lt;a href=&quot;#错误异常处理&quot; class=&quot;headerlink&quot; title=&quot;错误异常处理&quot;&gt;&lt;/a&gt;错误异常处理&lt;/h2&gt;&lt;h3 id=&quot;1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h&quot;&gt;&lt;a href=&quot;#1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h&quot; class=&quot;headerlink&quot; title=&quot;1. Failed to connect to repository : Error performing command: git ls-remote -h&quot;&gt;&lt;/a&gt;1. Failed to connect to repository : Error performing command: git ls-remote -h&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;产生原因:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Jenkins服务器没有安装git&lt;/p&gt;</summary>
    
    
    
    <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
    <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Go零零碎碎</title>
    <link href="https://blog.zhimma.com/2019/06/17/Go%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
    <id>https://blog.zhimma.com/2019/06/17/Go%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</id>
    <published>2019-06-17T09:08:40.000Z</published>
    <updated>2021-03-23T10:07:21.688Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3> <span id="more"></span><p>值类型：基本数据类型int、float、bool、string、数组和结构体struct都属于值类型,使用这些类型的变量是直接使用指向存在内存中的值，值类型的变量的值通常存储在栈中</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>golang的统一编码为utf-8，golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8，所以字母数字占一字节，汉字占3字节</p><p>要获取一个字符串的长度，有以下2种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello 芝麻开门&quot;</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str 的长度:&quot;</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;str 的RuneCountInString长度:&quot;</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">&quot;str 的rune convert长度：&quot;</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>golang中还有一个<strong>byte</strong>数据类型，与<strong>rune</strong>相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于int8，常用来处理ascii字符</li><li>rune 等同于int32，常用来处理unicode或utf-8字符</li><li>循环一个字符串时，如果有中文，需要转切片，不然会出现乱码，因为是按照字符串的字节长度遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello 芝麻开门&quot;</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">&quot;str 的长度:&quot;</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;str 的RuneCountInString长度:&quot;</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">&quot;str 的rune convert长度：&quot;</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">runeStr := []<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runeStr); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, runeStr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment">h</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">芝</span></span><br><span class="line"><span class="comment">麻</span></span><br><span class="line"><span class="comment">开</span></span><br><span class="line"><span class="comment">门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 字符串函数</span></span><br><span class="line"><span class="comment">// 判断一个字符串是否包含指定的字符串</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计一个字符串有几个指定的字符，判断字符重复次数</span></span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;o&quot;</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较：不区分大小写==</span></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;Hello World&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串第一次出现的index值</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;o&quot;</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串最后一次出现的位置</span></span><br><span class="line">fmt.Println(strings.LastIndex(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;o&quot;</span>)) <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换 n=-1表示全部替换</span></span><br><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>, <span class="number">1</span>)) <span class="comment">// 你好 world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查分字符串为数组，类似PHP中的explode</span></span><br><span class="line">strArr := strings.Split(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;o w&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strArr 类型 %T,值%v\n&quot;</span>, strArr, strArr) <span class="comment">// strArr 类型 []string,值[hell orld]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr); i++ &#123;</span><br><span class="line">fmt.Println(strArr[i])</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hell</span></span><br><span class="line"><span class="comment">orld</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字符串大小写转换</span></span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;HELLO WORLD&quot;</span>)) <span class="comment">// hello world</span></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;hello world&quot;</span>)) <span class="comment">// HELLO WORLD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串两边的字符</span></span><br><span class="line">fmt.Println(strings.TrimRight(<span class="string">&quot;~hello world~&quot;</span>, <span class="string">&quot;~&quot;</span>)) <span class="comment">// ~hello world</span></span><br><span class="line">fmt.Println(strings.TrimLeft(<span class="string">&quot;~hello world~&quot;</span>, <span class="string">&quot;~&quot;</span>))  <span class="comment">// hello world~</span></span><br><span class="line">fmt.Println(strings.Trim(<span class="string">&quot;~hello world~&quot;</span>, <span class="string">&quot;~&quot;</span>))      <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 评断字符串头尾是否存在指定字符</span></span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello&quot;</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join联合组合字符串</span></span><br><span class="line">fmt.Println(strings.Join(strArr, <span class="string">&quot;o w&quot;</span>)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">&quot;go &quot;</span>, <span class="number">3</span>)) <span class="comment">// go go go</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义并初始化一个长度为3的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr, arr1) <span class="comment">// [1 2 3] [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个长度为6的数组，最后一个元素值为-1</span></span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">5</span>: <span class="number">-1</span>&#125;</span><br><span class="line">fmt.Println(arr2) <span class="comment">// [0 0 0 0 0 -1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3的int型数组，初始值是3个0,数组“零值”状态</span></span><br><span class="line"><span class="keyword">var</span> arr3 [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(arr3) <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">arr4 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">arr5 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>&#125;, &#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>&#125;&#125;</span><br><span class="line">fmt.Println(arr4, arr5) <span class="comment">// [[0 0] [0 0] [0 0]] [[a b] [AA BB] [AAA BBB]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new声明数组</span></span><br><span class="line">arr6 := <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr6类型%T，值%v&quot;</span>, arr6, arr6) <span class="comment">// arr6类型*[3]int，值&amp;[0 0 0]</span></span><br><span class="line"></span><br><span class="line">arr7 := <span class="built_in">new</span>([<span class="number">2</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr7类型%T，值%v&quot;</span> , arr7 , arr7) <span class="comment">// arr7类型*[2]int，值&amp;[0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">for_range</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;php&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key = %v , value = %v&quot;</span>, key, value)</span><br><span class="line"><span class="comment">// key = 0 , value = gokey = 1 , value = phpkey = 2 , value = java</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h3><h4 id="定义和创建"><a href="#定义和创建" class="headerlink" title="定义和创建"></a>定义和创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sliceDemo1()</span><br><span class="line">   sliceDemo2()</span><br><span class="line">   sliceDemo3()</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo1() &#123;</span><br><span class="line">   var arr [5]int &#x3D; [...]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">   var slice &#x3D; arr[1:3]</span><br><span class="line">   &#x2F;&#x2F; slice value&#x3D;[2 3] , cap&#x3D;4 , len&#x3D;2</span><br><span class="line">   fmt.Printf(&quot;slice value&#x3D;%v , cap&#x3D;%v , len&#x3D;%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo2() &#123;</span><br><span class="line">   var slice []int &#x3D; make([]int, 5, 10)</span><br><span class="line">   fmt.Println(slice) &#x2F;&#x2F; [0 0 0 0 0]</span><br><span class="line">   slice[1] &#x3D; 5</span><br><span class="line">   slice[3] &#x3D; 10</span><br><span class="line">   &#x2F;&#x2F; slice value&#x3D;[0 5 0 10 0] , cap&#x3D;10 , len&#x3D;5</span><br><span class="line">   fmt.Printf(&quot;slice value&#x3D;%v , cap&#x3D;%v , len&#x3D;%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo3() &#123;</span><br><span class="line">   &#x2F;&#x2F; 声明和初始化一个切片</span><br><span class="line">   var slice []string &#x3D; []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;</span><br><span class="line">   fmt.Printf(&quot;slice value&#x3D;%v , cap&#x3D;%v , len&#x3D;%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三种方式说明及区别"><a href="#三种方式说明及区别" class="headerlink" title="三种方式说明及区别"></a>三种方式说明及区别</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>sliceDemo1</strong>：让切片引用一个已经存在的数组创建切片</p><p><strong>sliceDemo2</strong>：使用make来创建，可以指定切片的大小和容量，如果没有给切片赋值，则会使用默认值，(int、float=&gt;0, strint=&gt;””, bool=&gt;false)；make方式创建的切片对应的数组由make底层维护，对外不开见，只能通过slice访问各个元素</p><p><strong>sliceDemo3</strong>：定义一个切片直接指定具体数组</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>sliceDemo1方式是直接引用数组，这个数组是事先存在的，对程序员可见</p><p>sliceDemo2通过make创建切片，make也会创建一个数组，是由切片在底层维护，该数组对程序员不可见    </p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">8</span>]<span class="keyword">int</span>&#123;<span class="number">22</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">55</span>, <span class="number">54</span>, <span class="number">33</span>&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    [1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">fmt.Println(bubble1(arr))</span><br><span class="line">fmt.Println(bubble2(arr))</span><br><span class="line">fmt.Println(bubble3(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble1</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8] <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">fmt.Println(data[i])</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble2</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(data); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] &gt; data[j] &#123;</span><br><span class="line">tmp := data[i]</span><br><span class="line">data[i] = data[j]</span><br><span class="line">data[j] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble3</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map相当于PHP中的关联数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mapDemo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 声明方式1</span></span><br><span class="line">   <span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">   map1[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;zhimma&quot;</span></span><br><span class="line">   map1[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;xian&quot;</span></span><br><span class="line">   fmt.Println(map1) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式2</span></span><br><span class="line">   map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   map2[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;zhimma&quot;</span></span><br><span class="line">   map2[<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;xian&quot;</span></span><br><span class="line">   fmt.Println(map2) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式3</span></span><br><span class="line">   map3 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:    <span class="string">&quot;zhimma&quot;</span>,</span><br><span class="line">      <span class="string">&quot;address&quot;</span>: <span class="string">&quot;xian&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(map3) <span class="comment">// // map[name:zhimma address:xian]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针相关概念"><a href="#指针相关概念" class="headerlink" title="指针相关概念"></a>指针相关概念</h2><p><strong>变量</strong>：变量是基本类型，变量存的就是值，也叫值类型</p><p><strong>地址</strong>：用于引用计算机的内存地址，可理解为内存地址的标签，通俗一点讲就是一个房子在小区门牌号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量name并赋值</span></span><br><span class="line">name := <span class="string">&quot;zhimma&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;name 的地址是&quot;</span>, &amp;name) <span class="comment">// name 的地址是 0xc000092030</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>指针</strong>：指针变量存的是一个<strong>地址</strong>，这个地址指向的空间存的才是值，指针是一个指向另一个变量内存地址的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;i 的地址是&quot;</span>, &amp;i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr=%v\n&quot;</span>, ptr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr的地址是%v\n&quot;</span>, &amp;ptr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr指向的值是%v\n&quot;</span>, *ptr)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    i 的地址是 0xc00001a080</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">ptr=0xc00001a080</span></span><br><span class="line"><span class="comment">ptr的地址是0xc00000c030</span></span><br><span class="line"><span class="comment">ptr指向的值是1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>&amp;:取地址符，指针 := &amp;变量</p><p>*:取值符， 变量 := *指针</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>定义匿名函数有2种方式</p><ul><li><p>定义时直接使用（这种方式只使用一次）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">totalNum := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(totalNum) <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将匿名函数赋值给变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数赋值给变量sunFunc</span></span><br><span class="line">sumFunc := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">total := sumFunc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局匿名函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalFunc = <span class="function"><span class="keyword">func</span><span class="params">(params <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;this is globalFunc and receive params str is&#x27;&quot;</span> + params + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := globalFunc(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">fmt.Println(str) <span class="comment">// this is globalFunc and receive params str is&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数用来分配内存，主要分配值类型，比如int、float32、struct等，返回的是指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num 的类型是%T,值是%v,地址是%v&quot;</span>, num, num, &amp;num) </span><br><span class="line">    <span class="comment">// num 的类型是int,值是100,地址是0xc00001a178</span></span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;num1 的类型是%T,值是%v,地址是%v&quot;</span>, num1, num1, &amp;num1)                </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a190,地址是0xc00000c030</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;num1 的类型是%T,值是%v,地址是%v,指向的值是%v&quot;</span>, num1, num1, &amp;num1, *num1) </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a098,地址是0xc00000c030,指向的值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;常见数据类型&quot;&gt;&lt;a href=&quot;#常见数据类型&quot; class=&quot;headerlink&quot; title=&quot;常见数据类型&quot;&gt;&lt;/a&gt;常见数据类型&lt;/h2&gt;&lt;h3 id=&quot;值类型&quot;&gt;&lt;a href=&quot;#值类型&quot; class=&quot;headerlink&quot; title=&quot;值类型&quot;&gt;&lt;/a&gt;值类型&lt;/h3&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker数据管理-volume/bind mount/tmpfs mount</title>
    <link href="https://blog.zhimma.com/2019/04/10/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-volume-bind-mount-tmpfs-mount/"/>
    <id>https://blog.zhimma.com/2019/04/10/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-volume-bind-mount-tmpfs-mount/</id>
    <published>2019-04-10T03:11:26.000Z</published>
    <updated>2021-03-29T06:03:08.256Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，它绕过<code>UFS</code>，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul> <span id="more"></span><h2 id="v-mount-如何选择"><a href="#v-mount-如何选择" class="headerlink" title="-v/-mount 如何选择"></a>-v/-mount 如何选择</h2><p>最初，<code>-v</code> 和 <code>-volume</code> 用于独立的容器，<code>--mount</code> 用于 swarm server。但 docker 17.06 之后，也可以使用 <code>--mount</code>。两者的区别在于，<code>-v</code> 将所有选项组合在一个字段中，<code>--mount</code> 则将它们分开。</p><blockquote><p>新用户应使用 <code>--mount</code> 语法，老用户推荐使用 <code>--mount</code>。</p></blockquote><ul><li><code>-v/--volume</code>，由（<code>:</code>）分隔的三个字段组成，<code>&lt;卷名&gt;:&lt;容器路径&gt;:&lt;选项列表&gt;</code>。选项列表，如：<code>ro</code>只读。</li><li><code>--mount</code>，由多个键值对组成，由<code>,</code>分隔，每个由一个<code>&lt;key=&lt;value&gt;&gt;</code>元组组成。<ul><li><code>type</code>，值可以为 <code>bind</code>，<code>volume</code>，<code>tmpfs</code>。</li><li><code>source</code>，对于命名卷，是卷名。对于匿名卷，这个字段被省略。可能被指定为 <code>source</code> 或 <code>src</code>。</li><li><code>destination</code>，文件或目录将被挂载到容器中的路径。可以指定为 <code>destination</code>，<code>dst</code> 或 <code>target</code>。</li><li><code>volume-opt</code> 可以多次指定。</li></ul></li></ul><h2 id="选择合适的挂载方式"><a href="#选择合适的挂载方式" class="headerlink" title="选择合适的挂载方式"></a>选择合适的挂载方式</h2><p>Docker提供了3种方法将数据从Docker宿主机挂载（mount）到容器：<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>。一般来说，<code>volumes</code>总是最好的选择。</p><p>不管你选择哪种挂载方式，从容器中看都是一样的。数据在容器的文件系统中被展示为一个目录或者一个单独的文件。</p><p>一个简单区分<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>不同点的方法是：<strong>思考数据在宿主机上是如何存在的。</strong></p><ul><li><strong>Volumes</strong>由Docker管理，存储在宿主机的某个地方（在linux上是<code>/var/lib/docker/volumes/</code>）。非Docker应用程序不能改动这一位置的数据。Volumes是Docker最好的数据持久化方法。</li><li><strong>Bind mounts</strong>的数据可以存放在宿主机的任何地方。数据甚至可以是重要的系统文件或目录。非Docker应用程序可以改变这些数据。</li><li><strong>tmpfs mounts</strong>的数据只存储在宿主机的内存中，不会写入到宿主机的文件系统。</li></ul><h2 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h2><p><strong>Volumes</strong>：由Docker创建和管理。你可以通过<code>docker volume create</code>命令显式地创建<code>volume</code>，Docker也可以在创建容器或服务是自己创建volume。</p><p>例如下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">☁  Docker  docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name demo \</span><br><span class="line">  --mount type=volume,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line">7eb04d34a87ecd4a7996f8ad4da83bd613d2e992f6860faf730b876a66efd19f</span><br><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               0c06952c157c3b6550e7f71a9c6463a1b70c893c15b0d8e0b8d05ad398ced427</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure><blockquote><p>第一行：先查看下volume列表</p><p>第四行：创建container，并使用type=volume类型，指向container内部app目录</p><p>第十行：查看最新的volume列表</p></blockquote><p>当你创建了一个volume，它会被存放在宿主机的一个目录下。当你将这个volume挂载到某个容器时，这个目录就是挂载到容器的东西。这一点和<code>bind mounts</code>类似，除了volumes是由Docker创建的，和宿主机的核心（<code>core functionality</code>）隔离。</p><p>一个volume可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个volume，volume依然存在，不会被自动清除。可以通过<code>docker volume prune</code>清除不再使用的volumes。</p><p>volumes也支持<code>volume driver</code>，可以将数据存放在另外的机器或者云上。</p><p><strong>Bind mounts</strong>：Docker早期就支持这个特性。与volumes相比，<code>Bind mounts</code>支持的功能有限。使用<code>bind mounts</code>时，可以将你主机上的任何文件或目录（<strong>绝对路径</strong>）挂载到容器中。</p><blockquote><p>警告：使用<code>Bind mounts</code>的一个副作用是，容器中运行的程序可以修改宿主机的文件系统，包括创建，修改，删除重要的系统文件或目录。这个功能可能会有安全问题。</p></blockquote><p><strong>tmpfs mounts</strong>：<code>tmpfs mounts</code>的数据不会落盘。在容器的生命周期内，它可以被用来存储一些不需要持久化的状态或敏感数据。例如，<code>swarm</code>服务通过<code>tmpfs mounts</code>来将<a href="https://docs.docker.com/engine/swarm/secrets/">secrets</a>挂载到一个服务的容器中去。</p><h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><h3 id="适合volume的场景"><a href="#适合volume的场景" class="headerlink" title="适合volume的场景"></a>适合volume的场景</h3><ul><li>在不同的容器中共享数据，如果未显式创建它，则会在第一次将其装入容器时创建。当该容器停止或被移除时，该卷仍然存在。多个容器可以同时安装相同的卷，可以是读写也可以是只读。仅在您明确删除卷时才会删除卷</li><li>当Docker主机不能保证具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时分离。</li><li>如果要将容器的数据存储在远程主机或云提供程序上，而不是本地存储。</li><li>当你需要备份或迁移数据的时候，当您需要能够将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是更好的选择。您可以使用卷停止容器，然后备份卷的目录（例如/var/lib/docker/volumes/）</li></ul><h3 id="适合bind-mounts的场景"><a href="#适合bind-mounts的场景" class="headerlink" title="适合bind mounts的场景"></a>适合bind mounts的场景</h3><ul><li>宿主机和容器共享配置文件。Docker提供的DNS解决方案就是如此，将宿主机的<code>/etc/resolv.conf</code>挂载到每个容器中。</li><li>开发环境需要在宿主机和容器中共享代码。docker的开发就是如此，毕竟容器中一般是没有编辑器的</li><li>当Docker主机的文件或目录结构保证与容器所需的绑定安装一致时</li></ul><h2 id="适合tmpfs-mounts的场景"><a href="#适合tmpfs-mounts的场景" class="headerlink" title="适合tmpfs mounts的场景"></a>适合tmpfs mounts的场景</h2><p><code>tmpfs mounts</code>主要用在你既不想在容器内，又不想在宿主机文件系统保存数据的时候。这可能是出于安全原因，也可能是你的应用需要写非常多的非持久化数据，<code>tmpfs mounts</code>这时候可以保证容器性能。    </p><blockquote><p> 本文转自<a href="https://michaelyou.github.io/2017/09/17/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-Volume%EF%BC%8C-bind-mount%E5%92%8Ctmpfs-mount/">这里</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数据卷&lt;/code&gt;是一个可供一个或多个容器使用的特殊目录，它绕过&lt;code&gt;UFS&lt;/code&gt;，可以提供很多有用的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据卷 可以在容器之间共享和重用&lt;/li&gt;
&lt;li&gt;对 数据卷 的修改会立马生效&lt;/li&gt;
&lt;li&gt;对 数据卷 的更新，不会影响镜像&lt;/li&gt;
&lt;li&gt;数据卷 默认会一直存在，即使容器被删除&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Docker" scheme="https://blog.zhimma.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记8-Go语言并发</title>
    <link href="https://blog.zhimma.com/2019/03/22/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91/"/>
    <id>https://blog.zhimma.com/2019/03/22/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91/</id>
    <published>2019-03-22T06:33:29.000Z</published>
    <updated>2021-03-23T10:08:04.788Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言通过编译器运行时（runtime）,从语言上支持了并发的特性。Go 语言的并发通过goroutine 特性完成。<br>goroutine 类似于线程，但可以根据需要创建多个goroutine并发工作<br>goroutine 是由Go 语言的运行时调度完成，而线程是由操作系统调度完成</p><p>Go 语言还提供channel 在多个goroutine 间进行通信。goroutine 和 channel是Go 语言秉承CSP并发模式的重要实现基础。</p> <span id="more"></span><h2 id="Go-语言goroutine"><a href="#Go-语言goroutine" class="headerlink" title="Go 语言goroutine"></a>Go 语言goroutine</h2><p>在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。<br>开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。</p><p>如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go 语言中被称为 <strong>goroutine</strong>。</p><p>goroutine 的概念类似于线程，但 goroutine 是由Go 程序运行时进行调度和管理。Go 程序会智能地将goroutine 中的任务合理地分配给每个CPU</p><p>Go 程序从main 包的main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的goroutine</p><h3 id="使用普通函数创建-goroutine"><a href="#使用普通函数创建-goroutine" class="headerlink" title="使用普通函数创建 goroutine"></a>使用普通函数创建 goroutine</h3><p>Go 语言程序中使用<strong>go</strong>关键字为一个函数创建一个goroutine。一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数</p><p><strong>格式</strong></p><p>为一个普通函数创建goroutine的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>使用 <strong>go</strong>关键字创建goroutine时，被调用函数的返回值会被忽略</p><p>如果需要在goroutine中返回数据，需要使用channel特性，通过通道(channel)把数据从goroutine中作为返回值传出</p><p><strong>例子</strong></p><p>使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> running()</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input) <span class="comment">// 接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">running</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times++</span><br><span class="line">fmt.Println(<span class="string">&quot;tick&quot;</span> , times)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行输出如下：<br>tick 1<br>tick 2<br>tick 3<br>tick 4<br>tick 5</p><p>代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。</p><p>这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。</p><h3 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a>使用匿名函数创建goroutine</h3><p>go 关键字后也可以为匿名函数或者闭包启动goroutine</p><p><strong>使用匿名函数创建goroutine</strong></p><p>使用匿名函数或者闭包创建goroutine时，除了将函数定义部分卸载go 的后面之外，还需要加上匿名函数的调用参数，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;(调用参数列表)</span><br></pre></td></tr></table></figure><p><strong>使用匿名函数创建goroutine例子</strong></p><p>在main() 函数中创建一个匿名函数并未匿名函数启动goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times ++</span><br><span class="line">fmt.Println(<span class="string">&quot;tick&quot;</span> , times)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。</p><p>终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数</p><h2 id="Go语言GOMAXPROCS-调整并发的运行性能"><a href="#Go语言GOMAXPROCS-调整并发的运行性能" class="headerlink" title="Go语言GOMAXPROCS(调整并发的运行性能)"></a>Go语言GOMAXPROCS(调整并发的运行性能)</h2><p>在 Go 程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br></pre></td></tr></table></figure><p>这里的逻辑CPU数量可以有以下几种数值：</p><ul><li>&lt;1不修改任何数值</li><li>=1单核心执行</li><li>&gt;1多喝并发执行</li></ul><p>一般情况下，可以使用 <code>runtime.NumCPU() </code>查询 CPU 数量，并使用<code> runtime.GOMAXPROCS()</code> 函数进行设置，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure><p>GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。</p><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>下面让我们来了解并发和并行之间的区别：</p><ul><li>并发：把任务在不同的时间点交给处理器进行处理，在同一时间点，任务并不会同时运行</li><li>并行：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li></ul><p>两个概念的区别是：任务是否同时执行。举一个生活中的例子：打电话和吃饭。</p><p>吃饭时，电话来了，需要停止吃饭去接电话。电话接完后回来继续吃饭，这个过程是并发执行。</p><p>吃饭时，电话来了，边吃饭边接电话。这个过程是并行执行。</p><p>GO 语言在 GOMAXPROCS 数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。</p><h3 id="goroutine-和-coroutine的区别"><a href="#goroutine-和-coroutine的区别" class="headerlink" title="goroutine 和 coroutine的区别"></a>goroutine 和 coroutine的区别</h3><p>coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p><ul><li>goroutine 可能发生并行执行；</li><li>但 coroutine 始终顺序执行。</li></ul><p>狭义的说，</p><p>goroutine 可能发生在多线程环境下，goroutine无法控制自己获取高优先度支持</p><p>coroutine始终发生在单线程，coroutine 程序需要主动交出控制器，宿主才能获得控制权并将控制权交给其他coroutine</p><p>goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。</p><p>coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。</p><p>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p><h2 id="Go语言通道-chan"><a href="#Go语言通道-chan" class="headerlink" title="Go语言通道(chan)"></a>Go语言通道(chan)</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言通过编译器运行时（runtime）,从语言上支持了并发的特性。Go 语言的并发通过goroutine 特性完成。&lt;br&gt;goroutine 类似于线程，但可以根据需要创建多个goroutine并发工作&lt;br&gt;goroutine 是由Go 语言的运行时调度完成，而线程是由操作系统调度完成&lt;/p&gt;
&lt;p&gt;Go 语言还提供channel 在多个goroutine 间进行通信。goroutine 和 channel是Go 语言秉承CSP并发模式的重要实现基础。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记7-包(package)</title>
    <link href="https://blog.zhimma.com/2019/03/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-%E5%8C%85-package/"/>
    <id>https://blog.zhimma.com/2019/03/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-%E5%8C%85-package/</id>
    <published>2019-03-20T08:07:57.000Z</published>
    <updated>2021-03-23T10:08:00.405Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>终于学到包了，前面有忘得差不多了，特别是接口，晕晕乎乎的，期待学完之后的项目实战</p><p>Go 语言的源码复用建立在包(package) 基础之上。Go 语言的入口main() 函数所在的包叫main，main 包想要引用别的代码，必须同样以包的方式进行。</p> <span id="more"></span><p>Go 于洋的包与文件夹一一对应，所有与包相关的操作，必须依赖工作目录（GOPATH）</p><h2 id="GOPATH详解"><a href="#GOPATH详解" class="headerlink" title="GOPATH详解"></a>GOPATH详解</h2><p>GOPATH 是Go 语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  go env // 执行 go env 指令，将输出当前 Go 开发包的环境变量状态。 </span><br><span class="line">GOARCH=&quot;amd64&quot; // GOARCH 表示目标处理器架构</span><br><span class="line">GOBIN=&quot;&quot; // GOBIN 表示编译器和链接器的安装位置。 </span><br><span class="line">GOCACHE=&quot;/Users/zhimma/Library/Caches/go-build&quot;</span><br><span class="line">GOEXE=&quot;&quot;</span><br><span class="line">GOFLAGS=&quot;&quot;</span><br><span class="line">GOHOSTARCH=&quot;amd64&quot;</span><br><span class="line">GOHOSTOS=&quot;darwin&quot;</span><br><span class="line">GOOS=&quot;darwin&quot; // GOOS 表示目标操作系统 </span><br><span class="line">GOPATH=&quot;/Users/zhimma/go&quot; // GOPATH 表示当前工作目录</span><br><span class="line">GOPROXY=&quot;&quot;</span><br><span class="line">GORACE=&quot;&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot; // GOROOT 表示 Go 开发包的安装目录</span><br><span class="line">GOTMPDIR=&quot;&quot;</span><br><span class="line">GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;</span><br><span class="line">GCCGO=&quot;gccgo&quot;</span><br><span class="line">CC=&quot;clang&quot;</span><br><span class="line">CXX=&quot;clang++&quot;</span><br><span class="line">CGO_ENABLED=&quot;1&quot;</span><br><span class="line">GOMOD=&quot;&quot;</span><br><span class="line">CGO_CFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_CPPFLAGS=&quot;&quot;</span><br><span class="line">CGO_CXXFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_FFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_LDFLAGS=&quot;-g -O2&quot;</span><br><span class="line">PKG_CONFIG=&quot;pkg-config&quot;</span><br></pre></td></tr></table></figure><p>在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。</p><table><thead><tr><th>平  台</th><th>GOPATH 默认值</th><th>举 例</th></tr></thead><tbody><tr><td>Windows 平台</td><td>%USERPROFILE%/go</td><td>C:\Users\用户名\go</td></tr><tr><td>Unix 平台</td><td>$HOME/go</td><td>/home/用户名/go</td></tr></tbody></table><h3 id="使用GOPATH的工程结构"><a href="#使用GOPATH的工程结构" class="headerlink" title="使用GOPATH的工程结构"></a>使用GOPATH的工程结构</h3><p>在GOPATH 指定的工作目录下，代码总是会保存在<code>$GOPATH/src </code>目录下。在工程经过go build、go install或者go get 等指令后，会将产生的二进制可执行文件放在<code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code>下。</p><p>如果需要将整个源码添加到版本管理工具中时，只需要添加 <code>$GOPATH/src</code> 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</p><h3 id="设置和使用GOPATH"><a href="#设置和使用GOPATH" class="headerlink" title="设置和使用GOPATH"></a>设置和使用GOPATH</h3><p>下面以Linux为例进行演示</p><h4 id="设置当前目录为GOPATH"><a href="#设置当前目录为GOPATH" class="headerlink" title="设置当前目录为GOPATH"></a>设置当前目录为GOPATH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH&#x3D;&#96;pwd&#96;</span><br></pre></td></tr></table></figure><h4 id="建立GOPATH中的源码目录"><a href="#建立GOPATH中的源码目录" class="headerlink" title="建立GOPATH中的源码目录"></a>建立GOPATH中的源码目录</h4><p>使用下面指令创建GOPATH中的src 目录，在src目录下还有一个hello目录，该目录用于保存源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src&#x2F;hello</span><br></pre></td></tr></table></figure><h4 id="添加main-go源码文件"><a href="#添加main-go源码文件" class="headerlink" title="添加main.go源码文件"></a>添加main.go源码文件</h4><p>使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 $GOPATH/src/hello 目录下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译源码并运行"><a href="#编译源码并运行" class="headerlink" title="编译源码并运行"></a>编译源码并运行</h4><p>此时我们已经设定了 GOPATH，因此在 Go 语言中可以通过 GOPATH 找到工程的位置。</p><p>在命令行中执行如下指令编译源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install hello</span><br></pre></td></tr></table></figure><p>编译完成的可执行文件会保存在 $GOPATH/bin 目录下。</p><p>在 bin 目录中执行 ./hello，命令行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="package-创建包"><a href="#package-创建包" class="headerlink" title="package(创建包)"></a>package(创建包)</h2><p>包 是多个Go 源码的集合，是一种高级的代码复用方案，Go 语言默认为我们提供了很多包，如fmt、os、io包等。</p><p>包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>包的特性如下：</p><ul><li>一个目录下的同级文件归属一个包。</li><li>包名可以与其目录不同名。</li><li>包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。</li></ul><h2 id="包中的标识符"><a href="#包中的标识符" class="headerlink" title="包中的标识符"></a>包中的标识符</h2><p>如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的<strong>首字母大写</strong>就可以让引用者可以访问这些标识符了。</p><h2 id="import-导入包"><a href="#import-导入包" class="headerlink" title="import 导入包"></a>import 导入包</h2><p>要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用<code>/</code>进行路径分隔。</p><h3 id="默认导入的写法"><a href="#默认导入的写法" class="headerlink" title="默认导入的写法"></a>默认导入的写法</h3><p>导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的</p><h4 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h4><p>单行导入格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包1&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;包2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-多行导入"><a href="#2-多行导入" class="headerlink" title="2) 多行导入"></a>2) 多行导入</h4><p>当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;包1&quot;</span></span><br><span class="line">    <span class="string">&quot;包2&quot;</span></span><br><span class="line">    …</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="导入包后自定义引用的包名"><a href="#导入包后自定义引用的包名" class="headerlink" title="导入包后自定义引用的包名"></a>导入包后自定义引用的包名</h3><p>在默认导入包的基础上，在导入包路径前添加标识符即可形成自定义引用包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customName <span class="string">&quot;path/to/package&quot;</span></span><br></pre></td></tr></table></figure><p>其中，path/to/package 为要导入的包路径，customName 为自定义的包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    renameLib <span class="string">&quot;chapter08/importadd/mylib&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(renameLib.Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h3><p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;path/to/package&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，path/to/package 表示要导入的包名，下画线<code>_</code>表示匿名导入包。</p><p>匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。</p><h3 id="包在程序启动前的初始化入口：init"><a href="#包在程序启动前的初始化入口：init" class="headerlink" title="包在程序启动前的初始化入口：init"></a>包在程序启动前的初始化入口：init</h3><p>在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。</p><p>init() 函数的特性如下：</p><ul><li>每个源码可以使用 1 个 init() 函数。</li><li>init() 函数会在程序执行前（main() 函数执行前）被自动调用。</li><li>调用顺序为 main() 中引用的包，以深度优先顺序初始化。</li></ul><p>例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.init→B.init→A.init→main</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>同一个包中的多个 init() 函数的调用顺序不可预期。</li><li>init() 函数不能被其他函数调用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;终于学到包了，前面有忘得差不多了，特别是接口，晕晕乎乎的，期待学完之后的项目实战&lt;/p&gt;
&lt;p&gt;Go 语言的源码复用建立在包(package) 基础之上。Go 语言的入口main() 函数所在的包叫main，main 包想要引用别的代码，必须同样以包的方式进行。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记6-接口</title>
    <link href="https://blog.zhimma.com/2019/03/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/03/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-03-14T08:03:29.000Z</published>
    <updated>2021-03-23T10:07:53.432Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p><p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p><p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p> <span id="more"></span><h2 id="Go语言接口声明定义"><a href="#Go语言接口声明定义" class="headerlink" title="Go语言接口声明定义"></a>Go语言接口声明定义</h2><p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p><h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成，接口的形式代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名<span class="number">1</span>(参数列表<span class="number">1</span>) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>(参数列表<span class="number">2</span>) 返回值列表<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各个部分的说明：</p><ul><li><p>接口类型名： 使用 type 将接口定义为自定义的类型名。Go 语言在接口命名时，一并会在单词后面添加 <strong>er</strong>，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer…</p></li><li><p>方法名： 当方法名首字母大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问</p></li><li><p>参数列表、返回值列表： 参数列表和返回值列表中的参数变量名可以被忽略，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发中常见接口及写法"><a href="#开发中常见接口及写法" class="headerlink" title="开发中常见接口及写法"></a>开发中常见接口及写法</h3><p>Go 语言提供的很多包中都有接口，例如 io 包中提供的Writer 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口可以调用 Write() 方法写入一个字节数组([]byte)，返回值告知写入字节数（n int）和可能发生的错误（err error）</p><h2 id="Go语言实现接口的条件"><a href="#Go语言实现接口的条件" class="headerlink" title="Go语言实现接口的条件"></a>Go语言实现接口的条件</h2><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用</p><h3 id="条件一：接口的方法与实现接口的类型方式格式一致"><a href="#条件一：接口的方法与实现接口的类型方式格式一致" class="headerlink" title="条件一：接口的方法与实现接口的类型方式格式一致"></a>条件一：接口的方法与实现接口的类型方式格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该接口。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><p>数据写入器的抽象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，入参接收interface&#123;&#125; 类型的 data，返回一个 error 结构表示可能发生的错误</span></span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="comment">// file 的 WriteData() 方法使用指针接收器。输入一个 interface&#123;&#125; 类型的 data，返回 error。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *file)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;实现了DataWriter接口的WriteData方法&quot;</span> , data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化结构file</span></span><br><span class="line"><span class="comment">// 实例化 file 赋值给 f，f 的类型为 *file。</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter类型的writer接口变量</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口复赋值给f，也就是*file类型</span></span><br><span class="line">    <span class="comment">// 将 *file 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">writer.WriteData(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p><h4 id="1-函数名不一致导致的报错"><a href="#1-函数名不一致导致的报错" class="headerlink" title="1) 函数名不一致导致的报错"></a>1) 函数名不一致导致的报错</h4><h4 id="2-实现接口的方法签名不一致导致的报错"><a href="#2-实现接口的方法签名不一致导致的报错" class="headerlink" title="2) 实现接口的方法签名不一致导致的报错"></a>2) 实现接口的方法签名不一致导致的报错</h4><h3 id="条件二：接口中所有方法均被实现"><a href="#条件二：接口中所有方法均被实现" class="headerlink" title="条件二：接口中所有方法均被实现"></a>条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p><p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    <span class="comment">// 能否写入</span></span><br><span class="line">    CanWrite() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (<span class="keyword">type</span> *file) as <span class="keyword">type</span> DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></table></figure><p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p><p>Go 语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p><p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p><h2 id="Go语言类型与接口的关系"><a href="#Go语言类型与接口的关系" class="headerlink" title="Go语言类型与接口的关系"></a>Go语言类型与接口的关系</h2><p>类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。</p><h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口见彼此独立，不知道对方的实现</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p><p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p><p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Socket 结构的Write方法实现了io.Writer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时，Socket 结构也实现了 io.Close 接口：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6100I14b.jpg"></p><p>在代码中使用Socket结构实现的Writer接口和Closer接口代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingWriter</span><span class="params">(writer io.Writer)</span></span> &#123;</span><br><span class="line">writer.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingCloser</span><span class="params">(closer io.Closer)</span></span> &#123;</span><br><span class="line">closer.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(Socket)</span><br><span class="line">usingWriter(s)</span><br><span class="line">usingCloser(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个服务需要满足能够开启和写日志的功能</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()  <span class="comment">// 开启服务</span></span><br><span class="line">    Log(<span class="keyword">string</span>)  <span class="comment">// 日志输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日志器 定义能输出日志的日志器结构。</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(l <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 GameService 结构。</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">    Logger  <span class="comment">// 在 GameService 中嵌入 Logger 日志器，以实现日志功能。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Service的Start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Service = <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></table></figure><p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>Go语言中不同结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口</p><p>接口与接口嵌套组合而成了新接口，只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用</p><h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go 语言的io 包中定义写入器（Writer）、关闭器（Closer）和写入关闭器（WriteClose）3个接口，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriterCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</span></span><br><span class="line"><span class="keyword">var</span> wc io.WriteCloser = <span class="built_in">new</span>(device)</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">wc.Write(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeOnly io.Writer = <span class="built_in">new</span>(device)</span><br><span class="line"></span><br><span class="line">writeOnly.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>io.WriteCloser的实现及调用过程如图 1 所示。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ61125141Z.jpg" alt="img"></p><ol start="2"><li>io.Writer 的实现调用过程如图 2 所示。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6112952232.jpg" alt="img"></p><p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。&lt;/p&gt;
&lt;p&gt;Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。&lt;/p&gt;
&lt;p&gt;非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记5-结构体</title>
    <link href="https://blog.zhimma.com/2019/03/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://blog.zhimma.com/2019/03/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2019-03-12T07:16:13.000Z</published>
    <updated>2021-03-23T10:07:49.768Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型<br>Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性</p><p>Go 语言中的类型可以被实例化，使用<code>new</code> 或<code>&amp;</code>构造的类型实例的类型是类型的指针</p> <span id="more"></span><p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p><ul><li>字段拥有自己的类型和值</li><li>字段名必须唯一</li><li>字段的类型也可以是结构体，甚至是字段所在结构体的类型</li></ul><p><strong>关于 Go 语言的类(class)</strong></p><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p><p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的<strong>内嵌</strong>配合<strong>接口</strong>比面向对象具有更高的扩展性和灵活性。</p><p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法</p><h2 id="Go-语言结构体定义"><a href="#Go-语言结构体定义" class="headerlink" title="Go 语言结构体定义"></a>Go 语言结构体定义</h2><p>Go 语言的关键字<strong>type</strong> 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使用结构体更便于使用</p><p>结构体的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">    xx, yy <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言实例化结构体-结构体分配内存并初始化"><a href="#Go语言实例化结构体-结构体分配内存并初始化" class="headerlink" title="Go语言实例化结构体-结构体分配内存并初始化"></a>Go语言实例化结构体-结构体分配内存并初始化</h3><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。因此必须在定义结构体并实例化后才能使用结构体的字段</p><p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的</p><p>Go 语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p><h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整形、字符串等类型一样，以var 的方式声明结构体即可完成实例化</p><p>基本实例化格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ins T</span><br></pre></td></tr></table></figure><p>其中，T 为结构体类型，ins 为结构体的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p point</span><br><span class="line">p.x = <span class="number">10</span></span><br><span class="line">p.y = <span class="number">20</span></span><br><span class="line">fmt.Println(p) <span class="comment">// &#123;10 20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针类型的结构体"><a href="#指针类型的结构体" class="headerlink" title="指针类型的结构体"></a>指针类型的结构体</h3><p>Go 语言中，还可以使用 new 关键字对类型（包括结构体、整形。浮点数。字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体</p><p>使用new 的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 为类型，可以是结构体、整形、字符串等</li><li>ins ：T 类型被实例化后保存到ins 变量中，ins 的类型为 *T，属于指针</li></ul><p>Go 语言让我们可以像访问普通结构体一样使用<code>.</code>访问结构体指针的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">Name        <span class="keyword">string</span></span><br><span class="line">HealthPoint <span class="keyword">int</span></span><br><span class="line">MagicPoint  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">factory := <span class="built_in">new</span>(Player)</span><br><span class="line">factory.Name = <span class="string">&quot;鲁班&quot;</span></span><br><span class="line">factory.HealthPoint = <span class="number">300</span></span><br><span class="line">fmt.Println(factory) <span class="comment">// &amp;&#123;鲁班 300 0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p><blockquote><p>在 Go 语言中，访问结构体指针的成员变量时可以继续使用<code>.</code>。这是因为 Go 语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。</p></blockquote><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <strong>&amp;</strong> 取地址操作时，视为对该类型进行一次new 的实例化操作，取地址格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 表示结构体类型</li><li>ins 为结构体的实例，类型为 *<strong>T</strong> ，是指针类型</li></ul><p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等。对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span>    <span class="comment">// 指令名称</span></span><br><span class="line">    Var     *<span class="keyword">int</span>    <span class="comment">// 指令绑定的变量</span></span><br><span class="line">    Comment <span class="keyword">string</span>    <span class="comment">// 指令的注释</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">cmd := &amp;Command&#123;&#125;</span><br><span class="line">cmd.Name = <span class="string">&quot;version&quot;</span></span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = <span class="string">&quot;show version&quot;</span></span><br></pre></td></tr></table></figure><p>取地址实例化是最广泛的一种结构体实例化方式。可以使用函数封装上面的初始化过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCommand</span><span class="params">(name <span class="keyword">string</span>, varref *<span class="keyword">int</span>, comment <span class="keyword">string</span>)</span> *<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Command&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cmd = newCommand(</span><br><span class="line">    <span class="string">&quot;version&quot;</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">&quot;show version&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Go语言初始化结构体的成员变量"><a href="#Go语言初始化结构体的成员变量" class="headerlink" title="Go语言初始化结构体的成员变量"></a>Go语言初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化。初始化有两种形式：</p><ol><li>字段“键值对”形式</li><li>多个值的列表形式</li></ol><p>键值对形式的初始化适合选择性填充字段较多的结构体；</p><p>多个值的列表形式适合填充字段较少的结构体</p><h3 id="使用键值对初始化结构体"><a href="#使用键值对初始化结构体" class="headerlink" title="使用键值对初始化结构体"></a>使用键值对初始化结构体</h3><p>结构体可以使用<strong>键值对</strong>初始化字段，每个键对应结构体中的一个字段。键的值对应字段需要初始化的值,键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中</p><p>结构体实例化后字段的默认值是字段类型的默认值。例如：数值为 0，字符串为空字符串，布尔为 false，指针为 nil 等</p><h4 id="键值对初始化结构体格式"><a href="#键值对初始化结构体格式" class="headerlink" title="键值对初始化结构体格式"></a>键值对初始化结构体格式</h4><p>如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名&#123;</span><br><span class="line">    字段<span class="number">1</span>: 字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>：字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>结构体类型：定义结构体时的类型名称。</li><li>字段1、字段2：结构体的成员字段名。结构体类型名的字段初始化列表中，字段名只能出现一次。</li><li>字段1的值、字段2的值：结构体成员字段的初始值。</li></ul><blockquote><p>键值之间以<code>:</code>分隔；键值对之间以<code>,</code>分隔。</p></blockquote><h4 id="键值对初始化结构体的例子"><a href="#键值对初始化结构体的例子" class="headerlink" title="键值对初始化结构体的例子"></a>键值对初始化结构体的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    child *People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relation := &amp;People&#123;</span><br><span class="line">    name: <span class="string">&quot;爷爷&quot;</span>,</span><br><span class="line">    child: &amp;People&#123;</span><br><span class="line">        name: <span class="string">&quot;爸爸&quot;</span>,</span><br><span class="line">        child: &amp;People&#123;</span><br><span class="line">            name: <span class="string">&quot;孩子&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</p></blockquote><h3 id="使用多个值得列表初始化结构体"><a href="#使用多个值得列表初始化结构体" class="headerlink" title="使用多个值得列表初始化结构体"></a>使用多个值得列表初始化结构体</h3><p>Go 语言可以在键值对初始化的基础上忽略键，也就是说，可以使用多个值的列表初始化结构体的字段</p><h4 id="多个值列表初始化结构体的书写格式"><a href="#多个值列表初始化结构体的书写格式" class="headerlink" title="多个值列表初始化结构体的书写格式"></a>多个值列表初始化结构体的书写格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体名&#123;</span><br><span class="line">    字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ul><li>必须初始化结构体的所有字段</li><li>每一个初始值得填充顺序必须与结构体中的声明顺序一致</li><li>键值对与值列表的初始化形式不能混用</li></ul><h4 id="多个值列表初始化结构体的实例"><a href="#多个值列表初始化结构体的实例" class="headerlink" title="多个值列表初始化结构体的实例"></a>多个值列表初始化结构体的实例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province    <span class="keyword">string</span></span><br><span class="line">    City        <span class="keyword">string</span></span><br><span class="line">    ZipCode     <span class="keyword">int</span></span><br><span class="line">    PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">addr := Address&#123;</span><br><span class="line">    <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">    <span class="string">&quot;成都&quot;</span>,</span><br><span class="line">    <span class="number">610000</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(addr) <span class="comment">// &#123;四川 成都 610000 0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无需通过 <code>type </code>关键字定义就可以直接使用</p><h4 id="匿名结构体定义格式和初始化写法"><a href="#匿名结构体定义格式和初始化写法" class="headerlink" title="匿名结构体定义格式和初始化写法"></a>匿名结构体定义格式和初始化写法</h4><p>匿名结构体的初始化写法由<strong>结构体定义</strong>和<strong>键值对初始化</strong>两部分组成<br>结构体定义时没有结构体类型名，只有字段和字段类型的定义<br>键值对初始化部分由可选的多个键值对组成，如下格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>： 字段<span class="number">1</span>的值,</span><br><span class="line">    初始化字段<span class="number">2</span>： 字段<span class="number">2</span>的值,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用匿名结构体的例子"><a href="#使用匿名结构体的例子" class="headerlink" title="使用匿名结构体的例子"></a>使用匿名结构体的例子</h4><p>在本例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data）。打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 打印消息类型, 传入匿名结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsgType</span><span class="params">(msg *<span class="keyword">struct</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    id   <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用动词%T打印msg的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">    msg := &amp;<span class="keyword">struct</span> &#123;  <span class="comment">// 定义部分</span></span><br><span class="line">        id   <span class="keyword">int</span></span><br><span class="line">        data <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;  <span class="comment">// 值初始化部分</span></span><br><span class="line">        <span class="number">1024</span>,</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    printMsgType(msg) <span class="comment">// *struct &#123; id int; data string &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义 printMsgType() 函数，参数为 msg，类型为 *struct{id int data string}。因为类型没有使用 type 定义，所以需要在用到的地方每次进行定义。</li><li>第 11 行，使用字符串格式化中的<code>%T</code>动词，将 msg 的类型名打印出来。</li><li>第 15 行，对匿名结构体进行实例化，同时初始化成员。</li><li>第 16 和 17 行，定义匿名结构体的字段。</li><li>第 19 和 20 行，给匿名结构体字段赋予初始值。</li><li>第 22 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li></ul><blockquote><p>匿名结构体的类型名是结构体包含字段成员的详细描述。匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p></blockquote><h2 id="Go语言的构造函数"><a href="#Go语言的构造函数" class="headerlink" title="Go语言的构造函数"></a>Go语言的构造函数</h2><p>Go 语言的类型或结构体没有构造函数的功能，结构体的初始化过程可以使用函数封装实现</p><h3 id="TODO-没搞懂"><a href="#TODO-没搞懂" class="headerlink" title="TODO 没搞懂"></a>TODO 没搞懂</h3><h2 id="Go语言方法和接收器"><a href="#Go语言方法和接收器" class="headerlink" title="Go语言方法和接收器"></a>Go语言方法和接收器</h2><p>Go语言中的方法是一种作用于特定类型变量的函数。这种特定类型变量叫做<strong>接收器(Receiver)</strong></p><p>如果将特定类型理解为结构体或类时，接收器的概念就类似于其他语言中的 this 或者 self</p><p>在Go语言中，接收器的类型可以使任何类型，不仅仅是结构体，任何类型都可以拥有方法</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在 Go 语言中“方法”的概念与其他语言一致，只是 Go 语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</p><h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><h4 id="面向过程实现方法"><a href="#面向过程实现方法" class="headerlink" title="面向过程实现方法"></a>面向过程实现方法</h4><p>面向过程中没有方法 的概念，只能通过结构体和函数，有使用者使用函数参数和调用关系来形成接近方法的概念：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个物品放入背包的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(b *Bag, itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bag := <span class="built_in">new</span>(Bag)</span><br><span class="line">    Insert(bag, <span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert() 函数将 *Bag 参数放在第一位，强调 Insert 会操作 *Bag 结构体。但实际使用中，并不是每个人都会习惯将操作对象放在首位。一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念。随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p><h3 id="Go语言的结构体方法"><a href="#Go语言的结构体方法" class="headerlink" title="Go语言的结构体方法"></a>Go语言的结构体方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bag)</span> <span class="title">Insert</span><span class="params">(itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(Bag)</span><br><span class="line">    b.Insert(<span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法只能有一个接收器，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180815/1-1PQ5135I3337.jpg"></p><h3 id="接收器-方法作用的目标"><a href="#接收器-方法作用的目标" class="headerlink" title="接收器-方法作用的目标"></a>接收器-方法作用的目标</h3><p>接收器的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收器变量 接收器类型)</span> 方法名<span class="params">(参数列表)</span><span class="params">(返回参数)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各部分的说明：</p><ul><li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li><li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：格式与函数定义一致。</li></ul><p>接收器根据接收器的类型可以分为指针接收器、非指针接收器。两种接收器在使用时会产生不同的效果。根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p><h4 id="指针类型接收器"><a href="#指针类型接收器" class="headerlink" title="指针类型接收器"></a>指针类型接收器</h4><p>指针类型的接收器由一个结构体的指针组成，更接近与面向对象中的this 或者 self<br>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 定义属性结构</span></span><br><span class="line"><span class="keyword">type</span> Property <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span>  <span class="comment">// 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">SetValue</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改p的成员变量</span></span><br><span class="line">    p.value = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化属性</span></span><br><span class="line">    p := <span class="built_in">new</span>(Property)</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    p.SetValue(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 打印值</span></span><br><span class="line">    fmt.Println(p.Value()) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非指针类型接收器"><a href="#非指针类型接收器" class="headerlink" title="非指针类型接收器"></a>非指针类型接收器</h4><p>当方法作用于非指针接收器时，Go 语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义点结构</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非指针接收器的加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(other Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="comment">// 成员值与参数相加后返回新的结构</span></span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X + other.X, p.Y + other.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化点</span></span><br><span class="line">    p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// 与另外一个点相加</span></span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Println(result) <span class="comment">// &#123;3 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改</p><h4 id="指针和非指针接收器的使用"><a href="#指针和非指针接收器的使用" class="headerlink" title="指针和非指针接收器的使用"></a>指针和非指针接收器的使用</h4><p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器。大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p><h2 id="Go语言为任意类型添加方法"><a href="#Go语言为任意类型添加方法" class="headerlink" title="Go语言为任意类型添加方法"></a>Go语言为任意类型添加方法</h2><p>Go语言可以对任何类型添加方法。给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型</p><h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型。之后就可以为自定义类型添加各种方法。我们习惯于使用面向过程的方法判断一个值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 v 比作整型对象，那么判断 v 值就可以增加一个IsZero() 方法，通过这个方法就可以判断v 值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v.IsZero()&#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为基本类型添加方法的详细流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将int定义为MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 为MyInt添加IsZero()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为MyInt添加Add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">Add</span><span class="params">(other <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> other + <span class="keyword">int</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b MyInt = <span class="number">2</span></span><br><span class="line">    fmt.Println(b.IsZero()) <span class="comment">// false</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    fmt.Println(b.Add(<span class="number">2</span>)) <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言类型内嵌和结构体内嵌"><a href="#Go语言类型内嵌和结构体内嵌" class="headerlink" title="Go语言类型内嵌和结构体内嵌"></a>Go语言类型内嵌和结构体内嵌</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为<strong>类型内嵌</strong>或<strong>匿名字段类型内嵌</strong>，写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">ins := &amp;Data &#123;</span><br><span class="line">    <span class="keyword">int</span>: <span class="number">10</span>，</span><br><span class="line">    <span class="keyword">float32</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="keyword">bool</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型内嵌其实仍然拥有自己的字段名，只是字段名就是其类型本身而已，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个</p><p>结构体实例化后，如果匿名的字段类型为结构体，那么可以直接访问匿名结构体里的所有成员，这种方式被称为结<strong>构体内嵌</strong></p><h3 id="声明结构体内嵌"><a href="#声明结构体内嵌" class="headerlink" title="声明结构体内嵌"></a>声明结构体内嵌</h3><p>结构体类型内嵌比普通类型内嵌的概念复杂一些，下面通过一个实例来理解。</p><p>计算机图形学中的颜色有两种类型，一种是包含红、绿、蓝三原色的基础颜色；另一种是在基础颜色之外增加透明度的颜色。透明度在颜色中叫 Alpha，范围为 0～1 之间。0 表示完全透明，1 表示不透明。使用传统的结构体字段的方法定义基础颜色和带有透明度颜色的过程代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 基础颜色</span></span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 红、绿、蓝三种颜色分量</span></span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整颜色定义</span></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 将基本颜色作为成员</span></span><br><span class="line">    Basic BasicColor</span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    <span class="comment">// 设置基本颜色分量</span></span><br><span class="line">    c.Basic.R = <span class="number">1</span></span><br><span class="line">    c.Basic.G = <span class="number">1</span></span><br><span class="line">    c.Basic.B = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 设置透明度</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 显示整个结构体内容</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v&quot;</span>, c) <span class="comment">// &#123;Basic:&#123;R:1 G:1 B:0&#125; Alpha:1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然合理但是写法很复杂。使用 Go 语言的结构体内嵌写法重新调整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    BasicColor</span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    c.R = <span class="number">1</span></span><br><span class="line">    c.G = <span class="number">1</span></span><br><span class="line">    c.B = <span class="number">0</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第14-16 行，可以直接对 Color 的 R、G、B 成员进行设置，编译器通过 Color 的定义知道 R、G、B 成员来自 BasicColor 内嵌的结构体。</p><h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go 语言的结构体内嵌有如下特性：</p><p><strong>1. 内嵌的结构体可以直接访问其成员变量</strong></p><p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p><p><strong>2. 内嵌结构体的字段名是它的类型名</strong></p><p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Color</span><br><span class="line">c.BasicColor.R = <span class="number">1</span></span><br><span class="line">c.BasicColor.G = <span class="number">1</span></span><br><span class="line">c.BasicColor.B = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p><h2 id="Go语言结构体内嵌模拟类的继承"><a href="#Go语言结构体内嵌模拟类的继承" class="headerlink" title="Go语言结构体内嵌模拟类的继承"></a>Go语言结构体内嵌模拟类的继承</h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p><p>Go 语言 的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p><p>下面的代码使用 Go 语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p><p>人和鸟的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 可飞行的</span></span><br><span class="line"><span class="keyword">type</span> Flying <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Flying)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;can fly&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可行走的</span></span><br><span class="line"><span class="keyword">type</span> Walkable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Walkable)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;can calk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 人类能行走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 鸟类能行走</span></span><br><span class="line">    Flying   <span class="comment">// 鸟类能飞行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化鸟类</span></span><br><span class="line">    b := <span class="built_in">new</span>(Bird)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bird: &quot;</span>)</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line">    <span class="comment">// 实例化人类</span></span><br><span class="line">    h := <span class="built_in">new</span>(Human)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Human: &quot;</span>)</span><br><span class="line">    h.Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></table></figure><p>使用 Go 语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go 语言会在编译时检查能否使用这些特性。</p><h2 id="Go语言初始化内嵌结构体"><a href="#Go语言初始化内嵌结构体" class="headerlink" title="Go语言初始化内嵌结构体"></a>Go语言初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p><p>车辆结构的组装和初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引擎</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    Power <span class="keyword">int</span>    <span class="comment">// 功率</span></span><br><span class="line">    Type  <span class="keyword">string</span> <span class="comment">// 类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Car&#123;</span><br><span class="line">        <span class="comment">// 初始化轮子</span></span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: <span class="number">18</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 初始化引擎</span></span><br><span class="line">        Engine: Engine&#123;</span><br><span class="line">            Type:  <span class="string">&quot;1.4T&quot;</span>,</span><br><span class="line">            Power: <span class="number">143</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化内嵌匿名结构体</strong></p><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要<strong>再次声明结构</strong>才能赋予数据。具体请参考下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F; 车轮</span><br><span class="line">type Wheel struct &#123;</span><br><span class="line">    Size int</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 车</span><br><span class="line">type Car struct &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    &#x2F;&#x2F; 引擎</span><br><span class="line">    Engine struct &#123;</span><br><span class="line">        Power int    &#x2F;&#x2F; 功率</span><br><span class="line">        Type  string &#x2F;&#x2F; 类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    c :&#x3D; Car&#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化轮子</span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: 18,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 初始化引擎</span><br><span class="line">        Engine: struct &#123;</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        &#125;&#123;</span><br><span class="line">            Type:  &quot;1.4T&quot;,</span><br><span class="line">            Power: 143,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型&lt;br&gt;Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性&lt;/p&gt;
&lt;p&gt;Go 语言中的类型可以被实例化，使用&lt;code&gt;new&lt;/code&gt; 或&lt;code&gt;&amp;amp;&lt;/code&gt;构造的类型实例的类型是类型的指针&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记4-函数</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/</id>
    <published>2019-03-07T08:59:45.000Z</published>
    <updated>2021-03-23T10:07:44.810Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p><p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p> <span id="more"></span><p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul><li>函数本身可以作为值进行传递。</li><li>支持匿名函数和闭包（closure）。</li><li>函数可以满足接口。</li></ul><h2 id="Go语言函数声明-函数定义"><a href="#Go语言函数声明-函数定义" class="headerlink" title="Go语言函数声明(函数定义)"></a>Go语言函数声明(函数定义)</h2><p>普通函数需要先声明才能调用，一个函数的声明包含参数和函数名等，编译器通过声明才能了解函数应该怎样在调用代码和函数体之间传递参数和返回值</p><h3 id="普通函数的声明形式"><a href="#普通函数的声明形式" class="headerlink" title="普通函数的声明形式"></a>普通函数的声明形式</h3><p>Go语言的函数声明以<code>func </code>标识，后面紧接着函数名、参数列表、返回参数列表及函数体，具体形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对各个部分进行说明：</p><ul><li><p>函数名：由字母、数字、下划线组成。其中，函数名的第一个字母不能为数字，在同一个包内，函数名称不能重复</p><blockquote><p>包(package) 是Go源码的一种组织方式，一个包可以认为是一个文件夹</p></blockquote></li><li><p>参数列表：一个参数由参数变量和参数类型组成，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中，参数列表中的变量作为函数的局部变量而存在。</p></li><li><p>返回参数列表：可以是返回值类型列表，也可以是类似参数列表中变量名和类型名的组合。函数在声明有返回值时，必须在函数体中使用return 语句提供返回值列表</p></li><li><p>函数体：能够被重复调用的代码片段</p></li></ul><h3 id="参数类型的缩写"><a href="#参数类型的缩写" class="headerlink" title="参数类型的缩写"></a>参数类型的缩写</h3><p>在参数列表中，如果有多个参数变量，则以逗号<code>,</code>分隔；如果相邻变量时同类型，则可以将类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，a 和 b 的参数类型均是 int 类型，则可以省略 a 的类型，在 b 后面有类型说明，这个类型也是 a 的类型</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地取得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数中可能发生的错误。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToMysql()</span><br></pre></td></tr></table></figure><p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误。</p><p><strong>Go 语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</strong></p><h4 id="同一类型返回值"><a href="#同一类型返回值" class="headerlink" title="同一类型返回值"></a>同一类型返回值</h4><p>如果返回值是同一类型，则用括号将多个返回值类型括起来，用逗号分割每个返回值的类型</p><p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go 语言支持对返回值进行命名，这样返回值就可以和参数一样拥有参数变量名和类型</p><p>命名的返回值变量的默认值为类型的默认值，即数值为 0 ，字符串为空字符串，布尔值为false，指针为 nil 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p><p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p><p>Go语言的函数调用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>函数名：需要调用的函数名。</li><li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li><li>返回值变量列表：多个返回值使用逗号分隔。</li></ul><h3 id="函数示例-将秒转为具体时间"><a href="#函数示例-将秒转为具体时间" class="headerlink" title="函数示例-将秒转为具体时间"></a>函数示例-将秒转为具体时间</h3><p>在本例中，使用一个数值表示时间中的“秒”值，然后使用<code>resolveTime()</code>函数将传入的秒数转换为天、小时和分钟等时间单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SecondsPerMinute = <span class="number">60</span></span><br><span class="line"><span class="keyword">var</span> SecondsPerHour = <span class="number">60</span> * SecondsPerMinute</span><br><span class="line"><span class="keyword">var</span> SecondsPerDay = <span class="number">24</span> * SecondsPerHour</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(resolveTime(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">_, hour, minute := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">day, _, _ := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveTime</span><span class="params">(seconds <span class="keyword">int</span>)</span> <span class="params">(day, hour, minutes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">day = seconds / SecondsPerDay</span><br><span class="line">hour = seconds / SecondsPerHour</span><br><span class="line">minutes = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Go语言中传入参数和返回参数 在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用</p><h2 id="函数变量-把函数作为值保存到变量中"><a href="#函数变量-把函数作为值保存到变量中" class="headerlink" title="函数变量-把函数作为值保存到变量中"></a>函数变量-把函数作为值保存到变量中</h2><p>在Go语言中，函数也是一种类型，可以和其他类型一样被保存在变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    f = foo</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;foo func&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言匿名函数"><a href="#Go语言匿名函数" class="headerlink" title="Go语言匿名函数"></a>Go语言匿名函数</h2><p>Go 语言支持匿名函数，即在需要使用函数时在定义函数，匿名函数没有函数名，只有函数体，函数可以被作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式被传递</p><p>匿名函数经常被用于实现回调函数、闭包等</p><h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的定义就是没有名字的普通函数定义</p><h3 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h3><p>匿名函数可以在声明后调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Prinln(data) </span><br><span class="line">&#125;(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h3><p>匿名函数体可以被赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的用途非常广泛，匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p><h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现。用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line"></span><br><span class="line">    for _, v :&#x3D; range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数作为回调函数的设计在 Go 语言的系统包中也比较常见，strings 包中就有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string &#123;</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言函数类型实现接口"><a href="#Go语言函数类型实现接口" class="headerlink" title="Go语言函数类型实现接口"></a>Go语言函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将分别对比<strong>结构体</strong>与<strong>函数</strong>实现<code>接口</code>的过程。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h2 id="Go语言闭包"><a href="#Go语言闭包" class="headerlink" title="Go语言闭包"></a>Go语言闭包</h2><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此简单的说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></table></figure><p>一个函数类型就像结构体一样，可以被实例化。函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期静态的概念，而闭包是运行期动态的概念。</p><h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上的变量的引用可以进行修改，修改引用的变量就会对变量进行实际的修改。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">fmt.Println(str); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个累加器，初始值1</span></span><br><span class="line">value := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(value()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(value()) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span> , value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个累加器，初始值为1</span></span><br><span class="line">otherValue := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(otherValue()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>value 与 otherValue的函数地址不同，因此它们是两个不同的闭包实例</p></blockquote><p>闭包的记忆效应进程被用于实现类似于设计模式中工厂模式的生成器。</p><h2 id="Go语言可变参数-变参函数"><a href="#Go语言可变参数-变参函数" class="headerlink" title="Go语言可变参数(变参函数)"></a>Go语言可变参数(变参函数)</h2><p>所谓可变参数，是指参数数量不固定的函数形式。<br>Go语言支持可变参数特性，函数声明和调用时没有固定数量的参数，同时也提供了一套方法进行可变参数的多级传参</p><p>Go语音的可变参数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(固定参数列表，v ... T)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数一般被放置在函数列表的末尾，前面是固定参数列表，当没有固定参数时，所有变量将是可变参数</li><li>v 为可变参数变量，类型为<code>[]T</code>,也就是拥有多个T 元素的 T 类型的切片v 和 T 之前由<code>...</code>组成</li><li>T 为可变参数的类型，当T 为<code>interface&#123;&#125;</code>时，传入的可以使任意类型</li></ul><h3 id="fmt包中的例子"><a href="#fmt包中的例子" class="headerlink" title="fmt包中的例子"></a>fmt包中的例子</h3><p>可变参数有两种类型：所有参数都是可变参数的形式，如<code>fmt.Println</code>,以及部分是可变参数的形式，如 <code>fmt.Printf</code>，可变参数只能出现在参数的后半部分，因此不可变的参数只能放在参数的前半部分。</p><h4 id="所有参数都是可变参数：fmt-Println"><a href="#所有参数都是可变参数：fmt-Println" class="headerlink" title="所有参数都是可变参数：fmt.Println"></a>所有参数都是可变参数：fmt.Println</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Println</code> 在使用时，传入的值类型不收限制，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;string&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="部分参数是可变参数：-fmt-Printf"><a href="#部分参数是可变参数：-fmt-Printf" class="headerlink" title="部分参数是可变参数： fmt.Printf"></a>部分参数是可变参数： fmt.Printf</h4><p><code>fmt.Printf</code> 的第一个参数为参数列表， 后面的参数是可变参数，<code>fmt.Printf</code>函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Printf()</code> 函数在调用时，第一个函数始终必须传入字符串，对应参数是 format，后面的参数数量可以变化</p><h2 id="Go语音defer-延迟执行语句"><a href="#Go语音defer-延迟执行语句" class="headerlink" title="Go语音defer(延迟执行语句)"></a>Go语音defer(延迟执行语句)</h2><p>Go语音的defer 语句会将其后面跟随的语句进行延迟处理。<br>在defer 归属的函数即将返回时，将延迟处理的语句按defer 的逆序进行执行，也就是说，先被defer 的语句最后执行，最后defer 的语句，最后被执行</p><h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第二行&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;第三行&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;最后一行&quot;</span>)</span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 最后一行</span></span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure><ul><li>代码的延迟顺序与最终执行顺序是反向的</li><li>延迟调用是在 defer 所在函数结束时执行，函数结束可以是正常返回，也可以是出错时返回</li></ul><h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较繁琐的事情，比如打开和关闭文件、和解锁接受请求和回复请求、加锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p><p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理释放资源的问题</p><h4 id="使用-defer-延迟释放资源"><a href="#使用-defer-延迟释放资源" class="headerlink" title="使用 defer 延迟释放资源"></a>使用 defer 延迟释放资源</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟调用close ，此时close 不会被调用</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">info , err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">size := info.Size()</span><br><span class="line"><span class="comment">// defer 机制触发，调用close关闭文件</span></span><br><span class="line"><span class="keyword">return</span>  size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源</p></blockquote><h2 id="Go语言处理运行时错误"><a href="#Go语言处理运行时错误" class="headerlink" title="Go语言处理运行时错误"></a>Go语言处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p><ul><li><p>一个可能造成错误的函数，需要返回值中返回一个错误接口(error) 。如果调用是成功的，错误接口将返回<code>nil</code> , 否则返回错误</p></li><li><p>在函数调用后需要检查错误，如果发生错误，需要进行必要的错误处理</p></li></ul><p>Go 语言没有类似 Java或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做。Go 语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源。同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p><p>Go 语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数。同时，Go 语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p><h2 id="Go语言宕机-panic-，程序终止执行"><a href="#Go语言宕机-panic-，程序终止执行" class="headerlink" title="Go语言宕机(panic)，程序终止执行"></a>Go语言宕机(panic)，程序终止执行</h2><h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go 语言中可以在程序中手动触发宕机，让程序崩溃，这样使开发者可以及时的发现错误，同时减少可能的损失</p><p>Go 语言宕机时，会将堆栈和goroutine 信息输出到控制台，所以宕机也可以方便的知晓发生错误的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;crash&quot;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:4 +0x39</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>panic() 的参数可以是任意类型，后文将提到的 <code>recover</code> 参数会接收从 panic() 中发出的内容。</p><h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当<code>panic()</code> 触发的宕机发生时， <code>panic()</code> 后面的代码将不会被运行，但是在 <code>panic()</code> 函数前面已经运行的<code>defer</code>语句依然会在宕机时发生作用，例如下面的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;宕机后执行的事情1&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;crash&quot;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">宕机后执行的事情1</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:8 +0xf1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>宕机时，defer 语句会优先被执行</p><p><u><strong>测试了下，结果好像不一定，有时候先panic,有时候先defer，以后了解了再来补充吧</strong></u></p><h2 id="Go语言恢复-recover-宕机-防止程序崩溃"><a href="#Go语言恢复-recover-宕机-防止程序崩溃" class="headerlink" title="Go语言恢复(recover)宕机,防止程序崩溃"></a>Go语言恢复(recover)宕机,防止程序崩溃</h2><p>无论是代码运行错误，还是由<strong>Runtime</strong>层抛出的 panic 奔溃，还是主动出发的 panic 奔溃，都可以配合<strong>defer</strong> 和 <strong>recover</strong> 实现错误捕捉和恢复，让代码在发生奔溃后允许继续运行</p><p>在其他语言中，宕机往往以异常的形式存在。底层抛出异常，上层逻辑通过 <strong>try/catch</strong> 机制捕获异常，没有被捕获的严重异常会导致宕机，不活的异常可以被忽略，让代码继续运行</p><p>Go 语言没有异常系统，其使用 panic 触发宕机类似其他语言的抛出异常，那么 <strong>recover</strong>  的宕机恢复机制就是对应的 <strong>try/catch</strong> 机制</p><h3 id="让程序崩溃时继续执行"><a href="#让程序崩溃时继续执行" class="headerlink" title="让程序崩溃时继续执行"></a>让程序崩溃时继续执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> panicContext <span class="keyword">struct</span> &#123;</span><br><span class="line">function <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始运行&quot;</span>)</span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;手动宕机前-----&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>((&amp;panicContext&#123;</span><br><span class="line"><span class="string">&quot;手动触发panic&quot;</span>,</span><br><span class="line">&#125;))</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;手动宕机后&quot;</span>)</span><br><span class="line"></span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;赋值宕机前&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;赋值宕机后&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">&quot;结束宕机&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverDemo</span><span class="params">(entry <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 发生宕机时，获取panic传递的上下文并打印</span></span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> runtime.Error: <span class="comment">// 运行时错误</span></span><br><span class="line">fmt.Println(<span class="string">&quot;runtime error&quot;</span>, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">entry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始运行</span><br><span class="line">手动宕机前-----</span><br><span class="line">error &amp;&#123;手动触发panic&#125;</span><br><span class="line">手动宕机后</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">结束宕机</span><br></pre></td></tr></table></figure><h3 id="panic和recover的关系"><a href="#panic和recover的关系" class="headerlink" title="panic和recover的关系"></a>panic和recover的关系</h3><p>panic 和 defer 的组合有如下特性：</p><ul><li>有 panic 没 recover，程序宕机。</li><li>有 panic 也有 recover 捕获，程序不会宕机。执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li></ul><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>虽然 panic/recover 能模拟其他语言的异常机制，但并不建议代表编写普通函数也经常性使用这种特性。</p><p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛直到程序整体崩溃。</p><p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。&lt;/p&gt;
&lt;p&gt;Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记3-流程控制</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2019-03-07T06:54:49.000Z</published>
    <updated>2021-03-23T10:07:36.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p> Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else (分支结构)"></a>if else (分支结构)</h2><p>在Go语言中可以通过 if 关键字进行条件判断，格式如下：</p> <span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> Go 语言规定与 if 匹配的左括号<code>&#123;</code>必须与 if 和表达式放在同一行，如果尝试将<code>&#123;</code>放在其他位置，将会触发编译错误。</p></blockquote><h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>Go 语言规定与 if 匹配的左括号<code>&#123;</code>必须与 if 和表达式放在同一行，如果尝试将<code>&#123;</code>放在其他位置，将会触发编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connect 是一个带有返回值的函数，<code>err:=Connect()</code> 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p><p><code>err！=nil </code>才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Go语言中所有的循环类型均可以使用for 关键字来完成</p><p>基于语句和表达式的基本for 循环格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束表达式&#123;</span><br><span class="line">    循环体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环体不停地进行循环，直到条件表达式返回 false 时自动退出循环，执行 for 的<code>&#125;</code>之后的语句</p></blockquote><p>for 循环可以通过<code> break</code>、<code>goto</code>、<code>return</code>、<code>panic</code> 语句强制退出循环。for 的初始语句、条件表达式、结束语句的详细介绍如下。</p><h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其**<u>作用域</u>**将被局限在这个for 的范畴内</p><p>注意：初始语句可以被忽略，但是初始语句之后的分号必须填写，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; step &gt; <span class="number">0</span>; step-- &#123;</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p><h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>对每次循环开始前计算的表达式，如果表达式为true ,则循环继续，否则结束循环，条件表达式可以被忽略，被忽律条件的条件表达式默认形成无限循环</p><h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无线循环"><a href="#无线循环" class="headerlink" title="无线循环"></a>无线循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p><h3 id="Demo-九九乘法表"><a href="#Demo-九九乘法表" class="headerlink" title="Demo 九九乘法表"></a>Demo 九九乘法表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">1</span>; y &lt;= x; y++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d*%d=%d &quot;</span>, x, y, x*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1&#x3D;1 </span><br><span class="line">2*1&#x3D;2 2*2&#x3D;4 </span><br><span class="line">3*1&#x3D;3 3*2&#x3D;6 3*3&#x3D;9 </span><br><span class="line">4*1&#x3D;4 4*2&#x3D;8 4*3&#x3D;12 4*4&#x3D;16 </span><br><span class="line">5*1&#x3D;5 5*2&#x3D;10 5*3&#x3D;15 5*4&#x3D;20 5*5&#x3D;25 </span><br><span class="line">6*1&#x3D;6 6*2&#x3D;12 6*3&#x3D;18 6*4&#x3D;24 6*5&#x3D;30 6*6&#x3D;36 </span><br><span class="line">7*1&#x3D;7 7*2&#x3D;14 7*3&#x3D;21 7*4&#x3D;28 7*5&#x3D;35 7*6&#x3D;42 7*7&#x3D;49 </span><br><span class="line">8*1&#x3D;8 8*2&#x3D;16 8*3&#x3D;24 8*4&#x3D;32 8*5&#x3D;40 8*6&#x3D;48 8*7&#x3D;56 8*8&#x3D;64 </span><br><span class="line">9*1&#x3D;9 9*2&#x3D;18 9*3&#x3D;27 9*4&#x3D;36 9*5&#x3D;45 9*6&#x3D;54 9*7&#x3D;63 9*8&#x3D;72 9*9&#x3D;81 </span><br></pre></td></tr></table></figure><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>Go 语言可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong> 及<strong>通道（channel）</strong>。通过 <code>for range </code>遍历的返回值有一定的规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map 返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><h3 id="遍历数组、切片——获得索引和元素"><a href="#遍历数组、切片——获得索引和元素" class="headerlink" title="遍历数组、切片——获得索引和元素"></a>遍历数组、切片——获得索引和元素</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值。下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">fmt.Println(key, <span class="string">&quot;=&gt;&quot;</span>, value)</span><br><span class="line"><span class="comment">// 0 =&gt; 1</span></span><br><span class="line"><span class="comment">// 1 =&gt; 2</span></span><br><span class="line"><span class="comment">// 2 =&gt; 3</span></span><br><span class="line"><span class="comment">// 3 =&gt; 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历字符串——获得索引和元素"><a href="#遍历字符串——获得索引和元素" class="headerlink" title="遍历字符串——获得索引和元素"></a>遍历字符串——获得索引和元素</h3><p>Go 语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引（base0）和字符串中的每一个字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;你好，zhimma&quot;</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key:%d value:0x%x\n&quot;</span>, key, value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">key:0 value:0x4f60 type:int32</span></span><br><span class="line"><span class="comment">            key:3 value:0x597d type:int32</span></span><br><span class="line"><span class="comment">            key:6 value:0xff0c type:int32</span></span><br><span class="line"><span class="comment">            key:9 value:0x7a type:int32</span></span><br><span class="line"><span class="comment">            key:10 value:0x68 type:int32</span></span><br><span class="line"><span class="comment">            key:11 value:0x69 type:int32</span></span><br><span class="line"><span class="comment">            key:12 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:13 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:14 value:0x61 type:int32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 变量，实际类型是 rune，实际上就是 int32，以十六进制打印出来就是字符的编码。</p><h3 id="遍历map——获得map的键和值"><a href="#遍历map——获得map的键和值" class="headerlink" title="遍历map——获得map的键和值"></a>遍历map——获得map的键和值</h3><p>对于 map 类型来说，<code>for range</code> 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们总是一对一对的出现。下面的代码演示了如何遍历 map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;dad&quot;</span>:      <span class="string">&quot;zhimma dad&quot;</span>,</span><br><span class="line"><span class="string">&quot;mom&quot;</span>:      <span class="string">&quot;zhimma mom&quot;</span>,</span><br><span class="line"><span class="string">&quot;daughter&quot;</span>: <span class="string">&quot;zhimma&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> family &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>, key, value)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</p></blockquote><h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p><code>for range </code>可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h2><p>分支选择可以理解为一种批量的if语句，使用 switch 语句可方便地对大量的值进行判断。</p><p>在 Go 语言中的 switch，不仅可以基于常量进行判断，还可以基于表达式进行判断。</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go 语言改进了 switch 的语法设计，避免人为造成失误。Go 语言的 switch 中的每一个 case 与 case 间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;other&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，每个case 均是字符串格式，且使用了default 分支，Go语言规定每个 switch 只能有一个default 分支</p><h5 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h5><p>当出现多个 case 要放在一起的时候，可以像下面代码这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;mum&quot;</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;mum&quot;</span> , <span class="string">&quot;dad&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;family&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不通的 case 表达式使用逗号分隔</p></blockquote><h5 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h5><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num &lt; <span class="number">20</span> || num &gt; <span class="number">20</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;num value is &quot;</span>, num)</span><br><span class="line"><span class="comment">// num value is  10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况的 switch 后面不再跟判断变量，连判断的目标都没有了。</p></blockquote><h2 id="goto-语句——跳转到指定的标签"><a href="#goto-语句——跳转到指定的标签" class="headerlink" title="goto 语句——跳转到指定的标签"></a>goto 语句——跳转到指定的标签</h2><p>goto 语句通过标签进行代码间的无条件跳转。goto 语句可以在快速跳出循环、避免重复退出上有一定帮助，使用 goto 语句能简化一些代码的实现过程。</p><h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>多层循环中，传统方式退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breakAgain <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 外循环</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="comment">// 内循环</span></span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="comment">// 满足某个条件时, 退出循环</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 设置退出标记</span></span><br><span class="line">                breakAgain = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 退出本次循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记, 还需要退出一次循环</span></span><br><span class="line">        <span class="keyword">if</span> breakAgain &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 goto方式优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到标签</span></span><br><span class="line">                <span class="keyword">goto</span> breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动返回, 避免执行进入标签</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第13行 ：标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 16 行代码。</p><p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p><h3 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 goto 语句实现上面同样的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break (跳出循环)"></a>break (跳出循环)</h2><p>break 语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>代码块。break 语句还可以在语句后面添加标签，表示退出摸个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和<code>select</code>的代码块上</p><p>下面看下跳出指定循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">fmt.Println(i , j)</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 1 行，外层循环的标签。</li><li>第 2 行和第 3 行，双层循环。</li><li>第 5 行，使用 switch 进行数值分支判断。</li><li>第 8 和第 11 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 1 行。</li></ul><h2 id="continue-中断本次循环，继续下一次循环"><a href="#continue-中断本次循环，继续下一次循环" class="headerlink" title="continue(中断本次循环，继续下一次循环)"></a>continue(中断本次循环，继续下一次循环)</h2><p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用</p><p>在 continue 语句后添加标签时，表示开始标签对应的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OuterLoops:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">continue</span> OuterLoops</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>第 7 行将结束当前循环，开启下一次的外层循环，而不是第 3 行的循环。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。&lt;/p&gt;
&lt;p&gt; Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。&lt;/p&gt;
&lt;h2 id=&quot;if-else-分支结构&quot;&gt;&lt;a href=&quot;#if-else-分支结构&quot; class=&quot;headerlink&quot; title=&quot;if else (分支结构)&quot;&gt;&lt;/a&gt;if else (分支结构)&lt;/h2&gt;&lt;p&gt;在Go语言中可以通过 if 关键字进行条件判断，格式如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记2-容器</title>
    <link href="https://blog.zhimma.com/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/"/>
    <id>https://blog.zhimma.com/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/</id>
    <published>2019-03-06T06:13:39.000Z</published>
    <updated>2021-03-23T10:07:31.922Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p> <span id="more"></span><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array) 是一段固定长度的连续内存区域<br>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>Go 的数组和切片都是从C语言延续过来的设计。</p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>数组变量名：数组声明及使用时的变量名</li><li>元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整形数值</li><li>T 可以是任意基本类型，包括 T 为数组本身。但类型为数组本身时，可以实现多维数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>] <span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">&quot;JD&quot;</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">&quot;TaoBao&quot;</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">&quot;Wechat&quot;</span></span><br><span class="line">fmt.Println(team) <span class="comment">// [JD TaoBao Wechat]</span></span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组可以在声明时使用初始化列表进行元素设置，参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;JD&quot;</span>, <span class="string">&quot;TaoBao&quot;</span>, <span class="string">&quot;Wechat&quot;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式编写时，需要保证大括号后面的元素数量与数组的大小一致</p></blockquote><p>但一般情况下，这个过程可以交给编译器，让编译器在编译时，根据元素个数确定数组大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;JD&quot;</span> , <span class="string">&quot;TaoBao&quot;</span> , <span class="string">&quot;Wechat&quot;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>...</code>表示让编译器确定数组大小。上面例子中，编译器会自动为这个数组设置元素个数为 3</p></blockquote><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组也和遍历切片类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;JD&quot;</span>, <span class="string">&quot;TaoBao&quot;</span>, <span class="string">&quot;Wechat&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> team &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0 JD</span></span><br><span class="line"><span class="comment">1 TaoBao</span></span><br><span class="line"><span class="comment">2 Wechat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个拥有相同类型元素的<strong>可变</strong>长度的序列，Go语言切片的内部包含<strong>地址</strong>、<strong>大小</strong>、<strong>容量</strong>，切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始(这个就是切片的地址)及切多大(这个就是切片的大小)。容量可以理解为装切片的口袋大小</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3154340Y9.jpg"></p><h3 id="生成切片-从数组或切片生成新的切片"><a href="#生成切片-从数组或切片生成新的切片" class="headerlink" title="生成切片(从数组或切片生成新的切片)"></a>生成切片(从数组或切片生成新的切片)</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身</p><p>从连续内存区域生成切片是常见的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice[开始位置:结束位置]</span><br></pre></td></tr></table></figure><ul><li>slice表示目标切片对象</li><li>开始位置对应目标切片对象的索引</li><li>结束位置对应目标切片的结束索引</li></ul><h4 id="从数组生成切片："><a href="#从数组生成切片：" class="headerlink" title="从数组生成切片："></a>从数组生成切片：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr , arr[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">// [1 2 3] [2]</span></span><br></pre></td></tr></table></figure><p><code>[2]</code>就是<code>arr[1:2]</code>切片操作的结果</p><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置-开始位置。</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。</li><li>当缺省开始位置时，表示从连续区域开头到结束位置。</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾。</li><li>两者同时缺省时，与数组本身等效。</li><li>两者同时为0时，等效于空切片，一般用于切片复位。</li></ul><p>根据索引位置取切片 slice 元素值时，取值范围是<strong>（0～len(slice)-1）</strong>，超界会报运行时错误</p><p>生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>具体，下面使用一些实例演示：</p><h5 id="指定范围生成切片"><a href="#指定范围生成切片" class="headerlink" title="指定范围生成切片"></a>指定范围生成切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个array</span></span><br><span class="line">build := [<span class="number">30</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++ &#123;</span><br><span class="line">build[i] = i +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间取值</span></span><br><span class="line">fmt.Println(build[<span class="number">10</span>:<span class="number">15</span>]) <span class="comment">// [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">// 中间部分到结尾所有元素</span></span><br><span class="line">fmt.Println(build[<span class="number">20</span>:]) <span class="comment">// [21 22 23 24 25 26 27 28 29 30]</span></span><br><span class="line"><span class="comment">// 开始到中间所有元素</span></span><br><span class="line">fmt.Println(build[:<span class="number">8</span>]) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p><h5 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h5><p>生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[:]) <span class="comment">// [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重置切片，清空所有元素"><a href="#重置切片，清空所有元素" class="headerlink" title="重置切片，清空所有元素"></a>重置切片，清空所有元素</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[<span class="number">0</span>:<span class="number">0</span>]) <span class="comment">// []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明新的切片"><a href="#声明新的切片" class="headerlink" title="声明新的切片"></a>声明新的切片</h4><p>除了可以从原有的数组或者切片中生成切片，你也可以声明一个新的切片<br>每一种类型都可以拥有其切片类型，表示多个类型元素的连续集合。因此切片类型也可以被声明。切片类型声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><ul><li>Name 表示切片的变量名</li><li>T 表示切片对应的元素类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明字符串切片</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 声明整形切片</span></span><br><span class="line"><span class="keyword">var</span> intSlice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 声明一个空切片</span></span><br><span class="line"><span class="keyword">var</span> emptySlice = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strSlice, intSlice, emptySlice) <span class="comment">// [] [] []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出3个切片大小</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(strSlice), <span class="built_in">len</span>(intSlice), <span class="built_in">len</span>(emptySlice)) <span class="comment">// 0 0 0</span></span><br><span class="line"><span class="comment">// 切片判定空的结果</span></span><br><span class="line">fmt.Println(strSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(intSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>) <span class="comment">// true true false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是动态结构，只能与nil判定相等，不能互相判等时。</p><p>声明新的切片后，可以使用<code> append()</code>函数来添加元素。</p><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><p>如果需要动态的创建一个切片，可以使用make()内建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,size,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><ul><li>T : 切片的元素类型</li><li>size : 就是为这个类型分配多少个元素</li><li>cap : 预分配元素数量，这个值设定不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题。</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b) <span class="comment">// [0 0] [0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)) <span class="comment">// 2 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">cap</span>(b)) <span class="comment">// 2 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。<br>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p></blockquote><p>使用 make() 函数生成的切片一定发生了内存分配操作。但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p><p>切片不一定必须经过 make() 函数才能使用。生成切片、声明后使用 append() 函数均可以正常使用切片</p><h3 id="使用append-为切片添加元素"><a href="#使用append-为切片添加元素" class="headerlink" title="使用append()为切片添加元素"></a>使用append()为切片添加元素</h3><ul><li>Go语言的内建函数 append() 可以为切片动态添加元素</li><li>每个切片会指向一片内存空间，这片空间能容纳一定数量的元素</li><li>当空间不能容纳足够多的元素时，切片就会进行“扩容”。“扩容”操作往往发生在 append() 函数调用时</li><li>切片在扩容时，容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len: %d,cap: %d,pointer: %p\n&quot;</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line"><span class="comment">// len : 1,cap:1,pointer:0xc000014080</span></span><br><span class="line"><span class="comment">// len : 2,cap:2,pointer:0xc0000140b0</span></span><br><span class="line"><span class="comment">// len : 3,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 4,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 5,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 6,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 7,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 8,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 9,cap:16,pointer:0xc00008a000</span></span><br><span class="line"><span class="comment">// len : 10,cap:16,pointer:0xc00008a000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append() 函数除了添加一个元素外，也可以一次性添加很多元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> company []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加一个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">&quot;JD&quot;</span>)</span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">&quot;taobao&quot;</span> , <span class="string">&quot;t.tt&quot;</span>)</span><br><span class="line"><span class="comment">// 添加切片</span></span><br><span class="line">newCompany := []<span class="keyword">string</span>&#123;<span class="string">&quot;mi&quot;</span> , <span class="string">&quot;坚果&quot;</span>&#125;</span><br><span class="line">company = <span class="built_in">append</span>(company , newCompany...)</span><br><span class="line"></span><br><span class="line">fmt.Println(company) <span class="comment">// [JD taobao t.tt mi 坚果]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>第 13 行，在newCompany后面加上了<code>...</code>，表示将 newCompany 整个添加到 car 的后面。</p></blockquote><h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>使用内建的 copy() 函数，可以迅速地将一个切片的数据复制到另外一个切片空间中，copy() 函数的使用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(originSlice,srcSlice []T)<span class="keyword">int</span></span><br></pre></td></tr></table></figure><ul><li>originSlice 为数据来源切片</li><li>srcSlice为复制的目标。目标切片必须分配过空间且足够承载复制的元素个数，来源和目标的类型一致，copy 的返回值表示实际发生复制的元素个数。</li></ul><h3 id="删除切片元素"><a href="#删除切片元素" class="headerlink" title="删除切片元素"></a>删除切片元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq := []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 指定删除位置       </span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line"><span class="comment">// 查看删除位置之前的元素和之后的元素</span></span><br><span class="line">fmt.Println(seq[:index], seq[index+<span class="number">1</span>:])<span class="comment">// [a b] [d e]</span></span><br><span class="line"><span class="comment">// 将删除点前后的元素连接起来 </span></span><br><span class="line">seq = <span class="built_in">append</span>(seq[:index], seq[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(seq) <span class="comment">// [a b d e]</span></span><br></pre></td></tr></table></figure><p>代码的删除过程可以使用下图来描述。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3164544530.jpg"></p><p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p><blockquote><p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。</p></blockquote><h2 id="map-Go语言映射"><a href="#map-Go语言映射" class="headerlink" title="map(Go语言映射)"></a>map(Go语言映射)</h2><p>在业务和算法中需要使用任意类型的关联关系时，就需要使用到映射，如学号和学生的对应、名字与档案的对应等。</p><p>Go语言提供的映射关系容器为 map，map使用散列表（hash）实现。</p><h3 id="添加数据到map"><a href="#添加数据到map" class="headerlink" title="添加数据到map"></a>添加数据到map</h3><p>Go语言中 map 的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]vluesType</span><br></pre></td></tr></table></figure><ul><li>keyTyp 表示键类型</li><li>valueType 表示键对应值类型</li></ul><p>一个map 里，符合keyType和valueType 的映射总是成对出现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scene := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//  这里的map是内部实现的类型</span></span><br><span class="line">scene[<span class="string">&quot;route&quot;</span>] = <span class="number">666</span></span><br><span class="line">fmt.Println(scene[<span class="string">&quot;route&quot;</span>]) <span class="comment">// 666</span></span><br><span class="line"></span><br><span class="line">v := scene[<span class="string">&quot;route2&quot;</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>尝试查找一个不存在的键，那么返回的将是 ValueType 的默认值</p></blockquote><p>某些情况下，需要明确知道查询中某个键是否在 map 中存在，可以使用一种特殊的写法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := scene[<span class="string">&quot;route&quot;</span>]</span><br></pre></td></tr></table></figure><p>在默认获取键值的基础上，多取了一个变量 ok，可以判断键 route 是否存在于 map 中。</p><p>map 还可以在声明时填充内容，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;W&quot;</span> : <span class="string">&quot;forward&quot;</span>,</span><br><span class="line"><span class="string">&quot;A&quot;</span>: <span class="string">&quot;left&quot;</span>,</span><br><span class="line"><span class="string">&quot;D&quot;</span>: <span class="string">&quot;right&quot;</span>,</span><br><span class="line"><span class="string">&quot;S&quot;</span>: <span class="string">&quot;backward&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[W:forward A:left D:right S:backward]</span></span><br></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><h4 id="遍历key-和-value"><a href="#遍历key-和-value" class="headerlink" title="遍历key 和 value"></a>遍历key 和 value</h4><p>map 的遍历过程使用 <code>for range</code>循环完成，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;dad&quot;</span>:      <span class="string">&quot;zhimma dad&quot;</span>,</span><br><span class="line"><span class="string">&quot;mom&quot;</span>:      <span class="string">&quot;zhimma mom&quot;</span>,</span><br><span class="line"><span class="string">&quot;daughter&quot;</span>: <span class="string">&quot;zhimma&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span>  family&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span> , key ,value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><p>遍历时，可以同时获得键和值。如只遍历值，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>将不需要的键改为匿名变量形式。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><p>只遍历键时，使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>无须将值改为匿名变量形式，忽略值即可</p><h3 id="map-元素删除和清空"><a href="#map-元素删除和清空" class="headerlink" title="map 元素删除和清空"></a>map 元素删除和清空</h3><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对 ，<code>delete()</code>函数的格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span> , 键)</span><br></pre></td></tr></table></figure><ul><li>map 为要删除的map实例</li><li>键为要删除的 map 键值对中的键</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">numMap :&#x3D; make(map[string]int)</span><br><span class="line"></span><br><span class="line">numMap[&quot;aroute&quot;] &#x3D; 66</span><br><span class="line">numMap[&quot;brazil&quot;] &#x3D; 4</span><br><span class="line">numMap[&quot;china&quot;] &#x3D; 960</span><br><span class="line">delete(numMap , &quot;brazil&quot;)</span><br><span class="line">for k, v :&#x3D; range numMap &#123;</span><br><span class="line">fmt.Println(k , v)</span><br><span class="line">&#x2F;**</span><br><span class="line">aroute 66</span><br><span class="line">china 960</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h4><p>有意思的是,Go语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是<strong>重新 make 一个新的 map</strong>。不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数高效多了。</p><h2 id="sync-Map-在并发环境中使用的map"><a href="#sync-Map-在并发环境中使用的map" class="headerlink" title="sync.Map(在并发环境中使用的map)"></a>sync.Map(在并发环境中使用的map)</h2><p>Go 语言中的 map 在并发情况下，只读是线程安全的，同时读写线程不安全。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个int到int的映射</span></span><br><span class="line">n := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 不停地对map进行写入</span></span><br><span class="line">n[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = n[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码会报错，输出如下：<br><code>fatal error: concurrent map read and map write</code></p><p>运行时输出提示：并发的 map 读写。也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题。map 内部会对这种并发操作进行检查并提前发现</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高。Go 语言在 1.9 版本中提供了一种效率较高的并发安全的 <code>sync.Map</code>。<code>sync.Map</code> 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p><code>sync.Map</code>有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。Range 参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scenes sync.Map</span><br><span class="line"><span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">scenes.Store(<span class="string">&quot;greece&quot;</span>, <span class="number">97</span>)</span><br><span class="line">scenes.Store(<span class="string">&quot;london&quot;</span>, <span class="number">100</span>)</span><br><span class="line">scenes.Store(<span class="string">&quot;egypt&quot;</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">fmt.Println(scenes.Load(<span class="string">&quot;london&quot;</span>))</span><br><span class="line"><span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">scenes.Delete(<span class="string">&quot;london&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">scenes.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line"><span class="comment">// iterate: greece 97</span></span><br><span class="line"><span class="comment">//i terate: egypt 200</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>sync.Map 没有提供获取 map 数量的方法，替代方法是获取时遍历自行计算数量。sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之前的关系。列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示：</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31I54a30.jpg"></p><p>如果在这个基础上，再从 C 开始将自己的号码给自己知道号码的人，这样就形成了双链表结构，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31IJRI.jpg"></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环。这个过程就是列表遍历。<br>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除。这个过程就是列表元素的删除操作，如下图所示</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31J0524T.jpg"></p><p>在Go语言中，将列表使用 container/list 包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><code>list</code> 的初始化有两种方法：New 和声明。两种方法的初始化效果都是一致的。</p><h4 id="通过container-list-包的-New-方法初始化-list"><a href="#通过container-list-包的-New-方法初始化-list" class="headerlink" title="通过container/list 包的 New 方法初始化 list"></a>通过container/list 包的 New 方法初始化 list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure><h4 id="通过声明初始化list"><a href="#通过声明初始化list" class="headerlink" title="通过声明初始化list"></a>通过声明初始化list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure><p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制。因此，列表的元素可以是任意类型。这既带来便利，也会引来一些问题。给一个列表放入了非期望类型的值，在取出值后，将 interface{} 转换为期望类型时将会发生宕机。</p><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 <code>PushFront </code>和 <code>PushBack</code>。</p><p>这两个方法都会返回一个 <code>*list.Element</code> 结构。如果在以后的使用中需要删除插入的元素，则只能通过 <code>*list.Element</code> 配合<code>Remove()</code>方法进行删除，这种方法可以让删除更加效率化，也是双链表特性之一</p><p>下面代码展示给list添加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">l.PushFront(<span class="string">&quot;18+&quot;</span>)</span><br></pre></td></tr></table></figure><p>列表插入元素的方法如下表所示。</p><table><thead><tr><th>方  法</th><th>功  能</th></tr></thead><tbody><tr><td>InsertAfter(v interface {}, mark * Element) * Element</td><td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td></tr><tr><td>InsertBefore(v interface {}, mark * Element) *Element</td><td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td></tr><tr><td>PushBackList(other *List)</td><td>添加 other 列表元素到尾部</td></tr><tr><td>PushFrontList(other *List)</td><td>添加 other 列表元素到头部</td></tr></tbody></table><h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表的插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值及和其他节点之间的关系等信息。从列表中删除元素时，需要用到这个结构进行快速删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入age</span></span><br><span class="line">l.PushBack(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="comment">// 头部插入18+</span></span><br><span class="line">l.PushFront(<span class="string">&quot;18+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">element := l.PushBack(<span class="string">&quot;fist&quot;</span>)</span><br><span class="line"><span class="comment">// 在fist之后添加high</span></span><br><span class="line">l.InsertAfter(<span class="string">&quot;high&quot;</span>, element)</span><br><span class="line"><span class="comment">// 在fist之前添加noon</span></span><br><span class="line">l.InsertBefore(<span class="string">&quot;noon&quot;</span>, element)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">l.Remove(element)</span><br></pre></td></tr></table></figure><p>下表中展示了每次操作后列表的实际元素情况。</p><table><thead><tr><th>操作内容</th><th>列表元素</th></tr></thead><tbody><tr><td>l.PushBack(“age”)</td><td>age</td></tr><tr><td>l.PushFront(“18+”)</td><td>18+, age</td></tr><tr><td>element := l.PushBack(“fist”)</td><td>18+, age, fist</td></tr><tr><td>l.InsertAfter(“high”, element)</td><td>18+, age, fist, high</td></tr><tr><td>l.InsertBefore(“noon”, element)</td><td>18+, age, noon, fist, high</td></tr><tr><td>l.Remove(element)</td><td>18+, age, noon, high</td></tr></tbody></table><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>遍历双链表需要配合 <code>Front()</code>函数获取头元素，遍历时只要元素不为空就可以继续进行。每一次遍历调用元素的 <code>Next</code>，如代码中第 6 行所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">&quot;canon&quot;</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">    <span class="comment">// 67</span></span><br><span class="line">    <span class="comment">// canon</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次；每次循环会进行一次 i!=nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i=i.Next()。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记1-基本语法</title>
    <link href="https://blog.zhimma.com/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://blog.zhimma.com/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2019-03-05T08:48:28.000Z</published>
    <updated>2021-03-23T10:07:26.377Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="变量声明-使用var关键字"><a href="#变量声明-使用var关键字" class="headerlink" title="变量声明(使用var关键字)"></a>变量声明(使用var关键字)</h2><blockquote><p>变量（Variable）的功能是存储用户的数据,不同的逻辑有不同的对象类型，也就有不同的变量类型</p></blockquote><p>Go语言使用<strong>var</strong>关键字进行变量的声明</p> <span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">struct</span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行，声明一个整形类型的变量，用来保存整数数值</li><li>第二行，声明一个字符串类型的变量</li><li>第三行，声明一个32位浮点切片类型的变量，浮点切片表示由多个浮点类型组成的数据结构</li><li>第四行，声明一个返回值为bool类型的函数变量，这种形式一般用于回调函数，即将函数以变量的形式保存下来，在需要的时候重新调用这个函数</li><li>声明一个结构体类型的变量，这个结构体拥有一个整形的x字段</li></ul><h3 id="标准格式声明"><a href="#标准格式声明" class="headerlink" title="标准格式声明"></a>标准格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量的声明是以var关键字开头，要声明的变量名放中间，将其类型放在后面，行尾无需分号</p><h3 id="批量格式声明"><a href="#批量格式声明" class="headerlink" title="批量格式声明"></a>批量格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c []<span class="keyword">float32</span></span><br><span class="line">d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用var和括号，可以将一组变量定义放在一起</p><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p><ul><li>整型和浮点型变量的默认值为 0</li><li>字符串变量的默认值为空字符串</li><li>布尔型变量默认为 bool</li><li>切片、函数、指针变量的默认为 nil</li></ul><p>在声明变量的时候也可以进行赋初始值</p><h3 id="变量初始化标准格式"><a href="#变量初始化标准格式" class="headerlink" title="变量初始化标准格式"></a>变量初始化标准格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">&quot;zhimma&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编译器推导类型"><a href="#编译器推导类型" class="headerlink" title="编译器推导类型"></a>编译器推导类型</h3><p>在标准格式的基础上，可以省略部分变量类型，编译器会尝试根据等号右边的表达式推导变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhimma&quot;</span></span><br></pre></td></tr></table></figure><p>等号右边的部分在编译原理里被称做右值（rvalue）</p><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p>var 的变量声明还有一种精简写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;zhimma&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p> 左值变量必须是没有定义过的变量</p></blockquote><p>在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><p>多重赋值时，变量的左值和右值按从左到右的顺序赋值<br>多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。</p><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在使用多重赋值时，如果不需要在左值中接收变量，可以使用匿名变量（anonymous variable）</p><p>匿名变量的表现是一个下划线<code>_</code>,使用匿名变量时，只需要在变量声明的地方使用下画线替换即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line">fmt.Println(a, b)<span class="comment">// 100 200</span></span><br></pre></td></tr></table></figure><p><strong>匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</strong></p><p>匿名变量：</p><ul><li>可以理解为一种占位符。</li><li>本身这种变量不会进行空间分配，也不会占用一个变量的名字。</li><li>在<code> for range</code> 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li></ul><h2 id="Go语言类型"><a href="#Go语言类型" class="headerlink" title="Go语言类型"></a>Go语言类型</h2><p>Go语言 中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异，切片类型有着指针的便利性，但比指针更为安全，很多高级语言都配有切片进行安全和高效率的内存操作。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整型分为以下两个大类：</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>还有对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。</p><h3 id="浮点类型（小数类型）"><a href="#浮点类型（小数类型）" class="headerlink" title="浮点类型（小数类型）"></a>浮点类型（小数类型）</h3><p>Go语言</p><p>支持两种浮点型数：float32 和 float64。这两种浮点型数据格式遵循 IEEE 754 标准：</p><ul><li>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。</li><li>float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</li></ul><p>打印浮点数时，可以使用 fmt 包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi) <span class="comment">//按默认宽度和精度输出整型</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi)<span class="comment">//按默认宽度，2 位精度输出（小数点后的位数）。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.141593</span></span><br><span class="line"><span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>布尔型数据只有 true（真）和 false（假）两个值，布尔型无法参与数值运算，也无法与其他类型进行转换</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在Go语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。</p><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转移符</th><th>含  义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr></tbody></table><h4 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h4><p>在源码中，将字符串的值以双引号书写的方式是字符串的常见表达方式，被称为字符串字面量（string literal）<br>这种双引号字面量不能跨行。如果需要在源码中嵌入一个多行字符串时，就必须使用**`**字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><blockquote><p>在**`**间的所有代码均不会被编译器识别，而只是作为字符串的一部分</p></blockquote><h3 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h3><p>字符串中的每一个元素叫做<strong>“字符”</strong>，在遍历或者单个获取字符串元素时可以获得字符</p><p>Go语言的字符有以下两种：</p><ol><li><strong>uint8</strong>类型，也叫<strong>byte</strong>型，代表了<strong>ASCLL</strong>码中的一个字符</li><li><strong>rune</strong>类型，代表一个<strong>UTF-8</strong>字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32。</li></ol><p>使用<code>fmt.Printf</code>中的<code>%T</code>动词可以输出、变量的实际类型，使用这个方法可以查看 byte 和 rune 的本来类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %T\n&quot;</span>, a, a) <span class="comment">// 97 uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">rune</span> = <span class="string">&#x27;你&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %T\n&quot;</span>, b, b) <span class="comment">// 20320 int32</span></span><br></pre></td></tr></table></figure><blockquote><p>可以发现，byte 类型的 a 变量，实际类型是 uint8，其值为 ‘a’，对应的 ASCII 编码为 97<br>rune 类型的 b 变量的实际类型是 int32，对应的 Unicode 码就是 20320<br>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p></blockquote><h2 id="Go数据类型转换"><a href="#Go数据类型转换" class="headerlink" title="Go数据类型转换"></a>Go数据类型转换</h2><p>Go语言使用类型前置加括号的方式进行数据类型转换，一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><blockquote><p>T代表要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><p>类型转换时，需要考虑两种类型的关系和范围，是否会发生数值截断等</p></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，例如圆周率。<br>可以在编译时，对常量表达式进行计算求值，并在运行期使用该计算结果，计算结果无法被修改。常量表示起来非常简单，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">4.14159</span></span><br></pre></td></tr></table></figure><p>常量的声明和变量声明非常类似，只是把 var 换成了 const。</p><p>多个变量可以一起声明，类似的，常量也是可以多个一起声明的，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.141592</span></span><br><span class="line">    e = <span class="number">2.718281</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量因为在编译期确定，所以可以用于数组声明，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> arr [size]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="模拟枚举-const和iota模拟枚举"><a href="#模拟枚举-const和iota模拟枚举" class="headerlink" title="模拟枚举(const和iota模拟枚举)"></a>模拟枚举(const和iota模拟枚举)</h2><p>Go语言现阶段没有枚举，可以使用 const 常量配合 iota 模拟枚举，请看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weapon <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower) <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="comment">// 使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>枚举类型其实本质是一个 int 一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。</p><h2 id="Go语言type关键字-类型别名"><a href="#Go语言type关键字-类型别名" class="headerlink" title="Go语言type关键字(类型别名)"></a>Go语言type关键字(类型别名)</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名的写法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias &#x3D; int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a NewInt</span><br><span class="line">fmt.Printf(&quot;a type : %T\n&quot;, a) &#x2F;&#x2F; a type : main.NewInt</span><br><span class="line"></span><br><span class="line">var b IntAlias</span><br><span class="line">fmt.Printf(&quot;b type %T\n&quot;, b) &#x2F;&#x2F; b type int</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 8 行，将 NewInt 定义为 int 类型，这是常见定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</li><li>第 11 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。</li><li>第 15 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。</li><li>第 16 行，使用<code>%T</code>格式化参数，显示 a 变量本身的类型。</li><li>第 18 行，将 b 声明为 IntAlias 类型，此时打印 b 的值为 0。</li><li>第 19 行，显示 b 变量的类型。</li></ul><p>结果显示a的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型。b 类型是 int。IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。</p><h2 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h2><p>指针（pointer）概念在Go语言中被拆分为两个核心概念：</p><ol><li>类型指针，运行对这个指针类型的数据进行修改，传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算</li><li>切片，由指向起始元素的原始指针、元素数量和容量组成</li></ol><p>受益于这样的约束和拆分，Go 语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p>要明白指针，需要知道几个概念：<strong>指针地址</strong>、<strong>指针类型</strong>和<strong>指针取值</strong>，下面将展开细说。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置</p><p>Go 语言中使用<code>&amp;</code>作符放在变量前面对变量进行“取地址”操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中v代表被取地址的变量，被取地址的v使用ptr变量进行接收，ptr的类型就为<code>*T</code>,称做 T 的指针类型，<code>*</code>代表指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cat <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;banana&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p %p&quot;</span>, &amp;cat, &amp;str) <span class="comment">// 0xc042052088 0xc0420461b0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>第 8 行，声明整型 cat 变量。</li><li>第 9 行，声明字符串 str 变量。</li><li>第 10 行，使用 fmt.Printf 的动词<code>%p</code>输出 cat 和 str 变量取地址后的指针值，指针值带有<code>0x</code>的十六进制前缀。</li></ul><p>输出值在每次运行是不同的，代表 cat 和 str 两个变量在运行时的地址。</p><p><strong>提示：变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址</strong></p><h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用<code>&amp;</code>操作符获取地址获得这个变量的指针后，可以对指针使用<code>*</code>操作，也就是指针取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 声明一个字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">&quot;陕西西安&quot;</span></span><br><span class="line"><span class="comment">// 对字符串取地址，ptr类型为*string</span></span><br><span class="line">ptr := &amp;house</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出ptr类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ptr type: %T\n&quot;</span> , ptr) <span class="comment">// ptr type: *string</span></span><br><span class="line"><span class="comment">// 输出ptr指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;address: %p\n&quot;</span> , ptr) <span class="comment">// address: 0xc00000e1e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针进行取值操作</span></span><br><span class="line">value := *ptr</span><br><span class="line"><span class="comment">// 取值后类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value type: %T\n&quot;</span> , value) <span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// 指针去之后就是指向变量的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value: %s\n&quot;</span> , value) <span class="comment">//value: 陕西西安</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</strong></p><h3 id="变量、指针地址、指针变量、取地址、取值的相互关系和特性"><a href="#变量、指针地址、指针变量、取地址、取值的相互关系和特性" class="headerlink" title="变量、指针地址、指针变量、取地址、取值的相互关系和特性"></a>变量、指针地址、指针变量、取地址、取值的相互关系和特性</h3><p>如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 交换变量值</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line"><span class="comment">// 输出变量值</span></span><br><span class="line">fmt.Println(x, y) <span class="comment">// 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">t := *a</span><br><span class="line"><span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">*a = *b</span><br><span class="line"><span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">*b = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量</p><p><code>*</code>操作符的根本意义就是操作指针指向的变量，当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p></blockquote><h3 id="创建指针的另一种方法——new-函数"><a href="#创建指针的另一种方法——new-函数" class="headerlink" title="创建指针的另一种方法——new() 函数"></a>创建指针的另一种方法——new() 函数</h3><p>Go 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(T) <span class="comment">// T代表类型</span></span><br></pre></td></tr></table></figure><p>一般这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">&quot;zhimma&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str) <span class="comment">// zhimma</span></span><br></pre></td></tr></table></figure><blockquote><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;变量声明-使用var关键字&quot;&gt;&lt;a href=&quot;#变量声明-使用var关键字&quot; class=&quot;headerlink&quot; title=&quot;变量声明(使用var关键字)&quot;&gt;&lt;/a&gt;变量声明(使用var关键字)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;变量（Variable）的功能是存储用户的数据,不同的逻辑有不同的对象类型，也就有不同的变量类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Go语言使用&lt;strong&gt;var&lt;/strong&gt;关键字进行变量的声明&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
    <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Nginx单域名配置多Vue工程和多PHP接口</title>
    <link href="https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/</id>
    <published>2019-03-01T09:42:33.000Z</published>
    <updated>2021-03-23T10:09:08.042Z</updated>
    
    <content type="html"><![CDATA[<p>先简单说下需求吧：</p><p>前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即<code>小程序端</code>，<code>boss后台管理端</code>，<code>console客户端</code>，按照最简单的业务来解析域名，则需要6个域名。</p><p>由于种种原因吧，只能提供一个域名，所以就要借助Nginx的重定向或者rewrite功能；</p><p>大致流程和这里基本保持一致，<a href="https://blog.zhimma.com/2019/02/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8CPHP%E6%8E%A5%E5%8F%A3/">点击查看Nginx单域名配置多Vue工程和PHP接口</a></p><p>先贴一下代码吧：</p> <span id="more"></span><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> btg.ma;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="comment">##----boss api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/b &#123;</span><br><span class="line">       // 目录重定向</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/boss-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> $uri $uri/ @bossBackend;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $request_filename;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> @bossBackend &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123; </span><br><span class="line">            // 兼容路由模式-个人猜想</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/b/(.*)$</span> /boss/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /boss/b/(.*)$ /boss/b/index.php$is_args$args <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----boss web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/boss/;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/f/(.*)</span> /boss/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----console api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/console-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> $uri $uri/ @consoleBackend;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $request_filename;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> @consoleBackend &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/b/(.*)$</span> /console/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /console/b/(.*)$ /console/b/index.php$is_args$args <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----console web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/console/;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/f/(.*)</span> /console/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----crs api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/crs-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> $uri $uri/ @crsBackend;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME $request_filename;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> @crsBackend &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/b/(.*)$</span> /crs/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /crs/b/(.*)$ /crs/b/index.php$is_args$args <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----crs-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/crs/;</span><br><span class="line">        <span class="attribute">if</span> (!-e $request_filename) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/f/(.*)</span> /crs/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> @router &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#location /favicon.ico &#123;</span></span><br><span class="line">    <span class="comment">#    root /data/wwwroot/mk.vchangyi.com/web_test/backend;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/btg.ma.access.log main;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/btg.ma.<span class="literal">error</span>.log <span class="literal">error</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终效果就成为这样子：</p><p><code>domain/origin/type</code></p><p>域名+管理端+前后端，<strong>f</strong>代表<code>frontend</code>,<strong>b</strong>代表<code>backend</code></p><p><strong>boss:</strong></p><p>前台页面：<code>btg.ma/boss/f</code></p><p>后台接口地址：<code>btg.ma/boss/b</code></p><p><strong>console:</strong></p><p>前台页面：<code>btg.ma/console/f</code></p><p>后台接口地址：<code>btg.ma/console/b</code></p><p><strong>crs:</strong></p><p>前台页面：<code>btg.ma/crs/f</code></p><p>后台接口地址：<code>btg.ma/crs/b</code></p><p><em><strong>done</strong></em>;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先简单说下需求吧：&lt;/p&gt;
&lt;p&gt;前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即&lt;code&gt;小程序端&lt;/code&gt;，&lt;code&gt;boss后台管理端&lt;/code&gt;，&lt;code&gt;console客户端&lt;/code&gt;，按照最简单的业务来解析域名，则需要6个域名。&lt;/p&gt;
&lt;p&gt;由于种种原因吧，只能提供一个域名，所以就要借助Nginx的重定向或者rewrite功能；&lt;/p&gt;
&lt;p&gt;大致流程和这里基本保持一致，&lt;a href=&quot;https://blog.zhimma.com/2019/02/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8CPHP%E6%8E%A5%E5%8F%A3/&quot;&gt;点击查看Nginx单域名配置多Vue工程和PHP接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先贴一下代码吧：&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
    <category term="Vue" scheme="https://blog.zhimma.com/categories/Vue/"/>
    
    
    <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
    <category term="Vue" scheme="https://blog.zhimma.com/tags/Vue/"/>
    
  </entry>
  
</feed>
