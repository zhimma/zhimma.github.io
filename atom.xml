<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhimma&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zhimma.com/"/>
  <updated>2019-03-11T10:28:26.545Z</updated>
  <id>https://blog.zhimma.com/</id>
  
  <author>
    <name>zhimma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言学习笔记4-函数</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go语言学习笔记4-函数/</id>
    <published>2019-03-07T08:59:45.000Z</published>
    <updated>2019-03-11T10:28:26.545Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p><p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul><li>函数本身可以作为值进行传递。</li><li>支持匿名函数和闭包（closure）。</li><li>函数可以满足接口。</li></ul><h2 id="Go语言函数声明-函数定义"><a href="#Go语言函数声明-函数定义" class="headerlink" title="Go语言函数声明(函数定义)"></a>Go语言函数声明(函数定义)</h2><p>普通函数需要先声明才能调用，一个函数的声明包含参数和函数名等，编译器通过声明才能了解函数应该怎样在调用代码和函数体之间传递参数和返回值</p><h3 id="普通函数的声明形式"><a href="#普通函数的声明形式" class="headerlink" title="普通函数的声明形式"></a>普通函数的声明形式</h3><p>Go语言的函数声明以<code>func</code>标识，后面紧接着函数名、参数列表、返回参数列表及函数体，具体形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对各个部分进行说明：</p><ul><li><p>函数名：由字母、数字、下划线组成。其中，函数名的第一个字母不能为数字，在同一个包内，函数名称不能重复</p><blockquote><p>包(package) 是Go源码的一种组织方式，一个包可以认为是一个文件夹</p></blockquote></li><li><p>参数列表：一个参数由参数变量和参数类型组成，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中，参数列表中的变量作为函数的局部变量而存在。</p></li><li><p>返回参数列表：可以是返回值类型列表，也可以是类似参数列表中变量名和类型名的组合。函数在声明有返回值时，必须在函数体中使用return 语句提供返回值列表</p></li><li><p>函数体：能够被重复调用的代码片段</p></li></ul><h3 id="参数类型的缩写"><a href="#参数类型的缩写" class="headerlink" title="参数类型的缩写"></a>参数类型的缩写</h3><p>在参数列表中，如果有多个参数变量，则以逗号<code>,</code>分隔；如果相邻变量时同类型，则可以将类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，a 和 b 的参数类型均是 int 类型，则可以省略 a 的类型，在 b 后面有类型说明，这个类型也是 a 的类型</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地取得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数中可能发生的错误。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToMysql()</span><br></pre></td></tr></table></figure><p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误。</p><p><strong>Go 语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</strong></p><h4 id="同一类型返回值"><a href="#同一类型返回值" class="headerlink" title="同一类型返回值"></a>同一类型返回值</h4><p>如果返回值是同一类型，则用括号将多个返回值类型括起来，用逗号分割每个返回值的类型</p><p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go 语言支持对返回值进行命名，这样返回值就可以和参数一样拥有参数变量名和类型</p><p>命名的返回值变量的默认值为类型的默认值，即数值为 0 ，字符串为空字符串，布尔值为false，指针为 nil 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p><p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p><p>Go语言的函数调用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>函数名：需要调用的函数名。</li><li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li><li>返回值变量列表：多个返回值使用逗号分隔。</li></ul><h3 id="函数示例-将秒转为具体时间"><a href="#函数示例-将秒转为具体时间" class="headerlink" title="函数示例-将秒转为具体时间"></a>函数示例-将秒转为具体时间</h3><p>在本例中，使用一个数值表示时间中的“秒”值，然后使用<code>resolveTime()</code>函数将传入的秒数转换为天、小时和分钟等时间单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SecondsPerMinute = <span class="number">60</span></span><br><span class="line"><span class="keyword">var</span> SecondsPerHour = <span class="number">60</span> * SecondsPerMinute</span><br><span class="line"><span class="keyword">var</span> SecondsPerDay = <span class="number">24</span> * SecondsPerHour</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(resolveTime(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">_, hour, minute := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">day, _, _ := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveTime</span><span class="params">(seconds <span class="keyword">int</span>)</span> <span class="params">(day, hour, minutes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">day = seconds / SecondsPerDay</span><br><span class="line">hour = seconds / SecondsPerHour</span><br><span class="line">minutes = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中传入参数和返回参数 在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用</p><h2 id="函数变量-把函数作为值保存到变量中"><a href="#函数变量-把函数作为值保存到变量中" class="headerlink" title="函数变量-把函数作为值保存到变量中"></a>函数变量-把函数作为值保存到变量中</h2><p>在Go语言中，函数也是一种类型，可以和其他类型一样被保存在变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span> = <span class="title">foo</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"foo func"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言匿名函数"><a href="#Go语言匿名函数" class="headerlink" title="Go语言匿名函数"></a>Go语言匿名函数</h2><p>Go 语言支持匿名函数，即在需要使用函数时在定义函数，匿名函数没有函数名，只有函数体，函数可以被作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式被传递</p><p>匿名函数经常被用于实现回调函数、闭包等</p><h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的定义就是没有名字的普通函数定义</p><h3 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h3><p>匿名函数可以在声明后调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Prinln(data) </span><br><span class="line">&#125;(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h3><p>匿名函数体可以被赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的用途非常广泛，匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p><h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现。用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line"></span><br><span class="line">    for _, v := range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数作为回调函数的设计在 Go 语言的系统包中也比较常见，strings 包中就有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string &#123;</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言函数类型实现接口"><a href="#Go语言函数类型实现接口" class="headerlink" title="Go语言函数类型实现接口"></a>Go语言函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将分别对比<strong>结构体</strong>与<strong>函数</strong>实现<code>接口</code>的过程。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h2 id="Go语言闭包"><a href="#Go语言闭包" class="headerlink" title="Go语言闭包"></a>Go语言闭包</h2><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此简单的说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></table></figure><p>一个函数类型就像结构体一样，可以被实例化。函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期静态的概念，而闭包是运行期动态的概念。</p><h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上的变量的引用可以进行修改，修改引用的变量就会对变量进行实际的修改。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">fmt.Println(str); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个累加器，初始值1</span></span><br><span class="line">value := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(value()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(value()) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span> , value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个累加器，初始值为1</span></span><br><span class="line">otherValue := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(otherValue()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>value 与 otherValue的函数地址不同，因此它们是两个不同的闭包实例</p></blockquote><p>闭包的记忆效应进程被用于实现类似于设计模式中工厂模式的生成器。</p><h2 id="Go语言可变参数-变参函数"><a href="#Go语言可变参数-变参函数" class="headerlink" title="Go语言可变参数(变参函数)"></a>Go语言可变参数(变参函数)</h2><p>所谓可变参数，是指参数数量不固定的函数形式。<br>Go语言支持可变参数特性，函数声明和调用时没有固定数量的参数，同时也提供了一套方法进行可变参数的多级传参</p><p>Go语音的可变参数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(固定参数列表，v ... T)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数一般被放置在函数列表的末尾，前面是固定参数列表，当没有固定参数时，所有变量将是可变参数</li><li>v 为可变参数变量，类型为<code>[]T</code>,也就是拥有多个T 元素的 T 类型的切片v 和 T 之前由<code>...</code>组成</li><li>T 为可变参数的类型，当T 为<code>interface{}</code>时，传入的可以使任意类型</li></ul><h3 id="fmt包中的例子"><a href="#fmt包中的例子" class="headerlink" title="fmt包中的例子"></a>fmt包中的例子</h3><p>可变参数有两种类型：所有参数都是可变参数的形式，如<code>fmt.Println</code>,以及部分是可变参数的形式，如 <code>fmt.Printf</code>，可变参数只能出现在参数的后半部分，因此不可变的参数只能放在参数的前半部分。</p><h4 id="所有参数都是可变参数：fmt-Println"><a href="#所有参数都是可变参数：fmt-Println" class="headerlink" title="所有参数都是可变参数：fmt.Println"></a>所有参数都是可变参数：fmt.Println</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Println</code> 在使用时，传入的值类型不收限制，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"string"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="部分参数是可变参数：-fmt-Printf"><a href="#部分参数是可变参数：-fmt-Printf" class="headerlink" title="部分参数是可变参数： fmt.Printf"></a>部分参数是可变参数： fmt.Printf</h4><p><code>fmt.Printf</code> 的第一个参数为参数列表， 后面的参数是可变参数，<code>fmt.Printf</code>函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Printf()</code> 函数在调用时，第一个函数始终必须传入字符串，对应参数是 format，后面的参数数量可以变化</p><h2 id="Go语音defer-延迟执行语句"><a href="#Go语音defer-延迟执行语句" class="headerlink" title="Go语音defer(延迟执行语句)"></a>Go语音defer(延迟执行语句)</h2><p>Go语音的defer 语句会将其后面跟随的语句进行延迟处理。<br>在defer 归属的函数即将返回时，将延迟处理的语句按defer 的逆序进行执行，也就是说，先被defer 的语句最后执行，最后defer 的语句，最后被执行</p><h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"第一行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第二行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第三行"</span>)</span><br><span class="line">fmt.Println(<span class="string">"最后一行"</span>)</span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 最后一行</span></span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure><ul><li>代码的延迟顺序与最终执行顺序是反向的</li><li>延迟调用是在 defer 所在函数结束时执行，函数结束可以是正常返回，也可以是出错时返回</li></ul><h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较繁琐的事情，比如打开和关闭文件、和解锁接受请求和回复请求、加锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p><p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理释放资源的问题</p><h4 id="使用-defer-延迟释放资源"><a href="#使用-defer-延迟释放资源" class="headerlink" title="使用 defer 延迟释放资源"></a>使用 defer 延迟释放资源</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟调用close ，此时close 不会被调用</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">info , err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">size := info.Size()</span><br><span class="line"><span class="comment">// defer 机制触发，调用close关闭文件</span></span><br><span class="line"><span class="keyword">return</span>  size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源</p></blockquote><h2 id="Go语言处理运行时错误"><a href="#Go语言处理运行时错误" class="headerlink" title="Go语言处理运行时错误"></a>Go语言处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p><ul><li><p>一个可能造成错误的函数，需要返回值中返回一个错误接口(error) 。如果调用是成功的，错误接口将返回<code>nil</code> , 否则返回错误</p></li><li><p>在函数调用后需要检查错误，如果发生错误，需要进行必要的错误处理</p></li></ul><p>Go 语言没有类似 Java或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做。Go 语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源。同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p><p>Go 语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数。同时，Go 语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。&lt;/p&gt;
&lt;p&gt;Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。&lt;/p&gt;
&lt;p&gt;Go 语言的函
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记3-流程控制</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go语言学习笔记3-流程控制/</id>
    <published>2019-03-07T06:54:49.000Z</published>
    <updated>2019-03-07T08:58:00.197Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p> Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else (分支结构)"></a>if else (分支结构)</h2><p>在Go语言中可以通过 if 关键字进行条件判断，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p></blockquote><h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connect 是一个带有返回值的函数，<code>err:=Connect()</code> 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p><p><code>err！=nil</code>才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Go语言中所有的循环类型均可以使用for 关键字来完成</p><p>基于语句和表达式的基本for 循环格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束表达式&#123;</span><br><span class="line">    循环体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环体不停地进行循环，直到条件表达式返回 false 时自动退出循环，执行 for 的<code>}</code>之后的语句</p></blockquote><p>for 循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code> 语句强制退出循环。for 的初始语句、条件表达式、结束语句的详细介绍如下。</p><h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其<strong><u>作用域</u></strong>将被局限在这个for 的范畴内</p><p>注意：初始语句可以被忽略，但是初始语句之后的分号必须填写，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; step &gt; <span class="number">0</span>; step-- &#123;</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p><h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>对每次循环开始前计算的表达式，如果表达式为true ,则循环继续，否则结束循环，条件表达式可以被忽略，被忽律条件的条件表达式默认形成无限循环</p><h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无线循环"><a href="#无线循环" class="headerlink" title="无线循环"></a>无线循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p><h3 id="Demo-九九乘法表"><a href="#Demo-九九乘法表" class="headerlink" title="Demo 九九乘法表"></a>Demo 九九乘法表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">1</span>; y &lt;= x; y++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*%d=%d "</span>, x, y, x*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1 </span><br><span class="line">2*1=2 2*2=4 </span><br><span class="line">3*1=3 3*2=6 3*3=9 </span><br><span class="line">4*1=4 4*2=8 4*3=12 4*4=16 </span><br><span class="line">5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 </span><br><span class="line">6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 </span><br><span class="line">7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 </span><br><span class="line">8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 </span><br><span class="line">9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81</span><br></pre></td></tr></table></figure><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>Go 语言可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong> 及<strong>通道（channel）</strong>。通过 <code>for range</code>遍历的返回值有一定的规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map 返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><h3 id="遍历数组、切片——获得索引和元素"><a href="#遍历数组、切片——获得索引和元素" class="headerlink" title="遍历数组、切片——获得索引和元素"></a>遍历数组、切片——获得索引和元素</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值。下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">fmt.Println(key, <span class="string">"=&gt;"</span>, value)</span><br><span class="line"><span class="comment">// 0 =&gt; 1</span></span><br><span class="line"><span class="comment">// 1 =&gt; 2</span></span><br><span class="line"><span class="comment">// 2 =&gt; 3</span></span><br><span class="line"><span class="comment">// 3 =&gt; 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历字符串——获得索引和元素"><a href="#遍历字符串——获得索引和元素" class="headerlink" title="遍历字符串——获得索引和元素"></a>遍历字符串——获得索引和元素</h3><p>Go 语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引（base0）和字符串中的每一个字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好，zhimma"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"key:%d value:0x%x\n"</span>, key, value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">key:0 value:0x4f60 type:int32</span></span><br><span class="line"><span class="comment">            key:3 value:0x597d type:int32</span></span><br><span class="line"><span class="comment">            key:6 value:0xff0c type:int32</span></span><br><span class="line"><span class="comment">            key:9 value:0x7a type:int32</span></span><br><span class="line"><span class="comment">            key:10 value:0x68 type:int32</span></span><br><span class="line"><span class="comment">            key:11 value:0x69 type:int32</span></span><br><span class="line"><span class="comment">            key:12 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:13 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:14 value:0x61 type:int32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 变量，实际类型是 rune，实际上就是 int32，以十六进制打印出来就是字符的编码。</p><h3 id="遍历map——获得map的键和值"><a href="#遍历map——获得map的键和值" class="headerlink" title="遍历map——获得map的键和值"></a>遍历map——获得map的键和值</h3><p>对于 map 类型来说，<code>for range</code> 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们总是一对一对的出现。下面的代码演示了如何遍历 map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> family &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, key, value)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</p></blockquote><h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p><code>for range</code>可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h2><p>分支选择可以理解为一种批量的if语句，使用 switch 语句可方便地对大量的值进行判断。</p><p>在 Go 语言中的 switch，不仅可以基于常量进行判断，还可以基于表达式进行判断。</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go 语言改进了 switch 的语法设计，避免人为造成失误。Go 语言的 switch 中的每一个 case 与 case 间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"other"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"other"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，每个case 均是字符串格式，且使用了default 分支，Go语言规定每个 switch 只能有一个default 分支</p><h5 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h5><p>当出现多个 case 要放在一起的时候，可以像下面代码这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"mum"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mum"</span> , <span class="string">"dad"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"family"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不通的 case 表达式使用逗号分隔</p></blockquote><h5 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h5><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num &lt; <span class="number">20</span> || num &gt; <span class="number">20</span>:</span><br><span class="line">fmt.Println(<span class="string">"num value is "</span>, num)</span><br><span class="line"><span class="comment">// num value is  10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况的 switch 后面不再跟判断变量，连判断的目标都没有了。</p></blockquote><h2 id="goto-语句——跳转到指定的标签"><a href="#goto-语句——跳转到指定的标签" class="headerlink" title="goto 语句——跳转到指定的标签"></a>goto 语句——跳转到指定的标签</h2><p>goto 语句通过标签进行代码间的无条件跳转。goto 语句可以在快速跳出循环、避免重复退出上有一定帮助，使用 goto 语句能简化一些代码的实现过程。</p><h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>多层循环中，传统方式退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breakAgain <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 外循环</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="comment">// 内循环</span></span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="comment">// 满足某个条件时, 退出循环</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 设置退出标记</span></span><br><span class="line">                breakAgain = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 退出本次循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记, 还需要退出一次循环</span></span><br><span class="line">        <span class="keyword">if</span> breakAgain &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 goto方式优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到标签</span></span><br><span class="line">                <span class="keyword">goto</span> breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动返回, 避免执行进入标签</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第13行 ：标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 16 行代码。</p><p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p><h3 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><p>使用 goto 语句实现上面同样的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break (跳出循环)"></a>break (跳出循环)</h2><p>break 语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>代码块。break 语句还可以在语句后面添加标签，表示退出摸个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和<code>select</code>的代码块上</p><p>下面看下跳出指定循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">fmt.Println(i , j)</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 1 行，外层循环的标签。</li><li>第 2 行和第 3 行，双层循环。</li><li>第 5 行，使用 switch 进行数值分支判断。</li><li>第 8 和第 11 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 1 行。</li></ul><h2 id="continue-中断本次循环，继续下一次循环"><a href="#continue-中断本次循环，继续下一次循环" class="headerlink" title="continue(中断本次循环，继续下一次循环)"></a>continue(中断本次循环，继续下一次循环)</h2><p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用</p><p>在 continue 语句后添加标签时，表示开始标签对应的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OuterLoops:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">continue</span> OuterLoops</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>第 7 行将结束当前循环，开启下一次的外层循环，而不是第 3 行的循环。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。&lt;/p&gt;
&lt;p&gt; Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记2-容器</title>
    <link href="https://blog.zhimma.com/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/"/>
    <id>https://blog.zhimma.com/2019/03/06/Go语言学习笔记2-容器/</id>
    <published>2019-03-06T06:13:39.000Z</published>
    <updated>2019-03-07T06:53:43.851Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array) 是一段固定长度的连续内存区域<br>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>Go 的数组和切片都是从C语言延续过来的设计。</p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>数组变量名：数组声明及使用时的变量名</li><li>元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整形数值</li><li>T 可以是任意基本类型，包括 T 为数组本身。但类型为数组本身时，可以实现多维数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>] <span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">"JD"</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">"TaoBao"</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">"Wechat"</span></span><br><span class="line">fmt.Println(team) <span class="comment">// [JD TaoBao Wechat]</span></span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组可以在声明时使用初始化列表进行元素设置，参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式编写时，需要保证大括号后面的元素数量与数组的大小一致</p></blockquote><p>但一般情况下，这个过程可以交给编译器，让编译器在编译时，根据元素个数确定数组大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span> , <span class="string">"TaoBao"</span> , <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>...</code>表示让编译器确定数组大小。上面例子中，编译器会自动为这个数组设置元素个数为 3</p></blockquote><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组也和遍历切片类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> team &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0 JD</span></span><br><span class="line"><span class="comment">1 TaoBao</span></span><br><span class="line"><span class="comment">2 Wechat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个拥有相同类型元素的<strong>可变</strong>长度的序列，Go语言切片的内部包含<strong>地址</strong>、<strong>大小</strong>、<strong>容量</strong>，切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始(这个就是切片的地址)及切多大(这个就是切片的大小)。容量可以理解为装切片的口袋大小</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3154340Y9.jpg" alt=""></p><h3 id="生成切片-从数组或切片生成新的切片"><a href="#生成切片-从数组或切片生成新的切片" class="headerlink" title="生成切片(从数组或切片生成新的切片)"></a>生成切片(从数组或切片生成新的切片)</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身</p><p>从连续内存区域生成切片是常见的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice[开始位置:结束位置]</span><br></pre></td></tr></table></figure><ul><li>slice表示目标切片对象</li><li>开始位置对应目标切片对象的索引</li><li>结束位置对应目标切片的结束索引</li></ul><h4 id="从数组生成切片："><a href="#从数组生成切片：" class="headerlink" title="从数组生成切片："></a>从数组生成切片：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr , arr[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">// [1 2 3] [2]</span></span><br></pre></td></tr></table></figure><p><code>[2]</code>就是<code>arr[1:2]</code>切片操作的结果</p><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置-开始位置。</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。</li><li>当缺省开始位置时，表示从连续区域开头到结束位置。</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾。</li><li>两者同时缺省时，与数组本身等效。</li><li>两者同时为0时，等效于空切片，一般用于切片复位。</li></ul><p>根据索引位置取切片 slice 元素值时，取值范围是<strong>（0～len(slice)-1）</strong>，超界会报运行时错误</p><p>生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>具体，下面使用一些实例演示：</p><h5 id="指定范围生成切片"><a href="#指定范围生成切片" class="headerlink" title="指定范围生成切片"></a>指定范围生成切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个array</span></span><br><span class="line">build := [<span class="number">30</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++ &#123;</span><br><span class="line">build[i] = i +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间取值</span></span><br><span class="line">fmt.Println(build[<span class="number">10</span>:<span class="number">15</span>]) <span class="comment">// [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">// 中间部分到结尾所有元素</span></span><br><span class="line">fmt.Println(build[<span class="number">20</span>:]) <span class="comment">// [21 22 23 24 25 26 27 28 29 30]</span></span><br><span class="line"><span class="comment">// 开始到中间所有元素</span></span><br><span class="line">fmt.Println(build[:<span class="number">8</span>]) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p><h5 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h5><p>生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[:]) <span class="comment">// [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重置切片，清空所有元素"><a href="#重置切片，清空所有元素" class="headerlink" title="重置切片，清空所有元素"></a>重置切片，清空所有元素</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[<span class="number">0</span>:<span class="number">0</span>]) <span class="comment">// []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明新的切片"><a href="#声明新的切片" class="headerlink" title="声明新的切片"></a>声明新的切片</h4><p>除了可以从原有的数组或者切片中生成切片，你也可以声明一个新的切片<br>每一种类型都可以拥有其切片类型，表示多个类型元素的连续集合。因此切片类型也可以被声明。切片类型声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><ul><li>Name 表示切片的变量名</li><li>T 表示切片对应的元素类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明字符串切片</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 声明整形切片</span></span><br><span class="line"><span class="keyword">var</span> intSlice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 声明一个空切片</span></span><br><span class="line"><span class="keyword">var</span> emptySlice = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strSlice, intSlice, emptySlice) <span class="comment">// [] [] []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出3个切片大小</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(strSlice), <span class="built_in">len</span>(intSlice), <span class="built_in">len</span>(emptySlice)) <span class="comment">// 0 0 0</span></span><br><span class="line"><span class="comment">// 切片判定空的结果</span></span><br><span class="line">fmt.Println(strSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(intSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>) <span class="comment">// true true false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是动态结构，只能与nil判定相等，不能互相判等时。</p><p>声明新的切片后，可以使用<code>append()</code>函数来添加元素。</p><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><p>如果需要动态的创建一个切片，可以使用make()内建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,size,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><ul><li>T : 切片的元素类型</li><li>size : 就是为这个类型分配多少个元素</li><li>cap : 预分配元素数量，这个值设定不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题。</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b) <span class="comment">// [0 0] [0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)) <span class="comment">// 2 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">cap</span>(b)) <span class="comment">// 2 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。<br>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p></blockquote><p>使用 make() 函数生成的切片一定发生了内存分配操作。但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p><p>切片不一定必须经过 make() 函数才能使用。生成切片、声明后使用 append() 函数均可以正常使用切片</p><h3 id="使用append-为切片添加元素"><a href="#使用append-为切片添加元素" class="headerlink" title="使用append()为切片添加元素"></a>使用append()为切片添加元素</h3><ul><li>Go语言的内建函数 append() 可以为切片动态添加元素</li><li>每个切片会指向一片内存空间，这片空间能容纳一定数量的元素</li><li>当空间不能容纳足够多的元素时，切片就会进行“扩容”。“扩容”操作往往发生在 append() 函数调用时</li><li>切片在扩容时，容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">fmt.Printf(<span class="string">"len: %d,cap: %d,pointer: %p\n"</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line"><span class="comment">// len : 1,cap:1,pointer:0xc000014080</span></span><br><span class="line"><span class="comment">// len : 2,cap:2,pointer:0xc0000140b0</span></span><br><span class="line"><span class="comment">// len : 3,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 4,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 5,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 6,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 7,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 8,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 9,cap:16,pointer:0xc00008a000</span></span><br><span class="line"><span class="comment">// len : 10,cap:16,pointer:0xc00008a000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append() 函数除了添加一个元素外，也可以一次性添加很多元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> company []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加一个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"JD"</span>)</span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"taobao"</span> , <span class="string">"t.tt"</span>)</span><br><span class="line"><span class="comment">// 添加切片</span></span><br><span class="line">newCompany := []<span class="keyword">string</span>&#123;<span class="string">"mi"</span> , <span class="string">"坚果"</span>&#125;</span><br><span class="line">company = <span class="built_in">append</span>(company , newCompany...)</span><br><span class="line"></span><br><span class="line">fmt.Println(company) <span class="comment">// [JD taobao t.tt mi 坚果]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第 13 行，在newCompany后面加上了<code>...</code>，表示将 newCompany 整个添加到 car 的后面。</p></blockquote><h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>使用内建的 copy() 函数，可以迅速地将一个切片的数据复制到另外一个切片空间中，copy() 函数的使用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(originSlice,srcSlice []T)<span class="keyword">int</span></span><br></pre></td></tr></table></figure><ul><li>originSlice 为数据来源切片</li><li>srcSlice为复制的目标。目标切片必须分配过空间且足够承载复制的元素个数，来源和目标的类型一致，copy 的返回值表示实际发生复制的元素个数。</li></ul><h3 id="删除切片元素"><a href="#删除切片元素" class="headerlink" title="删除切片元素"></a>删除切片元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>&#125;</span><br><span class="line"><span class="comment">// 指定删除位置       </span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line"><span class="comment">// 查看删除位置之前的元素和之后的元素</span></span><br><span class="line">fmt.Println(seq[:index], seq[index+<span class="number">1</span>:])<span class="comment">// [a b] [d e]</span></span><br><span class="line"><span class="comment">// 将删除点前后的元素连接起来 </span></span><br><span class="line">seq = <span class="built_in">append</span>(seq[:index], seq[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(seq) <span class="comment">// [a b d e]</span></span><br></pre></td></tr></table></figure><p>代码的删除过程可以使用下图来描述。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3164544530.jpg" alt=""></p><p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p><blockquote><p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。</p></blockquote><h2 id="map-Go语言映射"><a href="#map-Go语言映射" class="headerlink" title="map(Go语言映射)"></a>map(Go语言映射)</h2><p>在业务和算法中需要使用任意类型的关联关系时，就需要使用到映射，如学号和学生的对应、名字与档案的对应等。</p><p>Go语言提供的映射关系容器为 map，map使用散列表（hash）实现。</p><h3 id="添加数据到map"><a href="#添加数据到map" class="headerlink" title="添加数据到map"></a>添加数据到map</h3><p>Go语言中 map 的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]vluesType</span><br></pre></td></tr></table></figure><ul><li>keyTyp 表示键类型</li><li>valueType 表示键对应值类型</li></ul><p>一个map 里，符合keyType和valueType 的映射总是成对出现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scene := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//  这里的map是内部实现的类型</span></span><br><span class="line">scene[<span class="string">"route"</span>] = <span class="number">666</span></span><br><span class="line">fmt.Println(scene[<span class="string">"route"</span>]) <span class="comment">// 666</span></span><br><span class="line"></span><br><span class="line">v := scene[<span class="string">"route2"</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尝试查找一个不存在的键，那么返回的将是 ValueType 的默认值</p></blockquote><p>某些情况下，需要明确知道查询中某个键是否在 map 中存在，可以使用一种特殊的写法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := scene[<span class="string">"route"</span>]</span><br></pre></td></tr></table></figure><p>在默认获取键值的基础上，多取了一个变量 ok，可以判断键 route 是否存在于 map 中。</p><p>map 还可以在声明时填充内容，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"W"</span> : <span class="string">"forward"</span>,</span><br><span class="line"><span class="string">"A"</span>: <span class="string">"left"</span>,</span><br><span class="line"><span class="string">"D"</span>: <span class="string">"right"</span>,</span><br><span class="line"><span class="string">"S"</span>: <span class="string">"backward"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[W:forward A:left D:right S:backward]</span></span><br></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><h4 id="遍历key-和-value"><a href="#遍历key-和-value" class="headerlink" title="遍历key 和 value"></a>遍历key 和 value</h4><p>map 的遍历过程使用 <code>for range</code>循环完成，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span>  family&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span> , key ,value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><p>遍历时，可以同时获得键和值。如只遍历值，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>将不需要的键改为匿名变量形式。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><p>只遍历键时，使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>无须将值改为匿名变量形式，忽略值即可</p><h3 id="map-元素删除和清空"><a href="#map-元素删除和清空" class="headerlink" title="map 元素删除和清空"></a>map 元素删除和清空</h3><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对 ，<code>delete()</code>函数的格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span> , 键)</span><br></pre></td></tr></table></figure><ul><li>map 为要删除的map实例</li><li>键为要删除的 map 键值对中的键</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">numMap := make(map[string]int)</span><br><span class="line"></span><br><span class="line">numMap[&quot;aroute&quot;] = 66</span><br><span class="line">numMap[&quot;brazil&quot;] = 4</span><br><span class="line">numMap[&quot;china&quot;] = 960</span><br><span class="line">delete(numMap , &quot;brazil&quot;)</span><br><span class="line">for k, v := range numMap &#123;</span><br><span class="line">fmt.Println(k , v)</span><br><span class="line">/**</span><br><span class="line">aroute 66</span><br><span class="line">china 960</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h4><p>有意思的是,Go语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是<strong>重新 make 一个新的 map</strong>。不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数高效多了。</p><h2 id="sync-Map-在并发环境中使用的map"><a href="#sync-Map-在并发环境中使用的map" class="headerlink" title="sync.Map(在并发环境中使用的map)"></a>sync.Map(在并发环境中使用的map)</h2><p>Go 语言中的 map 在并发情况下，只读是线程安全的，同时读写线程不安全。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个int到int的映射</span></span><br><span class="line">n := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 不停地对map进行写入</span></span><br><span class="line">n[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = n[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码会报错，输出如下：<br><code>fatal error: concurrent map read and map write</code></p><p>运行时输出提示：并发的 map 读写。也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题。map 内部会对这种并发操作进行检查并提前发现</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高。Go 语言在 1.9 版本中提供了一种效率较高的并发安全的 <code>sync.Map</code>。<code>sync.Map</code> 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p><code>sync.Map</code>有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。Range 参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scenes sync.Map</span><br><span class="line"><span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">scenes.Store(<span class="string">"greece"</span>, <span class="number">97</span>)</span><br><span class="line">scenes.Store(<span class="string">"london"</span>, <span class="number">100</span>)</span><br><span class="line">scenes.Store(<span class="string">"egypt"</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">fmt.Println(scenes.Load(<span class="string">"london"</span>))</span><br><span class="line"><span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">scenes.Delete(<span class="string">"london"</span>)</span><br><span class="line"><span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">scenes.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"iterate:"</span>, k, v)</span><br><span class="line"><span class="comment">// iterate: greece 97</span></span><br><span class="line"><span class="comment">//i terate: egypt 200</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>sync.Map 没有提供获取 map 数量的方法，替代方法是获取时遍历自行计算数量。sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之前的关系。列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示：</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31I54a30.jpg" alt=""></p><p>如果在这个基础上，再从 C 开始将自己的号码给自己知道号码的人，这样就形成了双链表结构，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31IJRI.jpg" alt=""></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环。这个过程就是列表遍历。<br>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除。这个过程就是列表元素的删除操作，如下图所示</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31J0524T.jpg" alt=""></p><p>在Go语言中，将列表使用 container/list 包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><code>list</code> 的初始化有两种方法：New 和声明。两种方法的初始化效果都是一致的。</p><h4 id="通过container-list-包的-New-方法初始化-list"><a href="#通过container-list-包的-New-方法初始化-list" class="headerlink" title="通过container/list 包的 New 方法初始化 list"></a>通过container/list 包的 New 方法初始化 list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure><h4 id="通过声明初始化list"><a href="#通过声明初始化list" class="headerlink" title="通过声明初始化list"></a>通过声明初始化list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure><p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制。因此，列表的元素可以是任意类型。这既带来便利，也会引来一些问题。给一个列表放入了非期望类型的值，在取出值后，将 interface{} 转换为期望类型时将会发生宕机。</p><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 <code>PushFront</code>和 <code>PushBack</code>。</p><p>这两个方法都会返回一个 <code>*list.Element</code> 结构。如果在以后的使用中需要删除插入的元素，则只能通过 <code>*list.Element</code> 配合<code>Remove()</code>方法进行删除，这种方法可以让删除更加效率化，也是双链表特性之一</p><p>下面代码展示给list添加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br></pre></td></tr></table></figure><p>列表插入元素的方法如下表所示。</p><table><thead><tr><th>方  法</th><th>功  能</th></tr></thead><tbody><tr><td>InsertAfter(v interface {}, mark <em> Element) </em> Element</td><td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td></tr><tr><td>InsertBefore(v interface {}, mark <em> Element) </em>Element</td><td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td></tr><tr><td>PushBackList(other *List)</td><td>添加 other 列表元素到尾部</td></tr><tr><td>PushFrontList(other *List)</td><td>添加 other 列表元素到头部</td></tr></tbody></table><h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表的插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值及和其他节点之间的关系等信息。从列表中删除元素时，需要用到这个结构进行快速删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入age</span></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line"><span class="comment">// 头部插入18+</span></span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"><span class="comment">// 在fist之后添加high</span></span><br><span class="line">l.InsertAfter(<span class="string">"high"</span>, element)</span><br><span class="line"><span class="comment">// 在fist之前添加noon</span></span><br><span class="line">l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">l.Remove(element)</span><br></pre></td></tr></table></figure><p>下表中展示了每次操作后列表的实际元素情况。</p><table><thead><tr><th>操作内容</th><th>列表元素</th></tr></thead><tbody><tr><td>l.PushBack(“age”)</td><td>age</td></tr><tr><td>l.PushFront(“18+”)</td><td>18+, age</td></tr><tr><td>element := l.PushBack(“fist”)</td><td>18+, age, fist</td></tr><tr><td>l.InsertAfter(“high”, element)</td><td>18+, age, fist, high</td></tr><tr><td>l.InsertBefore(“noon”, element)</td><td>18+, age, noon, fist, high</td></tr><tr><td>l.Remove(element)</td><td>18+, age, noon, high</td></tr></tbody></table><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>遍历双链表需要配合 <code>Front()</code>函数获取头元素，遍历时只要元素不为空就可以继续进行。每一次遍历调用元素的 <code>Next</code>，如代码中第 6 行所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">    <span class="comment">// 67</span></span><br><span class="line">    <span class="comment">// canon</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次；每次循环会进行一次 i!=nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i=i.Next()。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记1-基本语法</title>
    <link href="https://blog.zhimma.com/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://blog.zhimma.com/2019/03/05/Go语言学习笔记1-基本语法/</id>
    <published>2019-03-05T08:48:28.000Z</published>
    <updated>2019-03-07T07:55:34.994Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="变量声明-使用var关键字"><a href="#变量声明-使用var关键字" class="headerlink" title="变量声明(使用var关键字)"></a>变量声明(使用var关键字)</h2><blockquote><p>变量（Variable）的功能是存储用户的数据,不同的逻辑有不同的对象类型，也就有不同的变量类型</p></blockquote><p>Go语言使用<strong>var</strong>关键字进行变量的声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">e</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行，声明一个整形类型的变量，用来保存整数数值</li><li>第二行，声明一个字符串类型的变量</li><li>第三行，声明一个32位浮点切片类型的变量，浮点切片表示由多个浮点类型组成的数据结构</li><li>第四行，声明一个返回值为bool类型的函数变量，这种形式一般用于回调函数，即将函数以变量的形式保存下来，在需要的时候重新调用这个函数</li><li>声明一个结构体类型的变量，这个结构体拥有一个整形的x字段</li></ul><h3 id="标准格式声明"><a href="#标准格式声明" class="headerlink" title="标准格式声明"></a>标准格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量的声明是以var关键字开头，要声明的变量名放中间，将其类型放在后面，行尾无需分号</p><h3 id="批量格式声明"><a href="#批量格式声明" class="headerlink" title="批量格式声明"></a>批量格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c []<span class="keyword">float32</span></span><br><span class="line">d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用var和括号，可以将一组变量定义放在一起</p><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p><ul><li>整型和浮点型变量的默认值为 0</li><li>字符串变量的默认值为空字符串</li><li>布尔型变量默认为 bool</li><li>切片、函数、指针变量的默认为 nil</li></ul><p>在声明变量的时候也可以进行赋初始值</p><h3 id="变量初始化标准格式"><a href="#变量初始化标准格式" class="headerlink" title="变量初始化标准格式"></a>变量初始化标准格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><h3 id="编译器推导类型"><a href="#编译器推导类型" class="headerlink" title="编译器推导类型"></a>编译器推导类型</h3><p>在标准格式的基础上，可以省略部分变量类型，编译器会尝试根据等号右边的表达式推导变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><p>等号右边的部分在编译原理里被称做右值（rvalue）</p><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p>var 的变量声明还有一种精简写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><blockquote><p> 左值变量必须是没有定义过的变量</p></blockquote><p>在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><p>多重赋值时，变量的左值和右值按从左到右的顺序赋值<br>多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。</p><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在使用多重赋值时，如果不需要在左值中接收变量，可以使用匿名变量（anonymous variable）</p><p>匿名变量的表现是一个下划线<code>_</code>,使用匿名变量时，只需要在变量声明的地方使用下画线替换即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line">fmt.Println(a, b)<span class="comment">// 100 200</span></span><br></pre></td></tr></table></figure><p><strong>匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</strong></p><p>匿名变量：</p><ul><li>可以理解为一种占位符。</li><li>本身这种变量不会进行空间分配，也不会占用一个变量的名字。</li><li>在<code>for range</code> 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li></ul><h2 id="Go语言类型"><a href="#Go语言类型" class="headerlink" title="Go语言类型"></a>Go语言类型</h2><p>Go语言 中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异，切片类型有着指针的便利性，但比指针更为安全，很多高级语言都配有切片进行安全和高效率的内存操作。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整型分为以下两个大类：</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>还有对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。</p><h3 id="浮点类型（小数类型）"><a href="#浮点类型（小数类型）" class="headerlink" title="浮点类型（小数类型）"></a>浮点类型（小数类型）</h3><p>Go语言</p><p>支持两种浮点型数：float32 和 float64。这两种浮点型数据格式遵循 IEEE 754 标准：</p><ul><li>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。</li><li>float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</li></ul><p>打印浮点数时，可以使用 fmt 包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi) <span class="comment">//按默认宽度和精度输出整型</span></span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)<span class="comment">//按默认宽度，2 位精度输出（小数点后的位数）。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.141593</span></span><br><span class="line"><span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>布尔型数据只有 true（真）和 false（假）两个值，布尔型无法参与数值运算，也无法与其他类型进行转换</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在Go语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。</p><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转移符</th><th>含  义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr></tbody></table><h4 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h4><p>在源码中，将字符串的值以双引号书写的方式是字符串的常见表达方式，被称为字符串字面量（string literal）<br>这种双引号字面量不能跨行。如果需要在源码中嵌入一个多行字符串时，就必须使用<strong>`</strong>字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><blockquote><p>在<strong>`</strong>间的所有代码均不会被编译器识别，而只是作为字符串的一部分</p></blockquote><h3 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h3><p>字符串中的每一个元素叫做<strong>“字符”</strong>，在遍历或者单个获取字符串元素时可以获得字符</p><p>Go语言的字符有以下两种：</p><ol><li><strong>uint8</strong>类型，也叫<strong>byte</strong>型，代表了<strong>ASCLL</strong>码中的一个字符</li><li><strong>rune</strong>类型，代表一个<strong>UTF-8</strong>字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32。</li></ol><p>使用<code>fmt.Printf</code>中的<code>%T</code>动词可以输出、变量的实际类型，使用这个方法可以查看 byte 和 rune 的本来类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, a, a) <span class="comment">// 97 uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">rune</span> = <span class="string">'你'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, b, b) <span class="comment">// 20320 int32</span></span><br></pre></td></tr></table></figure><blockquote><p>可以发现，byte 类型的 a 变量，实际类型是 uint8，其值为 ‘a’，对应的 ASCII 编码为 97<br>rune 类型的 b 变量的实际类型是 int32，对应的 Unicode 码就是 20320<br>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p></blockquote><h2 id="Go数据类型转换"><a href="#Go数据类型转换" class="headerlink" title="Go数据类型转换"></a>Go数据类型转换</h2><p>Go语言使用类型前置加括号的方式进行数据类型转换，一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><blockquote><p>T代表要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><p>类型转换时，需要考虑两种类型的关系和范围，是否会发生数值截断等</p></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，例如圆周率。<br>可以在编译时，对常量表达式进行计算求值，并在运行期使用该计算结果，计算结果无法被修改。常量表示起来非常简单，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">4.14159</span></span><br></pre></td></tr></table></figure><p>常量的声明和变量声明非常类似，只是把 var 换成了 const。</p><p>多个变量可以一起声明，类似的，常量也是可以多个一起声明的，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.141592</span></span><br><span class="line">    e = <span class="number">2.718281</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量因为在编译期确定，所以可以用于数组声明，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> arr [size]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="模拟枚举-const和iota模拟枚举"><a href="#模拟枚举-const和iota模拟枚举" class="headerlink" title="模拟枚举(const和iota模拟枚举)"></a>模拟枚举(const和iota模拟枚举)</h2><p>Go语言现阶段没有枚举，可以使用 const 常量配合 iota 模拟枚举，请看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weapon <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower) <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="comment">// 使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>枚举类型其实本质是一个 int 一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。</p><h2 id="Go语言type关键字-类型别名"><a href="#Go语言type关键字-类型别名" class="headerlink" title="Go语言type关键字(类型别名)"></a>Go语言type关键字(类型别名)</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名的写法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a NewInt</span><br><span class="line">fmt.Printf(&quot;a type : %T\n&quot;, a) // a type : main.NewInt</span><br><span class="line"></span><br><span class="line">var b IntAlias</span><br><span class="line">fmt.Printf(&quot;b type %T\n&quot;, b) // b type int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 8 行，将 NewInt 定义为 int 类型，这是常见定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</li><li>第 11 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。</li><li>第 15 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。</li><li>第 16 行，使用<code>%T</code>格式化参数，显示 a 变量本身的类型。</li><li>第 18 行，将 b 声明为 IntAlias 类型，此时打印 b 的值为 0。</li><li>第 19 行，显示 b 变量的类型。</li></ul><p>结果显示a的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型。b 类型是 int。IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。</p><h2 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h2><p>指针（pointer）概念在Go语言中被拆分为两个核心概念：</p><ol><li>类型指针，运行对这个指针类型的数据进行修改，传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算</li><li>切片，由指向起始元素的原始指针、元素数量和容量组成</li></ol><p>受益于这样的约束和拆分，Go 语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p>要明白指针，需要知道几个概念：<strong>指针地址</strong>、<strong>指针类型</strong>和<strong>指针取值</strong>，下面将展开细说。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置</p><p>Go 语言中使用<code>&amp;</code>作符放在变量前面对变量进行“取地址”操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中v代表被取地址的变量，被取地址的v使用ptr变量进行接收，ptr的类型就为<code>*T</code>,称做 T 的指针类型，<code>*</code>代表指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cat <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"banana"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p %p"</span>, &amp;cat, &amp;str) <span class="comment">// 0xc042052088 0xc0420461b0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>第 8 行，声明整型 cat 变量。</li><li>第 9 行，声明字符串 str 变量。</li><li>第 10 行，使用 fmt.Printf 的动词<code>%p</code>输出 cat 和 str 变量取地址后的指针值，指针值带有<code>0x</code>的十六进制前缀。</li></ul><p>输出值在每次运行是不同的，代表 cat 和 str 两个变量在运行时的地址。</p><p><strong>提示：变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址</strong></p><h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用<code>&amp;</code>操作符获取地址获得这个变量的指针后，可以对指针使用<code>*</code>操作，也就是指针取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 声明一个字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">"陕西西安"</span></span><br><span class="line"><span class="comment">// 对字符串取地址，ptr类型为*string</span></span><br><span class="line">ptr := &amp;house</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出ptr类型</span></span><br><span class="line">fmt.Printf(<span class="string">"ptr type: %T\n"</span> , ptr) <span class="comment">// ptr type: *string</span></span><br><span class="line"><span class="comment">// 输出ptr指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">"address: %p\n"</span> , ptr) <span class="comment">// address: 0xc00000e1e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针进行取值操作</span></span><br><span class="line">value := *ptr</span><br><span class="line"><span class="comment">// 取值后类型</span></span><br><span class="line">fmt.Printf(<span class="string">"value type: %T\n"</span> , value) <span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// 指针去之后就是指向变量的值</span></span><br><span class="line">fmt.Printf(<span class="string">"value: %s\n"</span> , value) <span class="comment">//value: 陕西西安</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</strong></p><h3 id="变量、指针地址、指针变量、取地址、取值的相互关系和特性"><a href="#变量、指针地址、指针变量、取地址、取值的相互关系和特性" class="headerlink" title="变量、指针地址、指针变量、取地址、取值的相互关系和特性"></a>变量、指针地址、指针变量、取地址、取值的相互关系和特性</h3><p>如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 交换变量值</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line"><span class="comment">// 输出变量值</span></span><br><span class="line">fmt.Println(x, y) <span class="comment">// 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">t := *a</span><br><span class="line"><span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">*a = *b</span><br><span class="line"><span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">*b = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量</p><p><code>*</code>操作符的根本意义就是操作指针指向的变量，当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p></blockquote><h3 id="创建指针的另一种方法——new-函数"><a href="#创建指针的另一种方法——new-函数" class="headerlink" title="创建指针的另一种方法——new() 函数"></a>创建指针的另一种方法——new() 函数</h3><p>Go 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(T) <span class="comment">// T代表类型</span></span><br></pre></td></tr></table></figure><p>一般这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">"zhimma"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str) <span class="comment">// zhimma</span></span><br></pre></td></tr></table></figure><blockquote><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;变量声明-使用var关键字&quot;&gt;&lt;a href=&quot;#变量声明-使用var关键字&quot; class=&quot;headerlink&quot; title=&quot;变量声明(使用var关键字)&quot;&gt;&lt;/a&gt;变量声明(使用var关键字)&lt;/h2&gt;&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Nginx单域名配置多Vue工程和多PHP接口</title>
    <link href="https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/03/01/Nginx单域名配置多Vue工程和多PHP接口/</id>
    <published>2019-03-01T09:42:33.000Z</published>
    <updated>2019-03-01T10:03:18.633Z</updated>
    
    <content type="html"><![CDATA[<p>先简单说下需求吧：</p><p>前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即<code>小程序端</code>，<code>boss后台管理端</code>，<code>console客户端</code>，按照最简单的业务来解析域名，则需要6个域名。</p><p>由于种种原因吧，只能提供一个域名，所以就要借助Nginx的重定向或者rewrite功能；</p><p>大致流程和这里基本保持一致，<a href="https://blog.zhimma.com/2019/02/01/Nginx单域名配置多Vue工程和PHP接口/">点击查看Nginx单域名配置多Vue工程和PHP接口</a></p><p>先贴一下代码吧：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> btg.ma;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="comment">##----boss api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/b &#123;</span><br><span class="line">       // 目录重定向</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/boss-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@bossBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@bossBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            // 兼容路由模式-个人猜想</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/b/(.*)$</span> /boss/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /boss/b/(.*)$ /boss/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----boss web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/boss/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/f/(.*)</span> /boss/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----console api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/console-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@consoleBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@consoleBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/b/(.*)$</span> /console/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /console/b/(.*)$ /console/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----console web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/console/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/f/(.*)</span> /console/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----crs api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/crs-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@crsBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@crsBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/b/(.*)$</span> /crs/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /crs/b/(.*)$ /crs/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----crs-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/crs/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/f/(.*)</span> /crs/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#location /favicon.ico &#123;</span></span><br><span class="line">    <span class="comment">#    root /data/wwwroot/mk.vchangyi.com/web_test/backend;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/btg.ma.access.log main;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/btg.ma.<span class="literal">error</span>.log <span class="literal">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果就成为这样子：</p><p><code>domain/origin/type</code></p><p>域名+管理端+前后端，<strong>f</strong>代表<code>frontend</code>,<strong>b</strong>代表<code>backend</code></p><p><strong>boss:</strong></p><p>前台页面：<code>btg.ma/boss/f</code></p><p>后台接口地址：<code>btg.ma/boss/b</code></p><p><strong>console:</strong></p><p>前台页面：<code>btg.ma/console/f</code></p><p>后台接口地址：<code>btg.ma/console/b</code></p><p><strong>crs:</strong></p><p>前台页面：<code>btg.ma/crs/f</code></p><p>后台接口地址：<code>btg.ma/crs/b</code></p><p><strong><em>done</em></strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先简单说下需求吧：&lt;/p&gt;
&lt;p&gt;前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即&lt;code&gt;小程序端&lt;/code&gt;，&lt;code&gt;boss后台管理端&lt;/code&gt;，&lt;code&gt;conso
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/categories/Vue/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Nginx目录路径重定向</title>
    <link href="https://blog.zhimma.com/2019/03/01/Nginx%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://blog.zhimma.com/2019/03/01/Nginx目录路径重定向/</id>
    <published>2019-03-01T09:41:48.000Z</published>
    <updated>2019-03-01T10:07:55.645Z</updated>
    
    <content type="html"><![CDATA[<p>如果希望域名后边跟随的路径指向本地磁盘的其他目录,而不是默认的web目录时,需要设置nginx目录访问重定向</p><p>应用场景:<code>domain.com/image</code>自动跳转到<code>domain.com/folderName/image</code>目录。</p><h2 id="Nginx目录路径重定向的几种实现方式"><a href="#Nginx目录路径重定向的几种实现方式" class="headerlink" title="Nginx目录路径重定向的几种实现方式:"></a>Nginx目录路径重定向的几种实现方式:</h2><h3 id="Nginx修改root映射"><a href="#Nginx修改root映射" class="headerlink" title="Nginx修改root映射"></a>Nginx修改root映射</h3><p>修改root映射实现nginx目录访问重定向是最简单的方式, 推荐采用这一种.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image &#123;</span><br><span class="line">    <span class="attribute">root</span>   /folderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Nginx-rewrite内部跳转实现访问重定向"><a href="#通过Nginx-rewrite内部跳转实现访问重定向" class="headerlink" title="通过Nginx rewrite内部跳转实现访问重定向"></a>通过Nginx rewrite内部跳转实现访问重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>     /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx设置别名alias映射实现"><a href="#Nginx设置别名alias映射实现" class="headerlink" title="Nginx设置别名alias映射实现"></a>Nginx设置别名alias映射实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image  &#123;</span><br><span class="line">    <span class="attribute">alias</span>  /folderName/image;  <span class="comment">#这里写绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过nginx的permanent-301绝对跳转实现"><a href="#通过nginx的permanent-301绝对跳转实现" class="headerlink" title="通过nginx的permanent 301绝对跳转实现"></a>通过nginx的permanent 301绝对跳转实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>   http://dashidan.com/folderName/image/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过判断uri实现页面跳转"><a href="#通过判断uri实现页面跳转" class="headerlink" title="通过判断uri实现页面跳转"></a>通过判断uri实现页面跳转</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~* ^(/image))</span>&#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span> /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上转自<code>https://dashidan.com/article/webserver/nginx/4.html</code></p><p>具体实例，<a href="https://dashidan.com/article/webserver/nginx/4.html" target="_blank" rel="noopener">请参考这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果希望域名后边跟随的路径指向本地磁盘的其他目录,而不是默认的web目录时,需要设置nginx目录访问重定向&lt;/p&gt;
&lt;p&gt;应用场景:&lt;code&gt;domain.com/image&lt;/code&gt;自动跳转到&lt;code&gt;domain.com/folderName/image&lt;/c
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-基础方法Basic Steps</title>
    <link href="https://blog.zhimma.com/2019/02/20/Jenkins-%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95Basic-Steps/"/>
    <id>https://blog.zhimma.com/2019/02/20/Jenkins-基础方法Basic-Steps/</id>
    <published>2019-02-20T06:38:25.000Z</published>
    <updated>2019-02-21T12:01:37.486Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>这篇开始来学习一个最基础的pipeline组件，这个也是一个独立的插件，在安装pipeline的时候默认会自动安装，插件的名称是<a href="https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Basic+Steps+Plugin" target="_blank" rel="noopener">Pipeline: Basic Steps</a>,你可以去你自己jenkins环境，插件管理下的installed下面找到这个插件</p><p>下面具体介绍下该插件包含的各个方法    </p><h3 id="deleteDir-方法"><a href="#deleteDir-方法" class="headerlink" title="deleteDir()方法"></a>deleteDir()方法</h3><p>默认递归删除WORKSPACE下的文件和文件夹,这个方法是没有参数，也不需要参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">deleteDir()  <span class="comment">// clean up current work directory</span></span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/deleteDir.png" alt=""></p><h3 id="dir-方法"><a href="#dir-方法" class="headerlink" title="dir()方法"></a>dir()方法</h3><p>如果使用了dir语句块，这个方法就是改变当前的工作目录</p><p>在dir语句块里执行的其他路径或者相对路径，都是和dir里面设置的文件路径相关，这个和WORKSPACE相对文件路径已经没有关系了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    println env.WORKSPACE</span><br><span class="line">    dir(<span class="string">"$&#123;env.WORKSPACE&#125;/testdata"</span>)&#123;</span><br><span class="line">    sh <span class="string">"pwd"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/dir.png" alt=""></p><h3 id="echo-和-error-方法"><a href="#echo-和-error-方法" class="headerlink" title="echo() 和 error()方法"></a>echo() 和 error()方法</h3><p>echo就是和groovy中的println没有任何区别,如果看打印的效果。一般来说使用echo就是打印info debug级别的日志输出用</p><p>如果遇到错误，就可以使用error(‘error message’)    ，如果出现执行到error方法，jenkins job会退出并显示失败效果。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    echo(<span class="string">"this is echo info"</span>)</span><br><span class="line">    error(<span class="string">"this is error info"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/error.png" alt=""></p><h3 id="fileExists-方法"><a href="#fileExists-方法" class="headerlink" title="fileExists()方法"></a>fileExists()方法</h3><p>这是判断一个文件是否存在，返回值是布尔类型，true就表示文件存在，false表示文件不存在</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">json_file = <span class="string">"$&#123;env.WORKSPACE&#125;/testdata/test_json.json"</span></span><br><span class="line"><span class="keyword">if</span>(fileExists(json_file) == <span class="literal">true</span>) &#123;</span><br><span class="line">echo(<span class="string">"json file is exists"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">"here haven't find json file"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/fileExists.png" alt=""></p><h3 id="pwd-方法"><a href="#pwd-方法" class="headerlink" title="pwd()方法"></a>pwd()方法</h3><p>其实这个方法和linux下的shell命令pwd是一样的。由于jenkins支持windows和linux，但是linux是pwd，windows上是dir,所以这个插件就干脆支持一个方法，统称为pwd()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">sh(<span class="string">"pwd"</span>)</span><br><span class="line">println <span class="string">"==========="</span></span><br><span class="line">println pwd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/pwd.png" alt=""></p><h3 id="isUnix-方法"><a href="#isUnix-方法" class="headerlink" title="isUnix()方法"></a>isUnix()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(&quot;Demo&quot;) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">if(isUnix() == true) &#123;</span><br><span class="line">echo(&quot;this jenkins job running on a linux-like system&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">error(&quot;the jenkins job running on a windows system&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/isUnix.png" alt=""></p><h3 id="mail指令"><a href="#mail指令" class="headerlink" title="mail指令"></a>mail指令</h3><h4 id="Jenkins服务器上配置smtp服务"><a href="#Jenkins服务器上配置smtp服务" class="headerlink" title="Jenkins服务器上配置smtp服务"></a>Jenkins服务器上配置smtp服务</h4><p><strong>subject</strong></p><p>必填，邮件标题主题，Type: <code>String</code></p><p><strong>body</strong></p><p>必填，邮件正文，Type: <code>String</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">script &#123;</span><br><span class="line">mail <span class="string">to:</span> <span class="string">'admin@163.com'</span>,</span><br><span class="line"><span class="symbol">                    subject:</span> <span class="string">"Running Pipeline: $&#123;currentBuild.fullDisplayName&#125;"</span>,</span><br><span class="line"><span class="symbol">                    body:</span> <span class="string">"Something is wrong with $&#123;env.BUILD_URL&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;这篇开始来学习一个最基础的pipeline组件，这个也是一个独立的插件，在安装pipeline的时候默认会自动安装，插件的名称是&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Pipelin
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-Pipeline语法入门</title>
    <link href="https://blog.zhimma.com/2019/02/18/Jenkins-Pipeline%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.zhimma.com/2019/02/18/Jenkins-Pipeline语法入门/</id>
    <published>2019-02-18T14:28:14.000Z</published>
    <updated>2019-02-19T10:21:32.770Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>流水线最基础的部分是 “step”。基本上, step告诉 Jenkins 要做什么，以及作为声明式(Declarative)和脚本化(Scripted)流水线语法的基本构建块。</p><h2 id="Declarative-Pipeline-声明管道"><a href="#Declarative-Pipeline-声明管道" class="headerlink" title="Declarative Pipeline-声明管道"></a>Declarative Pipeline-声明管道</h2><p>有效的Declarative Pipeline必须包含在一个pipeline块内，例如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    <span class="comment">/* insert Declarative Pipeline here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Declarative Pipeline中有效的基本语句和表达式遵循与Groovy语法相同的规则 ，但有以下例外：</p><ul><li>Pipeline的顶层必须是块(block)，其实就是<code>pipeline { }</code></li><li>没有分号作为语句分隔符。每个声明必须在自己的一行</li><li>块只能包含章节， 指令，步骤<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或赋值语句</li><li>属性引用语句被视为无参数方法调用。所以例如，input被视为input（）</li></ul><blockquote><p>第一点：    就是声明指定的代码块</p><p>第二点：分号写了也是多余的。Groovy代码还可以写分号，Jenkins Pipeline代码就不需要，每行只写一个声明语句块或者调用方法语句</p><p>第三点：只能包含<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或者赋值语句</p><p>第四点：没懂，懂了再回来补充</p></blockquote><h3 id="Sections-章节-节段"><a href="#Sections-章节-节段" class="headerlink" title="Sections-章节/节段"></a>Sections-章节/节段</h3><p>Declarative Pipeline 代码中的Sections指的是必须包含一个或者多个指令或者步骤的<strong>代码区域块</strong>。Sections不是一个关键字或者指令，只是一个<strong>逻辑概念</strong>。</p><h3 id="agent指令-代理"><a href="#agent指令-代理" class="headerlink" title="agent指令-代理"></a><a href="https://blog.csdn.net/u011541946/article/details/83278214" target="_blank" rel="noopener">agent指令-代理</a></h3><p>agent部分指定整个Pipeline或特    定阶段将在Jenkins环境中执行的位置，具体取决于该agent 部分的放置位置。该部分必须在pipeline块内的顶层定义 ，但阶段级使用是可选的</p><blockquote><p>简单来说，agent部分主要作用就是告诉Jenkins，选择那台节点机器去执行Pipeline代码；这个指令是必须要有的，也就在你顶层pipeline {…}的下一层，必须要有一个agent{…}</p><p>agent这个指令对应的多个可选参数。</p><p>这里注意一点，在具体某一个stage {…}里面也可以使用agent指令。这种用法不多，一般我们在顶层使用agent，这样，接下来的全部stage都在一个agent机器下执行代码。</p><p>为了支持Pipeline作者可能拥有的各种用例，该agent部分支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p></blockquote><h4 id="参数1：any"><a href="#参数1：any" class="headerlink" title="参数1：any"></a>参数1：any</h4><p>作用：在任何可用的代理上执行Pipeline或stage</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种是最简单的，如果你Jenkins平台环境只有一个master，那么这种写法就最省事情</p><h4 id="参数2：none"><a href="#参数2：none" class="headerlink" title="参数2：none"></a>参数2：none</h4><p>作用：当在<code>pipeline</code>块的顶层应用时，将不会为整个Pipeline运行分配全局代理，并且每个<code>stage</code>部分将需要包含其自己的<code>agent</code>部分,就像上面说的在具体某一个stage {…}里面也可以使用agent指令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>)&#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">               label <span class="string">'具体的节点名称'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数3：label"><a href="#参数3：label" class="headerlink" title="参数3：label"></a>参数3：label</h4><p>作用：使用提供的标签在Jenkins环境中可用的代理机器上执行Pipeline或stage内执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">       label <span class="string">'具体一个节点label名称'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="参数4：node"><a href="#参数4：node" class="headerlink" title="参数4：node"></a>参数4：node</h4><p>作用：和上面label功能类似，但是node运行其他选项，例如customWorkspace</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post指令"><a href="#post指令" class="headerlink" title="post指令"></a><a href="https://blog.csdn.net/u011541946/article/details/83278531" target="_blank" rel="noopener">post指令</a></h3><p><code>post</code>部分定义将在Pipeline运行或阶段结束时运行的操作</p><p><code>post</code>部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a>,这些阶段根Pipeline或stage的完成情况而运行,<code>post</code> 支持以下 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#post-conditions" target="_blank" rel="noopener">post-condition</a> 块中的其中之一: <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code></p><blockquote><p>简单来说，post可以放在顶层，也就是和agent{…}同级，也可以放在stage里面。一般放顶层的比较多。而且pipeline代码中post代码块不是必须的，使用post的场景基本上执行完一个构建，进行发送消息通知，例如构建失败会发邮件通知</p></blockquote><p>简单示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">        stages &#123;</span><br><span class="line">            stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">          <span class="comment">//写相关post部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post条件的基本用法"><a href="#post条件的基本用法" class="headerlink" title="post条件的基本用法"></a>post条件的基本用法</h4><p>在post代码块区域，支持多种条件指令，这些指令有always，changed，failure，success，unstable，和aborted。下面分别来介绍这些条件的基本用法。</p><h5 id="条件1：always"><a href="#条件1：always" class="headerlink" title="条件1：always"></a>条件1：always</h5><p>作用：无论Pipeline运行的完成状态如何都会执行这段代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">//写相关清除/恢复环境等操作代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个always场景，很容易想到的场景就是，事后清理环境。例如测试完了，对数据库进行恢复操作，恢复到测试之前的环境。</p><h5 id="条件2：changed"><a href="#条件2：changed" class="headerlink" title="条件2：changed"></a>条件2：changed</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        changed &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个场景，大部分是写发邮件状态。例如，你最近几次构建都是成功，突然变成不是成功状态，里面就触发发邮件通知。当然，使用changed这个指令没success和failure要频率高</p><h5 id="条件3：failure"><a href="#条件3：failure" class="headerlink" title="条件3：failure"></a>条件3：failure</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        failure &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个failure条件一般来说，百分百会写到Pipeline代码中，内容无非就是发邮件通知，或者发微信群，钉钉机器人，还有国外的slack聊天群组等。</p><h3 id="stages和steps指令"><a href="#stages和steps指令" class="headerlink" title="stages和steps指令"></a>stages和steps指令</h3><ol><li><p><strong>stages</strong>被外层的<code>pipeline { }</code>包裹，内部包含多个<strong>stage</strong></p></li><li><p>每个<strong>stage</strong>代码块内包含多个<strong>steps { }</strong>，一个<strong>stage</strong>下至少有一个<strong>steps { }</strong>，一般也就是一个<strong>steps { }</strong></p></li><li><p>我们可以在一个steps下写调用一个或者几个方法，也就是两三行代码。具体的代码实现，可以放在别的包里面</p></li><li><p>stages下可以包含多个stage, 在一个Declarative Pipeline脚本中，只允许出现一次stages</p><p>以后我们大部分的pipeline代码都在每一个stage里面的steps下,如下示例</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Build"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Build"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Test"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Test"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Deploy"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Deploy"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面println是Groovy的语法，就是一个打印语句。不管以后pipeline代码有多么复杂，都是以这个为基础骨架，例如添加一些try catch语句还有其他的指令。</p></blockquote><h3 id="stage指令"><a href="#stage指令" class="headerlink" title="stage指令"></a>stage指令</h3><p>该stage指令在该stages部分中，应包含步骤部分，可选agent部分或其他特定于阶段的指令。实际上，Pipeline完成的所有实际工作都将包含在一个或多个stage指令中。</p><blockquote><p>stage一定是在stages{…}里面，一个pipeline{…}中至少有一个stages{…}和一个stage{…}.这里多说一句，一个stage{…}中至少有一个steps{…}。stage{…}还有一个特点就是，里面有一个强制的字符串参数，例如下面的”Example”，这个字符串参数就是描述这个stage是干嘛的，这个字符串参数是不支持变量的，只能你自己取名一个描述字段。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="environment指令"><a href="#environment指令" class="headerlink" title="environment指令"></a>environment指令</h3><p><strong>environment</strong>指令定义一个键-值，该键-值对将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>解释一下什么意思，environment{…}, 大括号里面写一些键值对，也就是定义一些变量并赋值，这些变量就是<strong>环境变量</strong>。环境变量的作用范围，取决你environment{…}所写的位置，你可以写在顶层环境变量，让所有的stage下的step共享这些变量，也可以单独定义在某一个stage下，只能供这个stage去调用变量，其他的stage不能共享这些变量。</p><p>一般来说，我们基本上上定义全局环境变量，如果是局部环境变量，我们直接用def关键字声明就可以，没必要放environment{…}里面</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        boolStatus = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Demo'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(boolStatus == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// Todo</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="options指令"><a href="#options指令" class="headerlink" title="options指令"></a>options指令</h3><p>该options指令允许在Pipeline本身内配置Pipeline专用选项，Pipeline提供了许多这些选项，例如buildDiscarder，但它们也可能由插件提供，例如 timestamps。</p><p>一个pipeline{…}内只运行出现<strong>一次<code>options{…}</code></strong>, 下面看一个下这个retry的使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    option &#123;</span><br><span class="line">        retry(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Demo"</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">//Tode</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的整个pipeline{…}, 如果在<a href="https://www.baidu.com/s?wd=jenkins&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">jenkins</a>上job执行失败，会继续执行，如果再遇到失败，继续执行一次，总共执行三次</p><p>把options{…}放在顶层里，也可以放在具体的某一个stage下，意味这这个stage下所有代码，如果遇到失败，最多执行三次。    </p></blockquote><h3 id="parameters指令"><a href="#parameters指令" class="headerlink" title="parameters指令"></a>parameters指令</h3><p><strong>parameters</strong>是参数的意思，parameters指令提供用户在触发Pipeline时应提供的参数列表，这些用户指定的参数的值通过该params对象可用于Pipeline步骤。</p><p>我们很多人听过<strong>参数化构建(Build with Parameters)</strong>，也可能知道如何在一个jenkins job上，通过UI创建不同的参数，例如有<strong>字符串参数</strong>，<strong>布尔选择参数</strong>，<strong>下拉多选参数</strong>等。这些参数即可以通过UI点击创建，也可以通过pipeline代码去写出来。我们先来看看了解有那些具体参数类型，然后挑选几个，分别用UI和代码方式去实现创建这些参数。</p><h4 id="字符串参数"><a href="#字符串参数" class="headerlink" title="字符串参数"></a>字符串参数</h4><p>就是定义一个字符串参数，用户可以在Jenkins UI上输入字符串，常见使用这个参数的场景有，用户名，收件人邮箱，文件网络路径，主机名称的或者url等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any   </span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'DEPLOY_ENV'</span>, <span class="string">defaultValue:</span> <span class="string">'staging'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔值参数"><a href="#布尔值参数" class="headerlink" title="布尔值参数"></a>布尔值参数</h4><p>就是定义一个布尔类型参数，用户可以在Jenkins UI上选择是还是否，选择是表示代码会执行这部分，如果选择否，会跳过这部分。一般需要使用布尔值的场景有，执行一些特定集成的脚本或则工作，或者事后清除环境，例如清楚Jenkins的workspace这样的动作。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        booleanParam(<span class="string">name:</span> <span class="string">'DEBUG_BUILD'</span>, <span class="string">defaultValue:</span> <span class="literal">true</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本参数"><a href="#文本参数" class="headerlink" title="文本参数"></a>文本参数</h4><p>文本（text）的参数就是支持写很多行的字符串，这个变量我好像没有使用过，例如想给发送一段欢迎的消息，你可以采用text的参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        text(<span class="string">name:</span> <span class="string">'Welcome_text'</span>, <span class="string">defaultValue:</span> <span class="string">'One\nTwo\nThree\n'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的\n表示换行，上面写了三行的text</p></blockquote><h4 id="选择参数"><a href="#选择参数" class="headerlink" title="选择参数"></a>选择参数</h4><p>选择（choice）的参数就是支持用户从多个选择项中，选择一个值用来表示这个变量的值。工作中常用的场景，有选择服务器类型，选择版本号等。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(<span class="string">name:</span> <span class="string">'ENV_TYPE'</span>, <span class="string">choices:</span> [<span class="string">'test'</span>, <span class="string">'dev'</span>, <span class="string">'product'</span>], <span class="string">description:</span> <span class="string">'test means test env,….'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件参数"><a href="#文件参数" class="headerlink" title="文件参数"></a>文件参数</h4><p>文件（file）参数就是在Jenkins 参数化构建UI上提供一个文件路径的输入框，Jenkins会自动去你提供的网络路径去查找并下载。一般伴随着还有你需要在Pipleline代码中写解析文件。也有这样场景，这个构建job就是把一个war包部署到服务器上特定位置，你可以使用这个文件参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line"><span class="symbol">        name:</span> <span class="string">'FILE'</span>, <span class="string">description:</span> <span class="string">'Some file to upload'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="密码参数"><a href="#密码参数" class="headerlink" title="密码参数"></a>密码参数</h4><p>密码（password）参数就是在Jenkins 参数化构建UI提供一个密文密码输入框，例如，我需要在一些linux机器上做自动化操作，需要提供机器的用户名和密码，由于密码涉及安全问题，一般都采用暗文显示，这个时候你就不能用string类型参数，就需要使用password参数类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        password(<span class="string">name:</span> <span class="string">'PASSWORD'</span>, <span class="string">defaultValue:</span> <span class="string">'SECRET'</span>, <span class="string">description:</span> <span class="string">'A secret password'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="web-ui方式"><a href="#web-ui方式" class="headerlink" title="web ui方式"></a>web ui方式</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/paramsFlow.gif" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                println <span class="string">"stringValue = $&#123;stringValue&#125;"</span></span><br><span class="line">                println <span class="string">"passwordValue = $&#123;passwordValue&#125;"</span></span><br><span class="line">                println <span class="string">"boolValue = $&#123;boolValue&#125;"</span></span><br><span class="line">                println <span class="string">"choseValue = $&#123;choseValue&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="triggers指令"><a href="#triggers指令" class="headerlink" title="triggers指令"></a>triggers指令</h3><ol><li>该triggers指令定义了Pipeline应重新触发的自动化方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成可能已经存在</li><li>目前有三个可用的触发器是cron和pollSCM 和 upstream    </li><li>在一个pipeline{…}代码中，只运行出现一次triggers{…},而且这个指令不是必须存在的。</li><li>triggers是触发器的意思，所以这块是设置什么条件下触发pipeline代码执行，以及触发的频率</li></ol><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>接受一个cron风格的字符串来定义Pipeline应重新触发的常规间隔，例如： triggers { cron(‘H 4/* 0 0 1-5’) }</p><p>####pollSCM</p><p> 接受一个cron风格的字符串来定义Jenkins应该检查新的源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers { pollSCM(‘H 4/* 0 0 1-5’) }</p><h4 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h4><p>接受逗号分隔的作业字符串和阈值。 当字符串中的任何作业以最小阈值结束时，将重新触发pipeline。例如：triggers { upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p><p>举例一个可能利用scm的场景，如果一个公司做到了很好的代码覆盖测试，一般都会，如果监控到有人提交代码，就会自动化触发启动相关的单元测试。这个场景就是适合在pipeline代码里使用triggers指令，下面代码举例一个pollSCM的基本使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        pollSCM (‘H H(<span class="number">9</span><span class="number">-16</span>)/<span class="number">2</span> * * <span class="number">1</span><span class="number">-5</span>)’)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释下“H H(9-16)/2 <em> </em> 1-5)”的含义，这个你可以在上面截图这个页面点击右侧这个问号，出来具体含义。第一步，先根据空格，把字符串切割成5段</p></blockquote><p>所以，H H(9-16)/2 <em> </em> 1-5) 的含义就是：</p><blockquote><p>第一部分“H” 表示hash，记住不是表示hour，是一个散列值，含义就是在一个小时之内，会执行一次，但是这次是一个散列值，而且不会并发执行。</p><p>第二部分“H(9-16)/2”，表示白天在早上9点到下午5点，每间隔2小时执行一次。</p><p>第三部分“*“，每天执行</p><p>第四部分“*“表示每月执行</p><p>第五部分“1-5“ 表示周一到周五执行</p><p>所以上面这个表达式“H H(9-16)/2 <em> </em> 1-5) “的含义就是，在每个月的周一到周五的白天，从早上9点到下午5点，每间隔两个小时去触发一次自动化构建。 这个就比较适合，我们每天上班，间隔两个小时去跑一次单元自动化测试。间隔时间长短，取决服务器压力和业务具体场景</p></blockquote><h3 id="input指令"><a href="#input指令" class="headerlink" title="input指令"></a>input指令</h3><p>该input指令允许在一个stage{…}显示提示输入等待。在inpt{…}写一些条件，然后用户触发构建这个job，但是这个时候没有接收到有效的input, job会一直在等待中；</p><p>下面解释input{…}里面支持写那些option。</p><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>必选，这个message会在用户提交构建的页面显示，提示用户提交相关的input条件</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>可选，可以作为这个input的标记符，默认的标记符是这个stage的名称</p><h4 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h4><p>可选， 主要是在ok按钮上显示一些文本，在input表单里</p><h4 id="submitter"><a href="#submitter" class="headerlink" title="submitter"></a>submitter</h4><p>可选，里面可以写多个用户名称或者组名称，用逗号隔开。意思就是，只有这写名称的对应用户登陆jenkins，才能提交这个input动作，如果不写，默认是任何人都可以提交input。</p><h4 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h4><p>可选，我们前面学的parameters没有区别，就是定义一些参数的地方    </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/inputFlow.gif" alt=""></p><p>代码示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            input &#123;</span><br><span class="line">                message <span class="string">"是否继续执发布操作?"</span></span><br><span class="line">                ok <span class="string">"是的,继续执行"</span></span><br><span class="line">                <span class="comment">// 用户,好像设置了没什么用</span></span><br><span class="line">                submitter <span class="string">"admin"</span></span><br><span class="line">                parameters &#123;</span><br><span class="line">                    string(<span class="string">name:</span> <span class="string">'NAME'</span>, <span class="string">defaultValue:</span> <span class="string">'zhimma'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello, $&#123;NAME&#125;, nice to meet you."</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when指令"><a href="#when指令" class="headerlink" title="when指令"></a>when指令</h3><p><strong>when</strong>指令允许流水线根据给定的条件决定是否应该执行阶段</p><p> <strong>when</strong>指令必须包含至少一个条件。</p><p><strong>when</strong> 指令包含多个条件, 所有的子条件必须返回True，阶段才能执行</p><p>下面详细解释下<strong>when</strong>可以使用的内置条件</p><h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h4><p>当正在构建的分支与模式给定的分支匹配时，执行这个阶段;例如：<code>when { branch &#39;master&#39; }</code>。请注意，这仅适用于多分支Pipeline。</p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>当指定的环境变量是给定的值时，执行这个步骤, 例如: <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></p><h4 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h4><p>当指定的Groovy表达式评估为true时，执行这个阶段, 例如: <code>when { expression { return params.DEBUG_BUILD } }</code></p><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>当嵌套条件是错误时，执行这个阶段,必须包含一个条件，例如: <code>when { not { branch &#39;master&#39; } }</code></p><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p>当所有的嵌套条件都正确时，执行这个阶段,必须包含至少一个条件，例如: <code>when { allOf { branch &#39;master&#39;; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; } }</code></p><h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>当至少有一个嵌套条件为真时，执行这个阶段,必须包含至少一个条件，例如: <code>when { anyOf { branch &#39;master&#39;; branch &#39;staging&#39; } }</code></p><h4 id="在进入-stage的-agent前测试执行when"><a href="#在进入-stage的-agent前测试执行when" class="headerlink" title="在进入 stage的 agent前测试执行when"></a>在进入 <code>stage</code>的 <code>agent</code>前测试执行<code>when</code></h4><p>默认情况下, 如果定义了某个阶段的agent，在进入该<code>stage</code>的<code>agent</code>后该 <code>stage</code>的<code>when</code> 条件将会被执行。但是, 可以通过在 <code>when</code>块中指定<code>beforeAgent</code> 选项来更改此选项。如果<code>beforeAgent</code> 被设置为 <code>true</code>, 那么就会首先对<code>when</code>条件进行评估 , 并且只有在<code>when</code>条件验证为真时才会进入<code>agent</code> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        quick_test = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    echo <span class="string">'Hello World'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Example Deploy'</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; </span><br><span class="line">                   <span class="keyword">return</span>  (quick_test == <span class="string">"true"</span>)  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://testerhome.com/topics/9977" target="_blank" rel="noopener">https://testerhome.com/topics/9977</a></p><p><a href="https://testerhome.com/topics/17251" target="_blank" rel="noopener">https://testerhome.com/topics/17251</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;流水线最基础的部分是 “step”。基本上, step告诉 Jenkins 要做什么，以及作为声明式(Declarative)和脚本化(Scripted)流水线语法的基本构建块。&lt;/p&gt;
&lt;h2 id=&quot;Declarative-Pipeline-声
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins的Pipeline发布代码至远程服务器</title>
    <link href="https://blog.zhimma.com/2019/02/16/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84Pipeline%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://blog.zhimma.com/2019/02/16/使用Jenkins的Pipeline发布代码至远程服务器/</id>
    <published>2019-02-16T14:07:31.000Z</published>
    <updated>2019-02-19T01:39:44.080Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们软件开发流程大概是下面所示：</p><p>本地开发-&gt;本地自测-&gt;提交代码-&gt;编译发布-&gt;测试人员测试-&gt;提交至生产</p><p>在发布阶段，</p><ol><li>有的项目是采用版本控制工具在Linux服务器上拉取对应分支的最新代码</li><li>有的是在本地对比Git版本的差异，生成差异的文件，打包上传至服务器，进行覆盖原来的代码文件完成发布</li></ol><p>上面2种方法是我工作中遇到的，下面我们来学习一种新的发布方式：<strong>Jenkins</strong></p><blockquote><p><strong>Jenkins可以帮你在写完代码后，一键完成开发过程中的一系列工作</strong></p></blockquote><p>特别是在开发阶段，配合<strong>WebHook</strong>可以非常省心的完成代码发布工作，开发者只需要提交代码，就会触发Jenkins发布任务的执行，从而将最新代码部署到服务器上</p><h2 id="什么是Jenkins？"><a href="#什么是Jenkins？" class="headerlink" title="什么是Jenkins？"></a>什么是Jenkins？</h2><p><strong>Jenkins</strong>是一个Java开放的开源程序，所以，需要提前安装Java JDK环境，能支持安装到windows,mac,linux平台，主要是一个管理工具</p><h2 id="为什么要使用Jenkins"><a href="#为什么要使用Jenkins" class="headerlink" title="为什么要使用Jenkins?"></a>为什么要使用Jenkins?</h2><p>我们用它，主要是项目上的持续集成和持续交付。持续集成对应英文（Continuous Integration），有时候简称CI，持续交付对应英文（Continuous Delivery），简称CD，以后，听到了CI和CD，就明白了什么意思。下面这张图，是Jenkins在实际项目运用上的一个经典的流程图</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/jenkinsFlow.png" alt=""></p><p>##安装Jenkins</p><p>安装的方式很多，我这里学习Jenkins采用的是Docker创建容器的方式运行</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><code>docker pull jenkins</code></p><p>下载完成，查看下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls</span><br><span class="line">REPOSITORY                                 TAG                 IMAGE ID     </span><br><span class="line">jenkins/jenkins                            latest              9b74eda1c268</span><br></pre></td></tr></table></figure><h3 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h3><p>这个目录根据个人需求，可以进行重新指定，我指定的是：<code>/Users/zhimma/jenkins</code></p><p><code>mkdir /Users/zhimma/jenkins</code></p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><code>docker run -d -p 49001:8080 -v $PWD/jenkins:/var/jenkins_home -t jenkins/jenkins</code></p><blockquote><p>我映射了容器的端口8080到主机上的端口49001， 第一个数字代表主机上的端口，而最后一个代表容器的端口</p></blockquote><p>运行后，Docker会帮我们创建一个Jenkins的运行环境的容器，使用<code>docker ps</code> 查看容器启动情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES</span><br><span class="line">782c2fb5ef74        jenkins/jenkins     &quot;/sbin/tini -- /usr/…&quot;   3 days ago          Up 3 days           50000/tcp, 0.0.0.0:49001-&gt;8080/tcp   trusting_burnell</span><br></pre></td></tr></table></figure><p>到这，我们的Jenkins环境搭建完成，下面我们做一些初始化工作</p><h3 id="初始化Jenkins"><a href="#初始化Jenkins" class="headerlink" title="初始化Jenkins"></a>初始化Jenkins</h3><h4 id="解锁Jenkins"><a href="#解锁Jenkins" class="headerlink" title="解锁Jenkins"></a>解锁Jenkins</h4><p>在浏览器中输入<code>localhost:49001</code>，进入web页面，第一次需要先解锁Jenkins</p><p>进入<code>/Users/zhimma/jenkins/secrets</code>目录，制<code>initialAdminPassword</code>文件的内容就是首次解锁的密码</p><h4 id="安装推荐插件"><a href="#安装推荐插件" class="headerlink" title="安装推荐插件"></a>安装推荐插件</h4><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/init.gif" alt="初始化"></p><h4 id="设置管理员"><a href="#设置管理员" class="headerlink" title="设置管理员"></a>设置管理员</h4><h3 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h3><p>我们目前使用GitLab管理代码，所以我们先安装下面几个插件</p><ul><li>GitLab Plugin</li><li>Gitlab Hook Plugin</li><li>AnsiColor（可选）这个插件可以让Jenkins的控制台输出的log带有颜色（就和linux控制台那样）</li></ul><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/installPlugin.gif" alt="安装插件"></p><p>###配置SSH</p><p>本机生成SSH：<code>ssh-keygen -t rsa -C &quot;Your email&quot;</code>，最终生成id_rsa和id_rsa.pub(公钥)</p><p>Gitlab上添加公钥：复制id_rsa.pub里面的公钥添加到Gitlab</p><p>Jenkins上配置密钥到SSH：复制id_rsa里面的公钥添加到Jenkins（private key选项）</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/ssh.gif" alt=""></p><p>##开始Pipeline</p><p>在Jenkins中，把每一段管道比作是不同的Job，我们提到Jenkins的工作流程，build-deploy-test-release，每个流程之间我们都可以用Pipeline来连接，大致如下效果图。</p><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/flow.png" alt=""></p><blockquote><p>SCM:软件配置管理工具</p></blockquote><p>###创建Pipeline风格的项目</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/createProject.gif" alt=""></p><p>###实现Pipeline-Web UI方式</p><p>如下图所示：</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/webuiway.gif" alt=""></p><p>###实现Pipeline-Jenkinsfile方式</p><p>上面通过Web UI方式只适用于非常简单的任务，而大型复杂的任务最好采用<code>Jenkinsfile</code>方式并纳入SCM管理。 这次我选择从SCM中的<code>Jenkinsfile</code>来定义管道。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/scm.gif" alt=""></p><p>我们需要在自己的项目根目录创建<code>Jenkinsfile</code>文件，在里面编写具体的发布流程代码。</p><h3 id="使用Jenkinsfile"><a href="#使用Jenkinsfile" class="headerlink" title="使用Jenkinsfile"></a>使用Jenkinsfile</h3><p>接下来详细介绍一下怎样编写<code>Jenkinsfile</code>来完成各种复杂的任务。</p><p>Pipeline支持两种形式，一种是<code>Declarative</code>管道，一个是<code>Scripted</code>管道。</p><p>一个<code>Jenkinsfile</code>就是一个文本文件，里面定义了<code>Jenkins Pipeline</code>。 将这个文本文件放到项目的根目录下面，纳入版本系统。</p><p>####Declarative风格类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个Declarative类型的Pipeline，目前实际开发基本采用这种方式；</p><ul><li>第一行是小写的pipeline，然后一对大括{}，大括号里面就是代码块，用来和别的代码块隔离出来，pipeline是一个语法标识符,也叫关键字，如果是Declarative类型，一定是pipeline {}这样起头的；如果是脚本文件，pipeline不要求一定是第一行代码。也就是说pipeline前面可以有其他代码，例如导入语句，和其他功能代码。pipeline是一个执行pipeline代码的入口，jenkins可以根据这个入门开始执行里面不同stage</li><li>第二行agent any，agent是一个语法关键字，any是一个option类型，agent是代理的意思，这个和选择用jenkins平台上那一台机器去执行任务构建有关</li><li>第三行stages{}, stages是多个stage的意思，也就是说一个stages可以包含多个stage，从上面代码结果你也可以看出来。上面写了三个stage，根据你任务需要，你可以写十多个都可以</li><li>第四行stage(‘Build’) {}, 这个就是具体定义一个stage,一般一个stage就是指完成一个业务场景。<strong>Build</strong>是认为给这个任务取一个名字。</li><li>第五行steps{},字面意思就是很多个步骤的意思。这里提一下，看到了steps，当然还有step这个指令。一般来说，一个steps{}里面就写几行代码，或者一个try catch语句。</li></ul><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><p><code>post</code> section 定义了管道执行结束后要进行的操作。支持在里面定义很多<code>Conditions</code>块： <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code> 和 <code>unstable</code>。 这些条件块会根据不同的返回结果来执行不同的逻辑。</p><ul><li>always：不管返回什么状态都会执行</li><li>changed：如果当前管道返回值和上一次已经完成的管道返回值不同时候执行</li><li>failure：当前管道返回状态值为”failed”时候执行，在Web UI界面上面是红色的标志</li><li>success：当前管道返回状态值为”success”时候执行，在Web UI界面上面是绿色的标志</li><li>unstable：当前管道返回状态值为”unstable”时候执行，通常因为测试失败，代码不合法引起的。在Web UI界面上面是黄色的标志</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">'I will always say Hello again!'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h5><p>由一个或多个<code>stage</code>指令组成，stages块也是核心逻辑的部分。 我们建议对于每个独立的交付部分（比如<code>Build</code>,<code>Test</code>,<code>Deploy</code>）都应该至少定义一个<code>stage</code>指令。比如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            echo <span class="string">'Hello World'</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h5><p>在<code>stage</code>中定义一系列的<code>step</code>来执行命令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123; ①</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h5><p><code>agent</code>指令指定整个管道或某个特定的<code>stage</code>的执行环境。它的参数可用使用：</p><ol><li>any - 任意一个可用的agent</li><li>none - 如果放在pipeline顶层，那么每一个<code>stage</code>都需要定义自己的<code>agent</code>指令</li><li>label - 在jenkins环境中指定标签的agent上面执行，比如<code>agent { label &#39;my-defined-label&#39; }</code></li><li>node - <code>agent { node { label &#39;labelName&#39; } }</code> 和 label一样，但是可用定义更多可选项</li><li>docker - 指定在docker容器中运行</li><li>dockerfile - 使用源码根目录下面的<code>Dockerfile</code>构建容器来运行</li></ol><h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h5><p><code>environment</code>定义键值对的环境变量</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">'clang'</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">'my-prefined-secret-text'</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'printenv'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p>还能定义一些管道特定的选项，介绍几个常用的：</p><ul><li>skipDefaultCheckout - 在<code>agent</code>指令中忽略源码<code>checkout</code>这一步骤。</li><li>timeout - 超时设置<code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></li><li>retry - 直到成功的重试次数<code>options { retry(3) }</code></li><li>timestamps - 控制台输出前面加时间戳<code>options { timestamps() }</code></li></ul><h5 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h5><p>参数指令，触发这个管道需要用户指定的参数，然后在<code>step</code>中通过<code>params</code>对象访问这些参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'PERSON'</span>, <span class="string">defaultValue:</span> <span class="string">'Mr Jenkins'</span>, <span class="string">description:</span> <span class="string">'Who should I say hello to?'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello $&#123;params.PERSON&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="triggers"><a href="#triggers" class="headerlink" title="triggers"></a>triggers</h5><p>触发器指令定义了这个管道何时该执行，一般我们会将管道和GitHub、GitLab、BitBucket关联， 然后使用它们的webhooks来触发，就不需要这个指令了。如果不适用<code>webhooks</code>，就可以定义两种<code>cron</code>和<code>pollSCM</code></p><ul><li>cron - linux的cron格式<code>triggers { cron(&#39;H 4/* 0 0 1-5&#39;) }</code></li><li>pollSCM - jenkins的<code>poll scm</code>语法，比如<code>triggers { pollSCM(&#39;H 4/* 0 0 1-5&#39;) }</code></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">'H 4/* 0 0 1-5'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h5><p><code>stage</code>指令定义在<code>stages</code>块中，里面必须至少包含一个<code>steps</code>指令，一个可选的<code>agent</code>指令，以及其他stage相关指令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h5><p>定义自动安装并自动放入<code>PATH</code>里面的工具集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">'apache-maven-3.0.1'</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'mvn --version'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：① 工具名称必须预先在Jenkins中配置好了 → Global Tool Configuration.</p><h5 id="内置条件"><a href="#内置条件" class="headerlink" title="内置条件"></a>内置条件</h5><ul><li>branch - 分支匹配才执行 <code>when { branch &#39;master&#39; }</code></li><li>environment - 环境变量匹配才执行 <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></li><li>expression - groovy表达式为真才执行 <code>expression { return params.DEBUG_BUILD } }</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Declarative //</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;Example Build&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &apos;Hello World&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Example Deploy&apos;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &apos;production&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &apos;Deploying&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h5><p>这里就是实实在在的执行步骤了，每个步骤step都具体干些什么东西， 前面的<code>Sections</code>、<code>Directives</code>算控制逻辑和环境准备，这里的就是真实执行步骤。</p><p>这部分内容最多不可能全部讲完，<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="noopener">官方Step指南</a> 包含所有的东西。</p><p><code>Declared Pipeline</code>和<code>Scripted Pipeline</code>都能使用这些step，除了下面这个特殊的<code>script</code>。</p><p>一个特殊的step就是<code>script</code>，它可以让你在声明管道中执行脚本，使用groovy语法，这个非常有用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">'chrome'</span>, <span class="string">'firefox'</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">"Testing the $&#123;browsers[i]&#125; browser"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 一个优雅的退出pipeline的方法，这里可执行任意逻辑</span></span><br><span class="line">                    <span class="keyword">if</span>( $VALUE1 == $VALUE2 ) &#123;</span><br><span class="line">                       currentBuild.result = <span class="string">'SUCCESS'</span></span><br><span class="line">                       <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scripted风格类型"><a href="#Scripted风格类型" class="headerlink" title="Scripted风格类型"></a>Scripted风格类型</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node &#123;  </span><br><span class="line">    stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 这个代码，有两点和上面不同。</p><p>第一个是Scripted模式是node{}开头，并没有pipeline{}直观。</p><p>第二个要指出的是，scripted模式下没有stages这个关键字或者指令，只有stage。上面其实可以node(‘Node name’) {}来开头，Node name就是从节点或master节点的名称。</p></blockquote><p><code>Scripted Pipeline</code>没那么多东西，就是定义一个<code>node</code>， 里面多个<code>stage</code>，里面就是使用Groovy语法执行各个<code>step</code>了，非常简单和清晰，也非常灵活。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Jenkins定了很多内置的环境变量，可在文档<code>localhost:49001/pipeline-syntax/globals#env</code>找到， 通过<code>env</code>直接使用它们：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 测试环境变量</span></span><br><span class="line">            echo <span class="string">"Running $&#123;env.BUILD_ID&#125; on $&#123;env.JENKINS_URL&#125;"</span></span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录修改Jenkinsfile后，提交到服务器，点击立即构建，查看<code>Console Output</code>输出系统的环境变量</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/envParams.png" alt=""></p><h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><p><a href="https://blog.csdn.net/u011541946/article/details/83152494" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/details/83152494</a></p><p><a href="https://blog.csdn.net/u011541946/article/category/8223796/2" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/category/8223796/2</a>?</p><p><a href="https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html" target="_blank" rel="noopener">https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们软件开发流程大概是下面所示：&lt;/p&gt;
&lt;p&gt;本地开发-&amp;gt;本地自测-&amp;gt;提交代码-&amp;gt;编译发布-&amp;gt;测试人员测试-&amp;gt;提交至生产&lt;/p&gt;
&lt;p&gt;在发布阶段，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有的项目是采用版本控制工具在Linux服务器上拉取对应分支的最
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Nginx单域名配置多Vue工程和PHP接口</title>
    <link href="https://blog.zhimma.com/2019/02/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8CPHP%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/02/01/Nginx单域名配置多Vue工程和PHP接口/</id>
    <published>2019-02-01T07:16:26.000Z</published>
    <updated>2019-03-01T10:06:15.869Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/">点击查看<strong>单域名配置多Vue工程和多PHP接口</strong></a></p><p>项目中遇到了一个问题，需要一个域名完成整个项目的部署，之前是使用的多个域名进行解析的，例如：</p><p>后台页面：<code>backend.domain.com</code>,后台接口：<code>backend-api.domain.com</code></p><p>前台页面：<code>fontend.domain.com</code>,前台接口：<code>fontend-api.domain.com</code></p><p>现在的需求是：<code>domain.com</code>就可以访问到前后台所有页面的接口</p><p>解决思路：<code>Nginx</code>和<code>Vue路由配置</code></p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p><code>vue-cli3.x</code><br>在vue.config.js的文件中加入（此处为了打包后的JS,CSS等文件的路径引向）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  baseUrl:&apos;/frontend/&apos;  //根据www.xxx.com/后面的路径写入（比如www.domain.com/frontend）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/config/#baseurl" target="_blank" rel="noopener">baseUrl官方文档</a></p><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配含有backend的</span></span><br><span class="line"><span class="attribute">location</span> /backend &#123;</span><br><span class="line">    <span class="comment"># 重新定义root目录</span></span><br><span class="line">    <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web;</span><br><span class="line">    <span class="comment"># 或者</span></span><br><span class="line">    <span class="comment"># alias /Users/zhimma/Data/www/MK_Project/public/web/backend;</span></span><br><span class="line">    <span class="comment"># 解决刷新页面404错误</span></span><br><span class="line">    <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 尝试t尝试列出的文件并设置内部文件指向。</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-配置"><a href="#PHP-配置" class="headerlink" title="PHP 配置"></a>PHP 配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrite</span>; </span><br><span class="line"><span class="attribute">location</span> <span class="variable">@rewrite</span> &#123; </span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /index.php?_url=/<span class="variable">$1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php</span> &#123; </span><br><span class="line"><span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line"><span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line"></span><br><span class="line"><span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> PATH_INFO <span class="variable">$fastcgi_path_info</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_path_info</span>; </span><br><span class="line"><span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>; </span><br><span class="line"><span class="attribute">include</span> fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> mk.ma;</span><br><span class="line">    <span class="attribute">index</span>       index.php index.html index default;</span><br><span class="line">    <span class="attribute">root</span>        /Users/zhimma/Data/www/MK_Project/public;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@rewrite</span>; </span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@rewrite</span> &#123; </span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /index.php?_url=/<span class="variable">$1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php</span> &#123; </span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">        <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">         </span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_INFO <span class="variable">$fastcgi_path_info</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_TRANSLATED <span class="variable">$document_root</span><span class="variable">$fastcgi_path_info</span>; </span><br><span class="line">        <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>; </span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment"># 匹配含有backend的</span></span><br><span class="line">    <span class="attribute">location</span> /backend &#123;</span><br><span class="line">        <span class="comment"># 重新定义root目录</span></span><br><span class="line">        <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web;</span><br><span class="line">        <span class="comment"># 或者</span></span><br><span class="line">        <span class="comment"># alias /Users/zhimma/Data/www/MK_Project/public/web/backend;</span></span><br><span class="line">        <span class="comment"># 解决刷新页面404错误</span></span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 尝试t尝试列出的文件并设置内部文件指向。</span></span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /frontend &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/MK_Project/public/web/frontend;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /frontend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /favicon.ico &#123;</span><br><span class="line">        <span class="attribute">root</span> /Users/zhimma/Data/www/MK_Project/public/web/backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后解析域名，访问地址就只需要一个</p><p>后台：<code>domain.com/backend</code></p><p>前台：<code>domain.com/frontend</code></p><p>接口地址统一调用：<code>domain.com</code></p><p>总结一下：</p><p>Nginx功能很强大，下一步需要彻底弄懂<strong>Nginx</strong>的一些配置项，方便项目的一些需求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/categories/Vue/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Docker相关知识再整理(1)</title>
    <link href="https://blog.zhimma.com/2019/01/28/Docker%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%86%8D%E6%95%B4%E7%90%86(1)/"/>
    <id>https://blog.zhimma.com/2019/01/28/Docker相关知识再整理(1)/</id>
    <published>2019-01-28T07:05:03.000Z</published>
    <updated>2019-02-01T07:17:16.271Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>个人理解为是创建容器的基础，类似于安装系统是所需的ISO文件，镜像就是生成容器所需的ISO。</p><h3 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><h5 id="列出镜像-不显示中间层镜像"><a href="#列出镜像-不显示中间层镜像" class="headerlink" title="列出镜像-不显示中间层镜像"></a>列出镜像-不显示中间层镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls</span><br><span class="line">REPOSITORY           TAG          IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                latest       42b4762643dc        5 days ago          109MB</span><br></pre></td></tr></table></figure><blockquote><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>    </p></blockquote><blockquote><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong></p></blockquote><h5 id="所有镜像："><a href="#所有镜像：" class="headerlink" title="所有镜像："></a>所有镜像：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls -a</span><br></pre></td></tr></table></figure><h5 id="特定格式显示镜像列表"><a href="#特定格式显示镜像列表" class="headerlink" title="特定格式显示镜像列表"></a>特定格式显示镜像列表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls -q</span><br><span class="line">42b4762643dc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br><span class="line">5f515359c7f8: redis</span><br></pre></td></tr></table></figure><h4 id="查看镜像、容器、数据卷所占用的空间"><a href="#查看镜像、容器、数据卷所占用的空间" class="headerlink" title="查看镜像、容器、数据卷所占用的空间"></a>查看镜像、容器、数据卷所占用的空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE           RECLAIMABLE</span><br><span class="line">Images              14                  13                  1.347GB        211.8MB (15%)</span><br><span class="line">Containers          23                  22                  4.962kB        0B (0%)</span><br><span class="line">Local Volumes       0                   0                   0B             0B</span><br><span class="line">Build Cache         0                   0                   0B             0B</span><br></pre></td></tr></table></figure><h4 id="悬浮镜像清理"><a href="#悬浮镜像清理" class="headerlink" title="悬浮镜像清理"></a>悬浮镜像清理</h4><p>无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image prune</span><br><span class="line">WARNING! This will remove all dangling images.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Total reclaimed space: 0B</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有镜像</span></span><br><span class="line">docker image rm $(docker image ls -q)</span><br></pre></td></tr></table></figure><h4 id="保存容器为镜像"><a href="#保存容器为镜像" class="headerlink" title="保存容器为镜像"></a>保存容器为镜像</h4><p>运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker commit \</span><br><span class="line">    --author <span class="string">"Nanme &lt;Email&gt;"</span> \</span><br><span class="line">    --message <span class="string">"Description"</span> \</span><br><span class="line">        webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容、</p></blockquote><p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样</p><blockquote><p>镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></blockquote><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>一个集中的存储、分发镜像的服务，<a href="https://docker_practice.gitee.io/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像</p><blockquote><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p></blockquote><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p>###FROM</p><p><code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一，</p><p>其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p></li><li><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li></ul><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p><p>​    </p><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="bash">COPY hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等</p></blockquote><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在 Docker 官方的 <a href="https://docker_practice.gitee.io/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要<strong>自动解压缩</strong>的场合。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /mydir/</span></span><br></pre></td></tr></table></figure><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，用法如下面的格式<code>$KEY</code></p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h2&gt;&lt;p&gt;Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Mac" scheme="https://blog.zhimma.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>1-Mac-Docker-Kubernetes-Rancher-环境初始化</title>
    <link href="https://blog.zhimma.com/2019/01/25/1-Mac-Docker-Kubernetes-Rancher-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://blog.zhimma.com/2019/01/25/1-Mac-Docker-Kubernetes-Rancher-环境初始化/</id>
    <published>2019-01-25T04:01:43.000Z</published>
    <updated>2019-02-19T01:39:31.625Z</updated>
    
    <content type="html"><![CDATA[<p><code>composer install --ignore-platform-reqs</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;composer install --ignore-platform-reqs&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Mac" scheme="https://blog.zhimma.com/tags/Mac/"/>
    
      <category term="k8s" scheme="https://blog.zhimma.com/tags/k8s/"/>
    
      <category term="Rancher" scheme="https://blog.zhimma.com/tags/Rancher/"/>
    
  </entry>
  
  <entry>
    <title>CLI&amp;Swoole Model</title>
    <link href="https://blog.zhimma.com/2018/11/30/CLI&amp;Swoole%20Model/"/>
    <id>https://blog.zhimma.com/2018/11/30/CLI&amp;Swoole Model/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-01-24T09:10:29.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p><code>php index.php FEE3D9650A692CB93FF43DE7267BDBD0/Customer/Api/Pay/Address/index/id/1/name/222</code></p><blockquote><p>获取参数<code>$_SERVER[&#39;PARAMS&#39;]</code></p></blockquote><h3 id="Swoole"><a href="#Swoole" class="headerlink" title="Swoole"></a>Swoole</h3><p><code>trunk/ThinkPHP/Library/Think/App.class.php    line:98</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strtolower($_SERVER[<span class="string">'CY_REQUEST_URI'</span>]) == <span class="string">'swoole/server/swooleserver'</span>) &#123;</span><br><span class="line">    $class = <span class="string">''</span>;</span><br><span class="line">    $array = explode(<span class="string">'/'</span>, $_SERVER[<span class="string">'CY_REQUEST_URI'</span>]);</span><br><span class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $name) &#123;</span><br><span class="line">        $class .= <span class="string">'\\'</span>.parse_name($name, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h4><p>启动swoole 服务:<code>php index.php Swoole/Server/SwooleServer</code></p><p>投递异步任务</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> SwooleClient())-&gt;handle([</span><br><span class="line"><span class="string">'class'</span> =&gt;  <span class="string">'Swoole\Process\Customer\Export'</span>,</span><br><span class="line"><span class="string">'params'</span> =&gt; [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'zhimma'</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CLI&quot;&gt;&lt;a href=&quot;#CLI&quot; class=&quot;headerlink&quot; title=&quot;CLI&quot;&gt;&lt;/a&gt;CLI&lt;/h3&gt;&lt;h4 id=&quot;执行&quot;&gt;&lt;a href=&quot;#执行&quot; class=&quot;headerlink&quot; title=&quot;执行&quot;&gt;&lt;/a&gt;执行&lt;/h4&gt;&lt;p
      
    
    </summary>
    
      <category term="PHP" scheme="https://blog.zhimma.com/categories/PHP/"/>
    
    
      <category term="Swoole" scheme="https://blog.zhimma.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7☞lnmp环境搭建</title>
    <link href="https://blog.zhimma.com/2018/11/30/CentOS7%E2%98%9Elnmp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.zhimma.com/2018/11/30/CentOS7☞lnmp环境搭建/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-02-12T06:46:06.957Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自<a href="https://mos.meituan.com/library/18/how-to-install-lnmp-on-centos7/" target="_blank" rel="noopener">这里</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。</p><p>本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。</p><p>本教程适用于CentOS 7.x版本。<br><a id="more"></a></p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><hr><p><code>yum install nginx</code></p><blockquote><p>如果报没有可用的软件包nginx错误，解决方法这<a href="https://blog.zhimma.com/2018/11/30/%E6%B2%A1%E6%9C%89%E5%8F%AF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85nginx/">这里</a></p></blockquote><p>按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx：<br><code>systemctl start nginx</code></p><p>检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。<br><code>systemctl status firewalld</code></p><p>如果显示active (running)，则需要调整防火墙规则的配置。</p><p>修改/etc/firewalld/zones/public.xml文件，在zone一节中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;zone&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;service name=&quot;nginx&quot;/&gt;</span><br><span class="line">&lt;zone&gt;</span><br></pre></td></tr></table></figure></p><p>保存后重新加载firewalld服务：<code>systemctl reload firewalld</code></p><p>可以通过浏览器访问 http://&lt;外网IP地址&gt; 来确定Nginx是否已经启动。</p><p>最后将Nginx设置为开机启动：<code>systemctl enable nginx.service</code></p><blockquote><p>测试环境的话，为了方便也可以先禁用掉防火墙</p></blockquote><h2 id="安装MySQL-MariaDB"><a href="#安装MySQL-MariaDB" class="headerlink" title="安装MySQL(MariaDB)"></a>安装MySQL(MariaDB)</h2><p><a href="https://my.oschina.net/Laily/blog/713023" target="_blank" rel="noopener">https://my.oschina.net/Laily/blog/713023</a></p><hr><p>MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。</p><p>我们可以使用yum直接安装MariaDB：<br><code>yum install mariadb-server</code></p><p>安装完成之后，执行以下命令重启MariaDB服务： <code>systemctl start mariadb</code></p><p>MariaDB默认root密码为空，我们需要设置一下，执行脚本：<code>/usr/bin/mysql_secure_installation</code></p><p>首先提示输入当前的root密码：<br><code>Enter current password for root (enter for none):</code></p><p>初始root密码为空，我们直接敲回车进行下一步<br><code>Set root password? [Y/n]</code></p><p>设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码<br><code>Remove anonymous users? [Y/n]</code></p><p>是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续<br><code>Disallow root login remotely? [Y/n]</code></p><p>是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续<br><code>Remove test database and access to it? [Y/n]</code></p><p>是否删除测试用的数据库和权限？ 建议按照默认设置，回车继续<br><code>Reload privilege tables now? [Y/n]</code></p><p>是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。</p><p>完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB：<code>mysql -uroot -p</code></p><p>按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。</p><p>最后我们将MariaDB设置为开机启动<code>systemctl enable mariadb</code></p><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><hr><p><a href="https://www.yaosansi.com/post/install-php-yum-on-centos/" target="_blank" rel="noopener">https://www.yaosansi.com/post/install-php-yum-on-centos/</a><br>我们可以直接使用yum安装PHP：<code>yum install php-fpm php-mysql</code></p><p>安装完成后我们将php-fpm启动：<code>systemctl start php-fpm</code></p><p>将php-fpm设置为开机启动: <code>systemctl enable php-fpm</code></p><p>php安装完成之后，需要设置一下php session的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/lib/php/session/</span><br><span class="line">sudo chown -R apache:apache /var/lib/php/session/</span><br></pre></td></tr></table></figure></p><p>这时php-fpm已经安装完毕，但是现在需要配置一下Nginx，在/etc/nginx/conf.d目录中新建一个名为php.conf的文件，其内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root           /usr/share/php;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行以下命令使我们的配置生效：<code>systemctl reload nginx</code></p><p>以上我们配置了Nginx的8000端口用来测试，如果您在美团云控制台创建机器时选择了绑定防火墙，需要检查该防火墙是否允许80端口，如果不允许的话，可以在防火墙设置中新增防火墙，并关联到该主机。</p><p>我们在/usr/share/php目录下新建一个名为phpinfo.php的文件用来展示phpinfo信息，文件内容为：</p><p><code>&lt;?php echo phpinfo(); ?&gt;</code></p><p>我们从浏览器打开 http://&lt;外网IP地址&gt;:80/phpinfo.php，您就能看到phpinfo信息了，说明我们php环境已经部署成功;</p><h2 id="升级PHP版本"><a href="#升级PHP版本" class="headerlink" title="升级PHP版本"></a>升级PHP版本</h2><hr><p>yum 默认安装的版本是5.4，现在升级PHP版本至5.6</p><p>执行下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</span><br><span class="line"></span><br><span class="line">rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span><br></pre></td></tr></table></figure></p><p>执行下面的命令删除php<br><code>yum remove php-common</code><br>然后像安装那样问你是否继续的，输入yes即可</p><p>安装php5.6</p><p><code>yum install -y php56w php56w-opcache php56w-xml php56w-fpm php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring</code></p><p>查看php版本<code>php-fpm --version</code></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br><span class="line">systemctl restart mariadb</span><br><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自&lt;a href=&quot;https://mos.meituan.com/library/18/how-to-install-lnmp-on-centos7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。&lt;/p&gt;
&lt;p&gt;本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。&lt;/p&gt;
&lt;p&gt;本教程适用于CentOS 7.x版本。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.zhimma.com/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://blog.zhimma.com/tags/CentOS/"/>
    
      <category term="LNMP" scheme="https://blog.zhimma.com/tags/LNMP/"/>
    
  </entry>
  
  <entry>
    <title>AJAX解决跨域问题（Access-Control-Allow-Origin）</title>
    <link href="https://blog.zhimma.com/2018/11/30/AJAX%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%88Access-Control-Allow-Origin%EF%BC%89/"/>
    <id>https://blog.zhimma.com/2018/11/30/AJAX解决跨域问题（Access-Control-Allow-Origin）/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-02-01T07:34:14.703Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到过跨域的问题,一直觉得很神秘,也没有多关注,就过去了,今天又看到几篇文章说跨域,闲来无事于是将其整理记录下来；</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>先来阐述下几个概念:</p><p><strong>跨域</strong>:是指浏览器对于JavaScript的同源策略限制,只要协议、域名、端口有任何一个不同,都被当作是不同的域,都不能执行或获取其他网站的资源；</p><p>姑且这么定义吧,举个简单例子,就是<a href="http://www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误" target="_blank" rel="noopener">www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误</a></p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/JavaScript/error1.png" alt="image"></p><a id="more"></a><p>有没有跨域,判断是不是属于跨域,可以参考下面:</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js</a> 调用 <a href="http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/script/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名,不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="https://www.a.com/b.js" target="_blank" rel="noopener">https://www.a.com/b.js</a></td><td>同一域名,不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://70.32.92.74/b.js" target="_blank" rel="noopener">http://70.32.92.74/b.js</a></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://script.a.com/b.js" target="_blank" rel="noopener">http://script.a.com/b.js</a></td><td>主域相同,子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a> 调用 <a href="http://a.com/b.js" target="_blank" rel="noopener">http://a.com/b.js</a> 同一域名,不同二级域名（同上）</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js</a> 调用 <a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><p><strong>CORS</strong>:<strong>CORS（Cross-Origin Resource Sharing）跨域资源共享</strong>,定义了必须在访问跨域资源时,浏览器与服务器应该如何沟通.CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是失败.</p><p>服务器端对于<strong>CORS</strong>的支持,主要就是通过设置<strong>Access-Control-Allow-Origin</strong>来进行的.如果浏览器检测到相应的设置,就可以允许Ajax进行跨域的访问.</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Solution-1-服务端程序解决"><a href="#Solution-1-服务端程序解决" class="headerlink" title="Solution 1:服务端程序解决"></a>Solution 1:服务端程序解决</h3><p>如果是双方预定沟通好请求允许数据,可以在服务端添加header头来解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header( &quot;Access-Control-Allow-Origin:*&quot; );</span><br><span class="line"></span><br><span class="line">header( &quot;Access-Control-Allow-Methods:POST,GET&quot; );</span><br></pre></td></tr></table></figure><p>看下面的例子:</p><p>客户端 <a href="http://www.client.com/cliend.html" target="_blank" rel="noopener">www.client.com/cliend.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt; 跨域测试 &lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button style=&quot;width:100px&quot;&gt;click client&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(&quot;button&quot;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://www.server.com/server.php&quot;,</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            data: &#123;&apos;text&apos;: &apos;hello world&apos;&#125;,</span><br><span class="line">            success: function (msg) &#123;</span><br><span class="line">                $(&quot;button&quot;).html(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//允许所有域名获取数据</span><br><span class="line">&lt;?php</span><br><span class="line">$text = $_POST[&apos;text&apos;];</span><br><span class="line">//允许所有的域名</span><br><span class="line">header(&apos;content-type:application:json;charset=utf8&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);  </span><br><span class="line">header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);</span><br><span class="line">echo json_encode($text);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//允许制定域名获取数据</span><br><span class="line">&lt;?php</span><br><span class="line">$text = $_POST[&apos;text&apos;];</span><br><span class="line">header(&apos;content-type:application:json;charset=utf8&apos;);</span><br><span class="line">$origin = isset($_SERVER[&apos;HTTP_ORIGIN&apos;]) ? $_SERVER[&apos;HTTP_ORIGIN&apos;] : &apos;&apos;;</span><br><span class="line">//允许指定域名</span><br><span class="line">$allow_origin = [</span><br><span class="line">    &apos;http://www.client.com&apos;,</span><br><span class="line">    &apos;http://www.client2.com&apos;</span><br><span class="line">];</span><br><span class="line">if (in_array($origin, $allow_origin)) &#123;</span><br><span class="line">    header(&apos;Access-Control-Allow-Origin:&apos; . $origin);</span><br><span class="line">    header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);</span><br><span class="line">    header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);</span><br><span class="line">&#125;</span><br><span class="line">echo json_encode($text);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这样,理论上就可以解决跨域问题:</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/JavaScript/success%60.png" alt="image"></p><h3 id="Solution-2-代理模式"><a href="#Solution-2-代理模式" class="headerlink" title="Solution 2:代理模式"></a>Solution 2:代理模式</h3><p>解决思路:<br>例如 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a> 需要调用 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a> ,可以写一个接口 <a href="http://www.client.com/server.php" target="_blank" rel="noopener">www.client.com/server.php</a> ,由这个接口在后端去调用 <a href="http://www.server.com/server.php" target="_blank" rel="noopener">www.server.com/server.php</a> 并拿到返回值,然后再返回给index.html,这就是一个代理的模式.相当于绕过了浏览器端,自然就不存在跨域问题.</p><h3 id="Solution-3-使用JSONP"><a href="#Solution-3-使用JSONP" class="headerlink" title="Solution 3:使用JSONP"></a>Solution 3:使用JSONP</h3><p>使用之前,建议去看下我的另一篇文章<a href="https://blog.bytesclub.com/2017/06/12/JSON%E5%92%8CJSONP/" target="_blank" rel="noopener">Json和JsonP</a>,然后再过来实践；</p><p>还是直接上代码:</p><p>客户端 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt; 跨域测试 &lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;clickMe&quot; style=&quot;width:100px&quot;&gt;click get jsonP&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(&quot;#clickMe&quot;).click(function () &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://www.server.com/jsonP.json&quot;,</span><br><span class="line">            type: &quot;post&quot;,</span><br><span class="line">            dataType: &quot;jsonP&quot;,</span><br><span class="line">            data: &#123;&apos;text&apos;: &apos;hello world&apos;&#125;,</span><br><span class="line">            jsonpCallback: &apos;returnData&apos;,  //可自定义 函数名</span><br><span class="line">            success: function (msg) &#123;</span><br><span class="line">                alert(msg.text);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (XMLHttpRequest, textStatus, errorThrown) &#123;</span><br><span class="line">                alert(XMLHttpRequest.status);</span><br><span class="line">                alert(XMLHttpRequest.readyState);</span><br><span class="line">                alert(textStatus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/jsonP.json" target="_blank" rel="noopener">www.server.com/jsonP.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnData(&#123;&quot;text&quot;:&quot;hello jsonP&quot;&#125;);</span><br></pre></td></tr></table></figure><p>同样的也可以跨域获取数据</p><h2 id="Solution-4-使用html5-API-postMessage-转自这里"><a href="#Solution-4-使用html5-API-postMessage-转自这里" class="headerlink" title="Solution 4:使用html5 API postMessage(转自这里)"></a>Solution 4:<a href="http://blog.xieliqun.com/2016/08/25/postMessage-cross-domain/" target="_blank" rel="noopener">使用html5 API postMessage(转自这里)</a></h2><p>客户端 <a href="http://www.client.com/client.html" target="_blank" rel="noopener">www.client.com/client.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;iframe style=&quot;display: none&quot; src=&quot;http://www.server.com/server.html&quot; name=&quot;postIframe&quot; onload=&quot;messageLoad()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function messageLoad() &#123;</span><br><span class="line">        var url = &quot;http://www.server.com&quot;;</span><br><span class="line">        window.postIframe.postMessage(&quot;给我tsort的信息&quot;, url); //发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    window.onmessage = function (e) &#123;</span><br><span class="line">        e = e || event;</span><br><span class="line">        console.log(e.data); //接收b返回的数据,在控制台有两次输出</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器端 <a href="http://www.server.com/server.html" target="_blank" rel="noopener">www.server.com/server.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onmessage = function(e)&#123;</span><br><span class="line">        e = e || event;</span><br><span class="line">        alert(e.data); //立即弹出a发送过来的数据</span><br><span class="line">        e.source.postMessage(&quot;好的,请稍等三秒！&quot;,e.origin); //立即回复a</span><br><span class="line"></span><br><span class="line">        var postData = &#123;name:&quot;tsrot&quot;,age:24&#125;;</span><br><span class="line">        var strData = JSON.stringify(postData); //json对象转化为字符串</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            e.source.postMessage(strData,e.origin);</span><br><span class="line">        &#125;,3000); //3秒后向a发送数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇到过跨域的问题,一直觉得很神秘,也没有多关注,就过去了,今天又看到几篇文章说跨域,闲来无事于是将其整理记录下来；&lt;/p&gt;
&lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a&gt;一些概念&lt;/h2&gt;&lt;p&gt;先来阐述下几个概念:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨域&lt;/strong&gt;:是指浏览器对于JavaScript的同源策略限制,只要协议、域名、端口有任何一个不同,都被当作是不同的域,都不能执行或获取其他网站的资源；&lt;/p&gt;
&lt;p&gt;姑且这么定义吧,举个简单例子,就是&lt;a href=&quot;http://www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.client.com网站上的程序不能从www.server.com网站上获取数据,如果强行获取,则会报出下面错误&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/JavaScript/error1.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://blog.zhimma.com/categories/JavaScript/"/>
    
    
      <category term="Cors" scheme="https://blog.zhimma.com/tags/Cors/"/>
    
  </entry>
  
  <entry>
    <title>Centos7中，PHP7下，扩展的安装</title>
    <link href="https://blog.zhimma.com/2018/11/30/Centos7%E4%B8%AD%EF%BC%8CPHP7%E4%B8%8B%EF%BC%8C%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://blog.zhimma.com/2018/11/30/Centos7中，PHP7下，扩展的安装/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-02-01T07:34:13.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CentOS 下，PHP有多种方式来安装拓展， 主要有 包管理式的 yum 安装、pecl 安装， 以及源码编译安装。<br>包管理式的安装卸载尤为方便，而源码编译式的安装则方便参数调优。<br>一般搭建本机开发环境推荐包管理式的安装，节约时间。而线上部署环境则推荐编译安装， 方便调优。 </p></blockquote><h2 id="环境和准备"><a href="#环境和准备" class="headerlink" title="环境和准备"></a>环境和准备</h2><hr><ul><li>环境 ： windows10</li><li>PHP版本：7.0.13</li><li>Nginx: 1.10.3</li><li>Centos: docker 创建的CentOS容器[CentOS Linux release 7.3.1611 (Core) ]</li><li>全程墙外网<h2 id="方式1：-yum-安装扩展（mongodb）"><a href="#方式1：-yum-安装扩展（mongodb）" class="headerlink" title="方式1： yum 安装扩展（mongodb）"></a>方式1： yum 安装扩展（mongodb）</h2></li></ul><hr><a id="more"></a><p>yum方式安装能自动安装扩展的.so动态库，并配置好php.ini</p><p><code>yum search mongodb|grep php  //搜索到拓展名为 php70w-pecl-mongodb</code></p><p>等待自动安装完成后，查看phpinfo</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/QQ%E6%88%AA%E5%9B%BE20170408234049.png" alt="mongodb"></p><p>到此 yum 安装扩展方法介绍完毕</p><h2 id="pecl-安装（redis）"><a href="#pecl-安装（redis）" class="headerlink" title="pecl 安装（redis）"></a>pecl 安装（redis）</h2><hr><p>pecl 安装需要准备2个文件：phpize ，php-config</p><h3 id="查找phpize的位置"><a href="#查找phpize的位置" class="headerlink" title="查找phpize的位置"></a><strong>查找phpize的位置</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc conf.d]# whereis phpize</span><br><span class="line">phpize: /usr/bin/phpize</span><br></pre></td></tr></table></figure><h3 id="查找php-config的位置"><a href="#查找php-config的位置" class="headerlink" title="查找php-config的位置"></a><strong>查找php-config的位置</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc conf.d]# whereis php-config</span><br><span class="line">php-config:[root@9e2c60482bdc conf.d]#</span><br></pre></td></tr></table></figure><p>发现没有php-config，先测试运行下phpize  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php-config:[root@9e2c60482bdc conf.d]# phpize</span><br><span class="line">Can t find PHP headers in /usr/include/php</span><br><span class="line">The php-devel package is required for use of this command.</span><br></pre></td></tr></table></figure><p>直接报错，接下来安装php-devel解决上面报错<code>yum install php70w-devel</code><br>​<br>再次运行phpize,没有报找不到的错误，出现了下面的报错：<br>​     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc bin]# phpize</span><br><span class="line">Cannot find config.m4. </span><br><span class="line">Make sure that you run /usr/bin/phpize in the top level source directory of the module</span><br></pre></td></tr></table></figure><p>先不管他，进行下一步的操作</p><h3 id="更新-pear（非必须）"><a href="#更新-pear（非必须）" class="headerlink" title="更新 pear（非必须）"></a><strong>更新 pear（非必须）</strong></h3><p>我们需要先从pear官网下载 go-pear 工具,这个工具将帮我们同时安装 pecl包管理器(管理php的C拓展) pear包管理器(管理php类库)；<br>​<br><code>wget http://pear.php.net/go-pear.phar</code><br>​<br>下载完成后安装工具，运行下面命令：<code>php go-pear.phar</code>，<img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/gopear.png" alt="go-pear"></p><p>然后默认回车即可，暂时没搞懂这些参数的意思，估计是配置路经相关吧，先回车再说；</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/gopear.png" alt="go-pear"></p><h3 id="安装扩展（1）"><a href="#安装扩展（1）" class="headerlink" title="安装扩展（1）"></a><strong>安装扩展（1）</strong></h3><p>搜索扩展包：<code>pecl search redis</code></p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl search redis</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in Command.php on line 249</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">Warning: Invalid argument supplied for foreach() in PEAR/Command.php on line 249</span><br><span class="line"></span><br><span class="line">Warning: Invalid argument supplied for foreach() in /usr/share/pear/PEAR/Command.php on line 249</span><br><span class="line">XML Extension not found</span><br></pre></td></tr></table></figure><p>​<br>刷刷的报错了，查询错误后贴出解决方法：</p><p><a href="http://serverfault.com/questions/589877/pecl-command-produces-long-list-of-errors" target="_blank" rel="noopener">解决方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/pecl  //文件最后一行去掉 -n 参数</span><br></pre></td></tr></table></figure><p>再次搜索，  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl search redis</span><br><span class="line">Retrieving data...0%</span><br><span class="line">Matched packages, channel pecl.php.net:</span><br><span class="line">=======================================</span><br><span class="line">Package Stable/(Latest) Local</span><br><span class="line">redis   3.1.2 (stable)        PHP extension for interfacing with Redis</span><br></pre></td></tr></table></figure><p>安装扩展包<code>pecl install mongodb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# pecl install redis</span><br><span class="line">downloading redis-3.1.2.tgz ...</span><br><span class="line">Starting to download redis-3.1.2.tgz (199,041 bytes)</span><br><span class="line">.................done: 199,041 bytes</span><br><span class="line">20 source files, building</span><br><span class="line">running: phpize</span><br><span class="line">Configuring for:</span><br><span class="line">PHP Api Version:         20151012</span><br><span class="line">Zend Module Api No:      20151012</span><br><span class="line">Zend Extension Api No:   320151012</span><br><span class="line">building in /tmp/pear/install/pear-build-rootLPns3m/redis-3.1.2</span><br><span class="line">running: /tmp/pear/install/redis/configure --with-php-config=/usr/bin/php-config</span><br><span class="line">checking for grep that handles long lines and -e... /usr/bin/grep</span><br><span class="line">checking for egrep... /usr/bin/grep -E</span><br><span class="line">checking for a sed that does not truncate output... /usr/bin/sed</span><br><span class="line">checking for cc... no</span><br><span class="line">checking for gcc... no</span><br><span class="line">configure: error: in /tmp/pear/install/pear-build-rootLPns3m/redis-3.1.2:</span><br><span class="line">configure: error: no acceptable C compiler found in $PATH</span><br><span class="line">See &apos;config.log&apos; for more details</span><br><span class="line">ERROR: &apos;/tmp/pear/install/redis/configure --with-php-config=/usr/bin/php-config&apos; failed</span><br></pre></td></tr></table></figure><p>刷刷的报错了，查询错误后贴出解决方法:<code>yun install gcc gcc+</code></p><h3 id="安装扩展（2）"><a href="#安装扩展（2）" class="headerlink" title="安装扩展（2）"></a><strong>安装扩展（2）</strong></h3><p>执行：<code>pecl install monodb</code> </p><p>等待自动安装完成后，显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Build process completed successfully</span><br><span class="line">Installing &apos;/usr/lib64/php/modules/redis.so&apos;</span><br><span class="line">install ok: channel://pecl.php.net/redis-3.1.2</span><br><span class="line">configuration option &quot;php_ini&quot; is not set to php.ini location</span><br><span class="line">You should add &quot;extension=redis.so&quot; to php.ini</span><br></pre></td></tr></table></figure><p>​<br>然后在php配置文件中稍作修改，将extension=redis.so添加到php.ini中,重启PHP,查看phpinfo</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/redis.png" alt="redis"></p><p>到此 pecl 安装扩展方法介绍完毕</p><h2 id="源码编译安装（Seaslog）"><a href="#源码编译安装（Seaslog）" class="headerlink" title="源码编译安装（Seaslog）"></a>源码编译安装（Seaslog）</h2><hr><p><a href="https://github.com/Neeke/SeasLog/blob/master/README_zh.md" target="_blank" rel="noopener">Seaslog文档</a></p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a><strong>安装git</strong></h3><p>先安装<a href="https://blog.bytesclub.com/2017/02/06/%E5%B8%B8%E7%94%A8%E7%9A%84git/" target="_blank" rel="noopener">git</a>，克隆Seaslog源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@9e2c60482bdc test]# git clone https://github.com/Neeke/SeasLog.git</span><br><span class="line">Cloning into &apos;SeasLog&apos;...</span><br><span class="line">remote: Counting objects: 1094, done.</span><br><span class="line">remote: Total 1094 (delta 0), reused 0 (delta 0), pack-reused 1094</span><br><span class="line">Receiving objects: 100% (1094/1094), 1.04 MiB | 24.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (628/628), done.</span><br></pre></td></tr></table></figure><h3 id="安装Seaslog"><a href="#安装Seaslog" class="headerlink" title="安装Seaslog"></a><strong>安装Seaslog</strong></h3><p>进入Seaslog目录，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /path/to/phpize  //更换自己对应的目录</span><br><span class="line">$ ./configure --with-php-config=/path/to/php-config</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>完成之后，修改php配置文件，将extension = seaslog.so添加到php.ini中,重启PHP,查看phpinfo<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/PHP7/seaslog.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此Linux中,给PHP安装扩展的3种方式记录完毕,特此总结</p><ol><li><a href="https://my.oschina.net/u/2400083/blog/518195" target="_blank" rel="noopener">参考1</a></li><li><a href="https://segmentfault.com/a/1190000008993194" target="_blank" rel="noopener">参考2</a></li><li><a href="https://segmentfault.com/a/1190000008993194" target="_blank" rel="noopener">peal官网</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CentOS 下，PHP有多种方式来安装拓展， 主要有 包管理式的 yum 安装、pecl 安装， 以及源码编译安装。&lt;br&gt;包管理式的安装卸载尤为方便，而源码编译式的安装则方便参数调优。&lt;br&gt;一般搭建本机开发环境推荐包管理式的安装，节约时间。而线上部署环境则推荐编译安装， 方便调优。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境和准备&quot;&gt;&lt;a href=&quot;#环境和准备&quot; class=&quot;headerlink&quot; title=&quot;环境和准备&quot;&gt;&lt;/a&gt;环境和准备&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;环境 ： windows10&lt;/li&gt;
&lt;li&gt;PHP版本：7.0.13&lt;/li&gt;
&lt;li&gt;Nginx: 1.10.3&lt;/li&gt;
&lt;li&gt;Centos: docker 创建的CentOS容器[CentOS Linux release 7.3.1611 (Core) ]&lt;/li&gt;
&lt;li&gt;全程墙外网&lt;h2 id=&quot;方式1：-yum-安装扩展（mongodb）&quot;&gt;&lt;a href=&quot;#方式1：-yum-安装扩展（mongodb）&quot; class=&quot;headerlink&quot; title=&quot;方式1： yum 安装扩展（mongodb）&quot;&gt;&lt;/a&gt;方式1： yum 安装扩展（mongodb）&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.zhimma.com/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://blog.zhimma.com/tags/CentOS/"/>
    
      <category term="PHP" scheme="https://blog.zhimma.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS中PHP7的安装</title>
    <link href="https://blog.zhimma.com/2018/11/30/CentOS%E4%B8%ADPHP7%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://blog.zhimma.com/2018/11/30/CentOS中PHP7的安装/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-01-24T09:10:06.454Z</updated>
    
    <content type="html"><![CDATA[<p>本文安装参考<a href="https://webtatic.com/packages/php70/" target="_blank" rel="noopener">这里</a>，并且全程墙外网;</p><hr><h2 id="查看Linux版本"><a href="#查看Linux版本" class="headerlink" title="查看Linux版本"></a>查看Linux版本</h2><pre><code>cat /etc/centos-releaseCentOS Linux release 7.3.1611 (Core)</code></pre><a id="more"></a><h2 id="删除之前的-PHP-版本"><a href="#删除之前的-PHP-版本" class="headerlink" title="删除之前的 PHP 版本"></a>删除之前的 PHP 版本</h2><pre><code>yum remove php* php-common //如果存在其他版本删除原来的版本  </code></pre><h2 id="rpm-安装-Php7-相应的-yum源"><a href="#rpm-安装-Php7-相应的-yum源" class="headerlink" title="rpm 安装 Php7 相应的 yum源"></a>rpm 安装 Php7 相应的 yum源</h2><pre><code>rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</code></pre><h2 id="yum安装PHP7"><a href="#yum安装PHP7" class="headerlink" title="yum安装PHP7"></a>yum安装PHP7</h2><pre><code>yum install php70w-fpm php70w-opcache</code></pre><h2 id="查看PHP版本"><a href="#查看PHP版本" class="headerlink" title="查看PHP版本"></a>查看PHP版本</h2><pre><code>php -v / php-fpm -v</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><table><thead><tr><th style="text-align:center">Package</th><th style="text-align:center">Provides</th></tr></thead><tbody><tr><td style="text-align:center">Package</td><td style="text-align:center">Provides</td></tr><tr><td style="text-align:center">php70w</td><td style="text-align:center">mod_php, php70w-zts</td></tr><tr><td style="text-align:center">php70w-bcmath</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-cli</td><td style="text-align:center">php-cgi, php-pcntl, php-readline</td></tr><tr><td style="text-align:center">php70w-common</td><td style="text-align:center">php-api, php-bz2, php-calendar, php-ctype, php-curl, php-date, php-exif, php-fileinfo,php-filter,php-ftp,php-gettext,php-gmp, php-hash, php-iconv, php-json, php-libxml, php-openssl,php-pcre,php-spl,php-tokenizer, php-zend-abi, php-zip, php-zlib</td></tr><tr><td style="text-align:center">php70w-dba</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-devel</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-embedded</td><td style="text-align:center">php-embedded-devel</td></tr><tr><td style="text-align:center">php70w-enchant</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-fpm</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-gd</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-imap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-interbase</td><td style="text-align:center">php_database, php-firebird</td></tr><tr><td style="text-align:center">php70w-intl</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-ldap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mbstring</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mcrypt</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-mysql</td><td style="text-align:center">php-mysqli, php_database</td></tr><tr><td style="text-align:center">php70w-mysqlnd</td><td style="text-align:center">php-mysqli, php_database</td></tr><tr><td style="text-align:center">php70w-odbc</td><td style="text-align:center">php-pdo_odbc, php_database</td></tr><tr><td style="text-align:center">php70w-opcache</td><td style="text-align:center">php70w-pecl-zendopcache</td></tr><tr><td style="text-align:center">php70w-pdo</td><td style="text-align:center">php70w-pdo_sqlite, php70w-sqlite3</td></tr><tr><td style="text-align:center">php70w-pdo_dblib</td><td style="text-align:center">php70w-mssql</td></tr><tr><td style="text-align:center">php70w-pear</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-apcu</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-imagick</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-redis</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pecl-xdebug</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-pgsql</td><td style="text-align:center">php-pdo_pgsql, php_database</td></tr><tr><td style="text-align:center">php70w-phpdbg</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-process</td><td style="text-align:center">php-posix, php-sysvmsg, php-sysvsem, php-sysvshm</td></tr><tr><td style="text-align:center">php70w-pspell</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-recode</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-snmp</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-soap</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-tidy</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">php70w-xml</td><td style="text-align:center">php-dom, php-domxml, php-wddx, php-xsl</td></tr><tr><td style="text-align:center">php70w-xmlrpc</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文安装参考&lt;a href=&quot;https://webtatic.com/packages/php70/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，并且全程墙外网;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;查看Linux版本&quot;&gt;&lt;a href=&quot;#查看Linux版本&quot; class=&quot;headerlink&quot; title=&quot;查看Linux版本&quot;&gt;&lt;/a&gt;查看Linux版本&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;cat /etc/centos-release
CentOS Linux release 7.3.1611 (Core)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.zhimma.com/categories/Linux/"/>
    
    
      <category term="PHP" scheme="https://blog.zhimma.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Git生成多个ssh key</title>
    <link href="https://blog.zhimma.com/2018/11/30/Git%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AAssh-key/"/>
    <id>https://blog.zhimma.com/2018/11/30/Git生成多个ssh-key/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-01-24T09:11:10.419Z</updated>
    
    <content type="html"><![CDATA[<p>当使用了多个不同的git版本控制系统，分别有不同账号时，如一个在github上面有项目，一个在coding或者开源中国上面的有项目时，如果2者的邮箱不同时，就会涉及一个问题，生成的ssh key 会相互覆盖，必然有一个无法使用；</p><p>下面记录下解决方法：<br><a id="more"></a></p><h2 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh-key"></a>生成ssh-key</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建github的ssh key</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/user/username/.ssh/github_rsa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">example：</span><br><span class="line">//我的秘钥保存路径C:\Users\MMA\.ssh\test,邮箱使用your_email@example.com</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/Users/MMA/.ssh/test/github_rsa </span><br><span class="line">//运行之后弹出</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f /c/User/MMA/.ssh/test/test/github_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line"></span><br><span class="line">回车默认即可，出现下面提示，则创建成功</span><br><span class="line"></span><br><span class="line">Your identification has been saved in /c/Users/MMA/.ssh/test/github_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/MMA/.ssh/test/github_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:AjEAqCT5VeTZsdHpklyMIVQQWbBVtAufE/P/GzkEw9I your_email@example.com</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|oo..o+OBBBo.     |</span><br><span class="line">|+.  .+.*.+=.o    |</span><br><span class="line">|+. .. +.+++. E   |</span><br><span class="line">|. .  .  +o.*. o  |</span><br><span class="line">|      . S.= .  . |</span><br><span class="line">|       .   . .. .|</span><br><span class="line">|              .+ |</span><br><span class="line">|               .o|</span><br><span class="line">|               .o|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>查看本地目录，GitHub ssh key生成成功<br><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/github.png" alt="github"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//创建coding的ssh key</span><br><span class="line">ssh-keygen -t rsa -C &quot;my_email@example.com&quot; -f /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line"></span><br><span class="line">和创建github的相似</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;my_email@example.com&quot; -f /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/MMA/.ssh/test/coding_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/MMA/.ssh/test/coding_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:aqcMT/i9ZgXB6aCHus1zdf5JQlrLBYfUnnIBNJ37WIQ my_email@example.com</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|       . o=+ o   |</span><br><span class="line">|      . +. oE .  |</span><br><span class="line">|     o o .o..=   |</span><br><span class="line">|    o . o .o= .  |</span><br><span class="line">|   . .  S.oo.+   |</span><br><span class="line">|  .  . ..=oo. .  |</span><br><span class="line">|   +o +.o++ .    |</span><br><span class="line">|  . +B.+o .o .   |</span><br><span class="line">|     o=oo. .o    |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/git/all.png" alt="github+coding"></p><h2 id="添加私钥到SSH-agent中"><a href="#添加私钥到SSH-agent中" class="headerlink" title="添加私钥到SSH agent中"></a>添加私钥到SSH agent中</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">ssh-add/c/Users/MMA/.ssh/test/github_rsa</span><br></pre></td></tr></table></figure><p>如果执行ssh-add时提示<code>&quot;Could not open a connection to your authentication agent&quot;</code>，可以现执行命令：<code>ssh-agent bash</code></p><p>重新添加即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add /c/Users/MMA/.ssh/test/github_rsa</span><br><span class="line">Identity added: /c/Users/MMA/.ssh/test/github_rsa (/c/Users/MMA/.ssh/test/github_rsa)</span><br><span class="line"></span><br><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line">Identity added: /c/Users/MMA/.ssh/test/coding_rsa (/c/Users/MMA/.ssh/test/coding_rsa)</span><br><span class="line"></span><br><span class="line">MMA@MMA-PC MINGW64 ~/Desktop</span><br><span class="line">$ ssh-add -l</span><br><span class="line">2048 SHA256:aqcMT/i9ZgXB6aCHus1zdf5JQlrLBYfUnnIBNJ37WIQ /c/Users/MMA/.ssh/test/coding_rsa (RSA)</span><br><span class="line">2048 SHA256:AjEAqCT5VeTZsdHpklyMIVQQWbBVtAufE/P/GzkEw9I /c/Users/MMA/.ssh/test/github_rsa (RSA)</span><br></pre></td></tr></table></figure><blockquote><p> // 可以通过 ssh-add -l 来确私钥列表</p><p> ssh-add -l</p><p> // 可以通过 ssh-add -D 来清空私钥列表</p><p> ssh-add -D</p></blockquote><h2 id="修改config文件"><a href="#修改config文件" class="headerlink" title="修改config文件"></a>修改config文件</h2><hr><p>在/c/Users/MMA/.ssh/test 目录下新建一个config文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># coding</span><br><span class="line">Host git.coding.net</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile /c/Users/MMA/.ssh/test/coding_rsa</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile /c/Users/MMA/.ssh/test/github_rsa</span><br></pre></td></tr></table></figure><h2 id="添加公钥到git平台"><a href="#添加公钥到git平台" class="headerlink" title="添加公钥到git平台"></a>添加公钥到git平台</h2><hr><p>[coding教程]<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="noopener">https://coding.net/help/doc/git/ssh-key.html</a>)</p><p>[github教程]<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account" target="_blank" rel="noopener">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用了多个不同的git版本控制系统，分别有不同账号时，如一个在github上面有项目，一个在coding或者开源中国上面的有项目时，如果2者的邮箱不同时，就会涉及一个问题，生成的ssh key 会相互覆盖，必然有一个无法使用；&lt;/p&gt;
&lt;p&gt;下面记录下解决方法：&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="https://blog.zhimma.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://blog.zhimma.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Laravel开发前期准备</title>
    <link href="https://blog.zhimma.com/2018/11/30/Laravel%E5%BC%80%E5%8F%91-%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://blog.zhimma.com/2018/11/30/Laravel开发-工具类/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-01-24T09:12:16.127Z</updated>
    
    <content type="html"><![CDATA[<p>环境 ： windows10</p><p>本地开发环境 ：<a href="https://github.com/salamander-mh/SalamanderWnmp" target="_blank" rel="noopener">SalamanderWnmp</a></p><p>Phpstrom版本：Phpstrom 2017.1 </p><p>Laravel版本：Laravel5.4</p><a id="more"></a><h1 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h1><h2 id="Laravel-Plugin"><a href="#Laravel-Plugin" class="headerlink" title="Laravel Plugin"></a>Laravel Plugin</h2><hr><p>ctrl+alt+s打开PHPStrom设置页面，按如下操作</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/laravel/laravel_plugin.png" alt="image"></p><p>安装完成后，启用插件，如下图所示</p><p><img src="http://mafuntoo-blog.oss-cn-qingdao.aliyuncs.com/laravel/laravel_enable_plugins.png" alt="image"></p><p>然后再去写代码的时候就会提供controllers,views, routes, configuration, translations等的代码提示功能。</p><h2 id="Laravel-IDE-Helper"><a href="#Laravel-IDE-Helper" class="headerlink" title="Laravel IDE Helper"></a>Laravel IDE Helper</h2><hr><p>有时候你会发现Route::之类的没有代码提示或者自动补全，这时候我们需要安装 Laravel IDE Helper</p><p>项目地址<a href="https://github.com/barryvdh/laravel-ide-helper" target="_blank" rel="noopener">：GitHub</a></p><p>使用composer命令安装:<figure class="highlight plain"><figcaption><span>require barryvdh/laravel-ide-helper```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装之后你需要把Laravel IDE Helper以服务的形式注册到应用中。</span><br><span class="line"></span><br><span class="line">修改**app/config/app.php**,添加```Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class```, 到**providers**元素下。</span><br><span class="line"></span><br><span class="line">执行下面的命令</span><br></pre></td></tr></table></figure></p><pre><code>php artisan clear-compiledphp artisan ide-helper:generatephp artisan optimize</code></pre><p><code>`</code></p><p>[参考资料]：<br><a href="https://confluence.jetbrains.com/display/PhpStorm/Laravel+Development+using+PhpStorm" target="_blank" rel="noopener">https://confluence.jetbrains.com/display/PhpStorm/Laravel+Development+using+PhpStorm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境 ： windows10&lt;/p&gt;
&lt;p&gt;本地开发环境 ：&lt;a href=&quot;https://github.com/salamander-mh/SalamanderWnmp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SalamanderWnmp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Phpstrom版本：Phpstrom 2017.1 &lt;/p&gt;
&lt;p&gt;Laravel版本：Laravel5.4&lt;/p&gt;
    
    </summary>
    
      <category term="Laravel" scheme="https://blog.zhimma.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="https://blog.zhimma.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Mac重启php-fpm失败</title>
    <link href="https://blog.zhimma.com/2018/11/30/Mac%E9%87%8D%E5%90%AFphp-fpm%E5%A4%B1%E8%B4%A5/"/>
    <id>https://blog.zhimma.com/2018/11/30/Mac重启php-fpm失败/</id>
    <published>2018-11-29T16:00:00.000Z</published>
    <updated>2019-02-01T07:35:26.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac重启php-fpm失败"><a href="#Mac重启php-fpm失败" class="headerlink" title="Mac重启php-fpm失败"></a><a href="https://www.jianshu.com/p/c9306c69e8b4" target="_blank" rel="noopener">Mac重启php-fpm失败</a></h3><p>关闭</p><p><code>killall -HUP php-fpm</code></p><p>重启，这里报错，提示找不到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  php-fpm</span><br><span class="line">[27-May-2018 11:27:47] ERROR: failed to open configuration file &apos;/private/etc/php-fpm.conf&apos;: No such file or directory (2)</span><br><span class="line">[27-May-2018 11:27:47] ERROR: failed to load configuration file &apos;/private/etc/php-fpm.conf&apos;</span><br><span class="line">[27-May-2018 11:27:47] ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>检查了下本机的php-fpm.conf放在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/php/7.1/php-fpm.conf</span><br></pre></td></tr></table></figure><p>于是修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf</span><br></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf</span><br><span class="line">[27-May-2018 11:28:47] ERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)</span><br><span class="line">[27-May-2018 11:28:47] ERROR: failed to post process the configuration</span><br><span class="line">[27-May-2018 11:28:47] ERROR: FPM initialization failed</span><br></pre></td></tr></table></figure><p>错误信息显示：不能正确的打开”日志“文件，原因是默认在/usr/var目录下工作，可以修改配置文件指定正确的日志文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php-fpm --fpm-config /usr/local/etc/php/7.1/php-fpm.conf --prefix /usr/local/var</span><br></pre></td></tr></table></figure><p>可以成功运行了，错误文件会放在 <code>/usr/local/var/log/php-fpm.log</code></p><p>[TOC]</p><h3 id="Mac-启动、停止、重启-Nginx-重启-php-fpm"><a href="#Mac-启动、停止、重启-Nginx-重启-php-fpm" class="headerlink" title="Mac 启动、停止、重启 Nginx,重启 php-fpm"></a><a href="https://www.yuanshidai.cc/archives/93" target="_blank" rel="noopener">Mac 启动、停止、重启 Nginx,重启 php-fpm</a></h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><hr><p>启动：<code>sudo nginx</code></p><p>停止：</p><figure class="highlight ps"><figcaption><span>-ef | grep nginxsudo kill -INT [进程号]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">sudo kill -INT [进程号]</span><br></pre></td></tr></table></figure><p>重启：<code>sudo nginx -s reload</code></p><blockquote><p>重启之前一定要 执行<code>nginx -t</code>检查配置文件是否有问题</p></blockquote><h4 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h4><hr><p>关闭</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep php-fpm</span><br><span class="line">sudo killall php-fpm</span><br></pre></td></tr></table></figure><p>重启</p><p><code>/usr/local/Cellar/php71/7.1.12_23/sbin/php71-fpm start</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mac重启php-fpm失败&quot;&gt;&lt;a href=&quot;#Mac重启php-fpm失败&quot; class=&quot;headerlink&quot; title=&quot;Mac重启php-fpm失败&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/c9306c69e
      
    
    </summary>
    
      <category term="PHP" scheme="https://blog.zhimma.com/categories/PHP/"/>
    
      <category term="Mac" scheme="https://blog.zhimma.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://blog.zhimma.com/tags/Mac/"/>
    
      <category term="PHP" scheme="https://blog.zhimma.com/tags/PHP/"/>
    
  </entry>
  
</feed>
