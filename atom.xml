<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhimma&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zhimma.com/"/>
  <updated>2020-03-17T07:30:02.246Z</updated>
  <id>https://blog.zhimma.com/</id>
  
  <author>
    <name>zhimma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rabbitmq名称解释</title>
    <link href="https://blog.zhimma.com/2020/03/17/Rabbitmq%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A/"/>
    <id>https://blog.zhimma.com/2020/03/17/Rabbitmq名称解释/</id>
    <published>2020-03-17T07:28:45.000Z</published>
    <updated>2020-03-17T07:30:02.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="1、基础模块"><a href="#1、基础模块" class="headerlink" title="1、基础模块"></a>1、基础模块</h2><p>要熟练使用Rabbitmq就必须知道其名词含义和工作机制</p><blockquote><p>基本流程</p></blockquote><p>基本的工作流程是这样的：生产者，就是你的发送程序，通过TCP连接，创建channel(通道)向指定的exchange(交换机)发送一个消息，exchange再将消息下发到binding(绑定)的queue(队列)中，然后消费者(处理程序)监听接收queue中的消息进行处理。</p><p>这是google的一张流程图</p><p><a href="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/716745-879fc1f697a02944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><blockquote><p>生产者，消费者</p></blockquote><p>即发送消息和接收处理消息的逻辑程序</p><blockquote><p>Channel</p></blockquote><p>通道，rabbitmq的本质是tcp通信，利用tcp连接创建内部的逻辑连接，注意，此通道不是tcp本身通道(tcp一个连接就是一个通道)，而是共享一个tcp连接的其内部实现的连接，至于rabbitmq内部如何实现的我也没吃透，应该是用到了多路复用，总之rabbitmq一切收发都是通过channel实现的，避免了重复连接tcp产生的资源消耗。</p><blockquote><p>Exchange</p></blockquote><p>交换机，相当于是一个消息中转控制中心，负责接收消息然后根据路由规则将消息下发到指定的queue。</p><blockquote><p>Queue</p></blockquote><p>队列，即存放消息的地方，消费的时候直接从队列里取。</p><h2 id="2、参数说明"><a href="#2、参数说明" class="headerlink" title="2、参数说明"></a>2、参数说明</h2><blockquote><p>Routing Key</p></blockquote><p>路由键，是exchange跟queue之间的桥梁，exchange根据绑定的routing key下发消息到对应的queue中，决定了消息的流向，键名可以自定义。</p><blockquote><p>Type</p></blockquote><p>exchange的类型，有’fanout’、’direct’、’topic’、’headers’四个类型。</p><ul><li><strong>fanout</strong>：不需要指定路由键，直接将消息发送给exchange中的所有queue，类似于广播。</li><li><strong>direct</strong>：将消息发给exchange中指定路由键的queue中，相当于精准投放。</li><li><strong>topic</strong>：匹配模式，消息下发到匹配规则的routing key的queue中，有’<em>‘与’#’两个通配符，’</em>‘表示只匹配一个词，’#’表示匹配多个，比如’user.*‘只能匹配到’user.name’而不能匹配到’user.name.wang’，’user.#’则都可以匹配到。</li><li><strong>headers</strong>：根据消息体的headers匹配，这种用到的比较少，绑定的时候指定相关header参数即可。</li></ul><blockquote><p>Durable</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，表示是否持久化。</p><blockquote><p>Auto delete</p></blockquote><p>exchange跟queue都有这个参数，类型为boolean，我试了一下，当exchange绑定的queue全都解绑的时候exchange会自动删除，queue好像没什么影响。</p><blockquote><p>Internal</p></blockquote><p>exchange有这个参数，类型为boolean，内部的，意味着不能对这个exchange发送消息，通过管理后台还是可以发送消息的。</p><blockquote><p>noWait</p></blockquote><p>几乎每个步骤都有这个参数，类型为boolean，不需要服务器任何返回值的意思，指服务端创建队列发送消息等，rabbitmq不需要这个返回状态即可进行下一步，正常来说不会用到这个参数，容易报异常。</p><blockquote><p>Exclusive</p></blockquote><p>queue有这个参数，类型为boolean，排他队列，只对创建该队列的用户可见，其它用户无法访问。</p><blockquote><p>延伸扩展</p></blockquote><p>rabbitmq还提供了很多扩展参数，比如’x-message-ttl’给消息设置过时时间，’x-max-length-bytes’设置消息最大长度，’x-dead-letter-exchange’设置消息过时后推送到的exchange等等，具体的官方文档也提供了，也可以看管理后台创建exchange、queue的时候会有提示的额外参数。</p><p><a href="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/716745-37258e22a0f6014b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>引用这里：<a href="https://shuangdeyu.gitee.io/2019/04/16/基于Go的Rabbitmq实践/" target="_blank" rel="noopener">https://shuangdeyu.gitee.io/2019/04/16/%E5%9F%BA%E4%BA%8EGo%E7%9A%84Rabbitmq%E5%AE%9E%E8%B7%B5/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;&lt;h2 id=&quot;1、基础模块&quot;&gt;&lt;a href=&quot;#1、基础模块&quot; class=&quot;headerlink&quot; title=&quot;1、基础模
      
    
    </summary>
    
      <category term="MQ" scheme="https://blog.zhimma.com/categories/MQ/"/>
    
    
      <category term="Rabbitmq" scheme="https://blog.zhimma.com/tags/Rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>项目LNMP环境搭建</title>
    <link href="https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AELNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.zhimma.com/2019/12/02/项目LNMP环境搭建/</id>
    <published>2019-12-02T06:08:28.000Z</published>
    <updated>2020-02-21T01:26:31.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p><a href="https://www.daehub.com/archives/2254.html" target="_blank" rel="noopener">https://www.daehub.com/archives/2254.html</a></p><ol><li>为了能够安装PHP7，需要安装<strong>EPEL</strong>和<strong>Remi</strong>的软件源，执行如下命令安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line">yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm</span><br></pre></td></tr></table></figure><ol><li>现在需要安装<strong>yum-utils</strong>工具，这个一个yum工具的增强工具，可以更加方便的管理yum软件源：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-utils</span><br></pre></td></tr></table></figure><ol><li>yum-utils的提供了一个yum-config-manager程序，它可以将<strong>Remi</strong>软件包作为默认源来安装PHP7：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php70   [安装 PHP 7.0]</span><br></pre></td></tr></table></figure><p>如果想在CentOS 7系统中安装PHP 7.1或PHP 7.2，则使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --enable remi-php71   [安装 PHP 7.1]</span><br><span class="line">yum-config-manager --enable remi-php72   [安装 PHP 7.2]</span><br></pre></td></tr></table></figure><ol><li>最后，使用如下命令将PHP及常的扩展安装至系统：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php php-mcrypt php-cli php-gd php-curl php-mysql php-ldap php-zip php-fileinfo php-devel php-mbstring php-simplexml php-dom php-common php-fpm</span><br></pre></td></tr></table></figure><p>最后，可以使用php -v命令来检查PHP是否正确的安装至CentOS 7系统中。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><a href="https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7" target="_blank" rel="noopener">https://qizhanming.com/blog/2018/08/06/how-to-install-nginx-on-centos-7</a></p><h4 id="添加-yum-源"><a href="#添加-yum-源" class="headerlink" title="添加 yum 源"></a>添加 yum 源</h4><p>Nginx 不在默认的 yum 源中，可以使用 epel 或者官网的 yum 源，本例使用官网的 yum 源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装完 yum 源之后，可以查看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">repo id                          repo name                          status</span><br><span class="line">base/7/x86_64                    CentOS-7 - Base                    9,911</span><br><span class="line">extras/7/x86_64                  CentOS-7 - Extras                    368</span><br><span class="line">nginx/x86_64                     nginx repo                           108</span><br><span class="line">updates/7/x86_64                 CentOS-7 - Updates                 1,041</span><br><span class="line">repolist: 11,428</span><br></pre></td></tr></table></figure><p>可以发现 <code>nginx repo</code> 已经安装到本机了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>yum 安装 Nginx，非常简单，一条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install nginx</span><br></pre></td></tr></table></figure><h4 id="配置-Nginx-服务"><a href="#配置-Nginx-服务" class="headerlink" title="配置 Nginx 服务"></a>配置 Nginx 服务</h4><h5 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>重新加载，因为一般重新配置之后，不希望重启服务，这时可以使用重新加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="https://juejin.im/post/5c088b066fb9a049d4419985" target="_blank" rel="noopener">https://juejin.im/post/5c088b066fb9a049d4419985</a></p><h4 id="添加Mysql5-7仓库"><a href="#添加Mysql5-7仓库" class="headerlink" title="添加Mysql5.7仓库"></a>添加Mysql5.7仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="确认Mysql仓库成功添加"><a href="#确认Mysql仓库成功添加" class="headerlink" title="确认Mysql仓库成功添加"></a>确认Mysql仓库成功添加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum repolist all | grep mysql | grep enabled</span><br></pre></td></tr></table></figure><p>如果展示像下面,则表示成功添加仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql-connectors-community/x86_64  MySQL Connectors Community    enabled:     51</span><br><span class="line">mysql-tools-community/x86_64       MySQL Tools Community         enabled:     63</span><br><span class="line">mysql57-community/x86_64           MySQL 5.7 Community Server    enabled:    267</span><br></pre></td></tr></table></figure><h4 id="开始安装Mysql5-7"><a href="#开始安装Mysql5-7" class="headerlink" title="开始安装Mysql5.7"></a>开始安装Mysql5.7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><h4 id="启动Mysql"><a href="#启动Mysql" class="headerlink" title="启动Mysql"></a>启动Mysql</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure><h5 id="设置系统启动时自动启动"><a href="#设置系统启动时自动启动" class="headerlink" title="设置系统启动时自动启动"></a>设置系统启动时自动启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mysqld</span><br></pre></td></tr></table></figure><h5 id="查看启动状态"><a href="#查看启动状态" class="headerlink" title="查看启动状态"></a>查看启动状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mysqld</span><br></pre></td></tr></table></figure><h5 id="Mysql的安全设置"><a href="#Mysql的安全设置" class="headerlink" title="Mysql的安全设置"></a>Mysql的安全设置</h5><p>CentOS上的root默认密码可以在文件/var/log/mysqld.log找到，通过下面命令可以打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log | grep -i &apos;temporary password&apos;</span><br></pre></td></tr></table></figure><p>执行下面命令进行安全设置，这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation     (Prod@Mysql@Passw0rd)</span><br></pre></td></tr></table></figure><h5 id="设置数据库编码为utf8"><a href="#设置数据库编码为utf8" class="headerlink" title="设置数据库编码为utf8"></a>设置数据库编码为utf8</h5><ol><li>打开配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/my.cnf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>在[mysqld]，[client]，[mysql]节点下添加编码设置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">collation-server = utf8_unicode_ci</span><br><span class="line">init-connect=&apos;SET NAMES utf8&apos;</span><br><span class="line">character-set-server = utf8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>重启Mysql即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/" target="_blank" rel="noopener">https://www.linode.com/docs/databases/redis/install-and-configure-redis-on-centos-7/</a></p><h4 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h4><ol><li><p>Add the EPEL repository, and update YUM to confirm your change:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li><li><p>Install Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install redis</span><br></pre></td></tr></table></figure></li><li><p>Start Redis:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis</span><br></pre></td></tr></table></figure><p><strong>Optional</strong>: To automatically start Redis on boot:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable redis</span><br></pre></td></tr></table></figure></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>Verify that Redis is running with <code>redis-cli</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure><p>If Redis is running, it will return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv composer.phar  /usr/local/bin/composer</span><br></pre></td></tr></table></figure><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer -V</span><br><span class="line">Composer version 1.9.1 2019-11-01 17:20:17</span><br></pre></td></tr></table></figure><h4 id="设置镜像地址"><a href="#设置镜像地址" class="headerlink" title="设置镜像地址"></a>设置镜像地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PHP&quot;&gt;&lt;a href=&quot;#PHP&quot; class=&quot;headerlink&quot; title=&quot;PHP&quot;&gt;&lt;/a&gt;PHP&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.daehub.com/archives/2254.html&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="CentOS" scheme="https://blog.zhimma.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>项目压测及调优</title>
    <link href="https://blog.zhimma.com/2019/12/02/%E9%A1%B9%E7%9B%AE%E5%8E%8B%E6%B5%8B%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
    <id>https://blog.zhimma.com/2019/12/02/项目压测及调优/</id>
    <published>2019-12-02T03:56:48.000Z</published>
    <updated>2020-02-06T01:49:02.762Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="性能概念TPS、QPS、RPS"><a href="#性能概念TPS、QPS、RPS" class="headerlink" title="性能概念TPS、QPS、RPS"></a>性能概念TPS、QPS、RPS</h2><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p>TPS：Transactions Per Second（每秒事务处理数），指服务器每秒处理的事务次数。一般用于评估数据库、交易系统的基准性能。</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>QPS：Queries Per Second（查询量/秒），是服务器每秒能够处理的查询次数，例如域名服务器、Mysql查询性能。</p><h3 id="RPS"><a href="#RPS" class="headerlink" title="RPS"></a>RPS</h3><p>RPS：Request Per Second（请求数/秒）RPS（Request Per Second）和QPS可以认为是一回事。RT：Response Time（响应时间）：客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。也叫Think Time。</p><h3 id="并发数与TPS-QPS的关系"><a href="#并发数与TPS-QPS的关系" class="headerlink" title="并发数与TPS/QPS的关系"></a>并发数与TPS/QPS的关系</h3><p>QPS（TPS）= 并发数/平均响应时间这里的并发数如果为事务处理请求数，则为TPS，如果为查询请求数，则为QPS。</p><h2 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h2><p><a href="https://blog.csdn.net/u011636440/article/details/78611838" target="_blank" rel="noopener">https://blog.csdn.net/u011636440/article/details/78611838</a></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>查看当前操作系统发行版信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]#  cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.7.1908 (Core)</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                8</span><br><span class="line">On-line CPU(s) list:   0-7</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    8</span><br><span class="line">座：                 1</span><br><span class="line">NUMA 节点：         1</span><br><span class="line">厂商 ID：           GenuineIntel</span><br><span class="line">CPU 系列：          6</span><br><span class="line">型号：              79</span><br><span class="line">型号名称：        Intel(R) Xeon(R) CPU E5-26xx v4</span><br><span class="line">步进：              1</span><br><span class="line">CPU MHz：             2394.446</span><br><span class="line">BogoMIPS：            4788.89</span><br><span class="line">超管理器厂商：  KVM</span><br><span class="line">虚拟化类型：     完全</span><br><span class="line">L1d 缓存：          32K</span><br><span class="line">L1i 缓存：          32K</span><br><span class="line">L2 缓存：           4096K</span><br><span class="line">NUMA 节点0 CPU：    0-7</span><br><span class="line">Flags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch bmi1 avx2 bmi2 rdseed adx xsaveopt</span><br></pre></td></tr></table></figure><h4 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line">cpu cores: 8</span><br></pre></td></tr></table></figure><h4 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="查看概要内存使用情况"><a href="#查看概要内存使用情况" class="headerlink" title="查看概要内存使用情况"></a>查看概要内存使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_25_122_centos conf.d]# free -g</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:             15           1           9           0           4          13</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><blockquote><p>-g是以GB为单位；也可以使用-m，即以MB为单位</p></blockquote><h2 id="压测和优化"><a href="#压测和优化" class="headerlink" title="压测和优化"></a>压测和优化</h2><h3 id="未优化压测"><a href="#未优化压测" class="headerlink" title="未优化压测"></a>未优化压测</h3><h4 id="压测结果预览"><a href="#压测结果预览" class="headerlink" title="压测结果预览"></a>压测结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/php-fpm%E6%9C%AA%E4%BC%98%E5%8C%96.gif" alt=""></p><h4 id="PHP-FPM配置"><a href="#PHP-FPM配置" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96php-fpm%E9%85%8D%E7%BD%AE.png" alt=""></p><h4 id="wrk压测结果"><a href="#wrk压测结果" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png" alt=""></p><h4 id="Nginx报错"><a href="#Nginx报错" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E6%9C%AA%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png" alt=""></p><h3 id="优化PHP-FPM"><a href="#优化PHP-FPM" class="headerlink" title="优化PHP-FPM"></a>优化PHP-FPM</h3><h4 id="PHP-FPM优化-示例：这是另一台服务器"><a href="#PHP-FPM优化-示例：这是另一台服务器" class="headerlink" title="PHP-FPM优化(示例：这是另一台服务器)"></a>PHP-FPM优化(示例：这是另一台服务器)</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/psaux.png" alt=""></p><p>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><p> 格式说明：</p><p>USER: 行程拥有者</p><p>PID: pid</p><p>%CPU: 占用的 CPU 使用率</p><p>%MEM: 占用的记忆体使用率</p><p>VSZ: 占用的虚拟记忆体大小</p><p>RSS: 占用的记忆体大小</p><p>TTY: 终端的次要装置号码 (minor device number of tty)</p><p>STAT: 该行程的状态，linux的进程有5种状态：</p><p>​    D 不可中断 uninterruptible sleep (usually IO)</p><p>​    R 运行 runnable (on run queue)</p><p>​    S 中断 sleeping</p><p>​    T 停止 traced or stopped</p><p>​    Z 僵死 a defunct (”zombie”) process</p><p>注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p><p>START: 行程开始时间</p><p>TIME: 执行的时间</p><p>COMMAND:所执行的指令</p><h4 id="查看进程的消息"><a href="#查看进程的消息" class="headerlink" title="查看进程的消息"></a>查看进程的消息</h4><p><code>ps auxf | grep php | grep -v grep</code></p><blockquote><p>grep -v grep 过滤当前命令grep</p></blockquote><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/ps.png" alt="image-20191016153558487"></p><h4 id="占用的内存数量"><a href="#占用的内存数量" class="headerlink" title="占用的内存数量"></a><code>占用的内存数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | awk &apos;&#123;sum+=$6&#125; END &#123;print sum&#125;&apos;</span><br><span class="line"></span><br><span class="line">18207120</span><br></pre></td></tr></table></figure><h4 id="查看进程数量"><a href="#查看进程数量" class="headerlink" title="查看进程数量"></a><code>查看进程数量</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep php | grep -v grep | grep -v master | wc -l</span><br><span class="line"></span><br><span class="line">800</span><br></pre></td></tr></table></figure><p>可以看到第6列，每一个子进程的内存占用大概在22M之间（单位为KB）。平均的内存占用为<code>18207120KB/800/1024 = 22.2M</code>。</p><h5 id="进程数限制"><a href="#进程数限制" class="headerlink" title="进程数限制"></a>进程数限制</h5><p>此时如果我们分配全部的内存给<code>PHP-FPM</code>使用，那么进程数可以限制在`16*1000/22 = 744,但是由于我们的服务器同时服务了很多内容，所以我们可以向下调整到256个进程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.max = 700</span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = 700</span><br><span class="line">pm.start_servers = 450</span><br><span class="line">pm.min_spare_servers = 200</span><br><span class="line">pm.max_spare_servers = 700</span><br></pre></td></tr></table></figure><h5 id="max-children"><a href="#max-children" class="headerlink" title="max_children"></a>max_children</h5><ul><li><strong>这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。</strong></li><li>设置”max_children”也需要根据服务器的性能进行设定</li><li>一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右</li><li>假设“max_children”设置成100个，20M*100=2000M</li><li>也就是说在峰值的时候所有PHP-CGI所耗内存在2000M以内。</li><li>假设“max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。</li><li>如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。</li></ul><h5 id="start-servers"><a href="#start-servers" class="headerlink" title="start_servers"></a>start_servers</h5><ul><li>pm.start_servers的默认值为2。并且php-fpm中给的计算方式也为：<br>{（cpu空闲时等待连接的php的最小子进程数） + （cpu空闲时等待连接的php的最大子进程数 - cpu空闲时等待连接的php的最小子进程数）/ 2}；</li><li>用配置表示就是：min_spare_servers + (max_spare_servers - min_spare_servers) / 2；</li><li>一般而言，设置成10-20之间的数据足够满足需求了。</li></ul><h5 id="max-requests（最大请求数）"><a href="#max-requests（最大请求数）" class="headerlink" title="max_requests（最大请求数）"></a>max_requests（最大请求数）</h5><blockquote><p>最大处理请求数是指一个php-fpm的worker进程在处理多少个请求后就终止掉，master进程会重新respawn一个新的。<br>这个配置的主要目的是避免php解释器或程序引用的第三方库造成的内存泄露。<br>pm.max_requests = 10240</p></blockquote><ul><li>当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，自动重启该进程。</li><li>502，是后端 PHP-FPM 不可用造成的，间歇性的502一般认为是由于 PHP-FPM 进程重启造成的.</li><li>但是为什么要重启进程呢？</li><li>如果不定期重启 PHP-CGI 进程，势必造成内存使用量不断增长（比如第三方库有问题等）。因此 PHP-FPM 作为 PHP-CGI 的管理器，提供了这么一项监控功能，对请求达到指定次数的 PHP-CGI 进程进行重启，保证内存使用量不增长。</li><li>正是因为这个机制，在高并发中，经常导致 502 错误</li><li>目前我们解决方案是把这个值尽量设置大些，减少 PHP-CGI 重新 SPAWN 的次数，同时也能提高总体性能。PS：刚开始我们是500导致内存飙高，现在改成5120，当然可以再大一些，10240等，这个主要看测试结果，如果没有内存泄漏等问题，可以再大一些。</li></ul><h5 id="request-terminate-timeout（最长执行时间）"><a href="#request-terminate-timeout（最长执行时间）" class="headerlink" title="request_terminate_timeout（最长执行时间）"></a>request_terminate_timeout（最长执行时间）</h5><p><strong>max_execution_time</strong>和<strong>request_terminate_timeout</strong></p><blockquote><p>; The timeout for serving a single request after which the worker process will<br>; be killed. This option should be used when the ‘max_execution_time’ ini option<br>; does not stop script execution for some reason. A value of ‘0’ means ‘off’.<br>; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)<br>; Default Value: 0<br>;request_terminate_timeout = 0<br>＝＝＝＝＝＝＝＝＝＝＝＝<br>设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。</p></blockquote><ul><li>这两项都是用来配置一个PHP脚本的最大执行时间的。当超过这个时间时，PHP-FPM不只会终止脚本的执行，还会终止执行脚本的Worker进程。</li><li>Nginx会发现与自己通信的连接断掉了，就会返回给客户端502错误。</li></ul><h3 id="优化PHP-FPM压测"><a href="#优化PHP-FPM压测" class="headerlink" title="优化PHP-FPM压测"></a>优化PHP-FPM压测</h3><h4 id="优化PHP-FPM结果预览"><a href="#优化PHP-FPM结果预览" class="headerlink" title="优化PHP-FPM结果预览"></a>优化PHP-FPM结果预览</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/php-fpm%E4%BC%98%E5%8C%96.gif" alt=""></p><h4 id="PHP-FPM配置-1"><a href="#PHP-FPM配置-1" class="headerlink" title="PHP-FPM配置"></a>PHP-FPM配置</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96php-fpm.png" alt=""></p><h4 id="wrk压测结果-1"><a href="#wrk压测结果-1" class="headerlink" title="wrk压测结果"></a>wrk压测结果</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96%E7%BB%93%E6%9E%9C.png" alt=""></p><h4 id="Nginx报错-1"><a href="#Nginx报错-1" class="headerlink" title="Nginx报错"></a>Nginx报错</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E4%BC%98%E5%8C%96nginx%E6%8A%A5%E9%94%99.png" alt=""></p><h3 id="优化Nginx压测"><a href="#优化Nginx压测" class="headerlink" title="优化Nginx压测"></a>优化Nginx压测</h3><p><a href="https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/</a></p><p><a href="http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/" target="_blank" rel="noopener">http://www.chengweiyang.cn/2015/11/14/how-to-enlarge-linux-open-files-upper-cell/</a></p><h4 id="错误：24-Too-many-open-files"><a href="#错误：24-Too-many-open-files" class="headerlink" title="错误：24: Too many open files"></a>错误：<code>24: Too many open files</code></h4><h5 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h5><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/nginx%E6%8A%A5%E9%94%99.png" alt="image-20191113164407658"> </p><h5 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h5><p>Linux / UNIX对文件句柄和打开文件的数量设置了软限制和硬限制。您可以使用ulimit命令查看这些限制</p><p>查看硬值和软值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>在Linux OS级别上增加开放FD限制</p><p>编辑文件/etc/sysctl.conf，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>追加/修改以下行：<br><code>fs.file-max = 100000</code></p><p>保存并关闭文件。编辑/etc/security/limits.conf，输入：<br><code># vi /etc/security/limits.conf</code></p><p>Set soft and hard limit for all users or nginx user as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx       soft    nofile   100000</span><br><span class="line">nginx       hard    nofile  100000</span><br></pre></td></tr></table></figure><p>保存并并关闭文件输入下面命令使之生效<br><code>sysctl -p</code></p><h4 id="Nginx优化"><a href="#Nginx优化" class="headerlink" title="Nginx优化"></a>Nginx优化</h4><p><a href="https://www.mtyun.com/library/how-to-optimize-nginx" target="_blank" rel="noopener">https://www.mtyun.com/library/how-to-optimize-nginx</a></p><p><a href="https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html" target="_blank" rel="noopener">https://www.linpx.com/p/11-nginx-parameter-performance-optimization-suggestions.html</a></p><p>对于Nginx的调优，可以大致从如下指令着手</p><ol><li>worker_processes </li><li>worker_connections</li><li>Buffers</li><li>Timeouts</li><li>Gzip Compression</li><li>Static File Caching</li><li>logging</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">8</span>;</span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> auto;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="attribute">accept_mutex</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">accept_mutex_delay</span> <span class="number">500ms</span>;</span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>     <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">10</span>;</span><br><span class="line"><span class="attribute">keepalive_requests</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">12</span>;</span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">crit</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> any;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">gzip_types</span><br><span class="line">text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">text/javascript application/javascript application/x-javascript</span><br><span class="line">text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">text/css text/plain text/x-component</span><br><span class="line">font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">image/x-icon;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\.(?!.*SV1)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">100000</span> inactive=<span class="number">20s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">30s</span>; </span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">12</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####worker_processes-配置工作进程数量</p><p><code>worker_processes</code>表示工作进程的数量，一般情况设置成CPU核的数量即可，一个cpu配置多于一个worker数，对Nginx而言没有任何益处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep processor /proc/cpuinfo | wc -l</span><br></pre></td></tr></table></figure><p>这个命令会告诉你当前机器是多少核，输出为8即表示8核。</p><h5 id="worker-cpu-affinity-配置cpu亲和性"><a href="#worker-cpu-affinity-配置cpu亲和性" class="headerlink" title="worker_cpu_affinity-配置cpu亲和性"></a>worker_cpu_affinity-配置cpu亲和性</h5><p>设置<code>worker_cpu_affinity</code>，这个配置用于将worker process与指定cpu核绑定，降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。 </p><h5 id="worker-rlimit-nofile-配置-worker-进程的最大打开文件数"><a href="#worker-rlimit-nofile-配置-worker-进程的最大打开文件数" class="headerlink" title="worker_rlimit_nofile-配置 worker 进程的最大打开文件数"></a>worker_rlimit_nofile-配置 worker 进程的最大打开文件数</h5><p>调整配置 Nginx worker 进程的最大打开文件数，这个控制连接数的参数为<code>worker_rlimit_nofile</code>。该参数的实际配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure><p>可设置为系统优化后的 <code>ulimit -HSn</code> 的结果</p><h5 id="events块-配置事件处理模型的优化"><a href="#events块-配置事件处理模型的优化" class="headerlink" title="events块-配置事件处理模型的优化"></a>events块-配置事件处理模型的优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"><span class="comment"># accept_mutex off;</span></span><br><span class="line"><span class="comment"># accept_mutex_delay 500ms;</span></span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">10240</span>;</span><br><span class="line"><span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>use epoll</strong></p><p>Nginx 的连接处理机制在不同的操作系统中会采用不同的 I/O 模型，在 linux 下，Nginx 使用 epoll 的 I/O 多路复用模型，在 Freebsd 中使用 kqueue 的 I/O 多路复用模型，在 Solaris 中使用 /dev/poll 方式的 I/O 多路复用模型，在 Windows 中使用 icop，等等。</p><p><code>events</code> 指令是设定 Nginx 的工作模式及连接数上限。<code>use</code>指令用来指定 Nginx 的工作模式。Nginx 支持的工作模式有 select、 poll、 kqueue、 epoll 、 rtsig 和/ dev/poll。当然，也可以不指定事件处理模型，Nginx 会自动选择最佳的事件处理模型。</p><p><strong>accept_mutex off/on ?</strong></p><p><a href="https://blog.huoding.com/2013/08/24/281" target="_blank" rel="noopener">https://blog.huoding.com/2013/08/24/281</a></p><p><a href="https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">https://www.linuxdashen.com/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a>    </p><p>关闭 accept_mutex ，请求在多个 worker 间的分配更均衡</p><h5 id="accept-mutex-delay"><a href="#accept-mutex-delay" class="headerlink" title="accept_mutex_delay"></a>accept_mutex_delay</h5><p>当accept_mutex功能启用后，只有一个持有mutex锁的worker进程会接受并处理请求，其他worker进程等待。accept_mutex_delay指定的时间就是这些worker进程的等待时间，过了等待时间下一个worker进程便取得mutex锁，处理请求。accept_mutex_delay在events模块中指定，默认的值为500ms。</p><h5 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h5><p>通过调整控制连接数的参数来调整 Nginx 单个进程允许的客户端最大连接数。    </p><p><code>worker_connections</code> 也是个事件模块指令，用于定义 Nginx 每个进程的最大连接数，默认是 1024。</p><p>最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients = worker_processes * worker_connections;</span><br></pre></td></tr></table></figure><p>如果作为反向代理，因为浏览器默认会开启 2 个连接到 server，而且 Nginx 还会使用fds（file descriptor）从同一个连接池建立连接到 upstream 后端。则最大连接数的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_clients = worker_processes * worker_connections / 4;</span><br></pre></td></tr></table></figure><p>另外，<strong>进程的最大连接数受 Linux 系统进程的最大打开文件数限制</strong>，在执行操作系统命令 <code>ulimit -HSn 65535</code>或配置相应文件后， <code>worker_connections</code> 的设置才能生效。</p><p><strong>multi_accept</strong></p><p>默认情况下，Nginx 进程只会在一个时刻接收一个新的连接，我们可以配置<code>multi_accept</code> 为 <code>on</code>，实现在一个时刻内可以接收多个新的连接，提高处理效率。该参数默认是 <code>off</code>，建议开启。</p><h5 id="tcp优化"><a href="#tcp优化" class="headerlink" title="tcp优化"></a>tcp优化</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">  <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendfile</strong></p><p>第一行的 <code>sendfile</code> 配置可以提高 Nginx 静态资源托管效率。sendfile 是一个系统调用，直接在内核空间完成文件发送，不需要先 read 再 write，没有上下文切换开销。</p><p><strong>tcp_nopush</strong></p><p>TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 <code>tcp_nopush</code> 来控制它，并且只有在启用了 <code>sendfile</code> 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。</p><p><strong>keepalive_timeout</strong></p><p>Nginx 使用 keepalive_timeout 来指定 KeepAlive 的超时时间（timeout）。指定每个 TCP 连接最多可以保持多长时间。Nginx 的默认值是 75 秒，有些浏览器最多只保持 60 秒，所以可以设定为 60 秒。若将它设置为 0，就禁止了 keepalive 连接。</p><p><strong>keepalive_requests</strong></p><p>keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100。</p><p>这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。<br>大多数情况下当QPS(每秒请求数)不是很高时，默认值100凑合够用。但是，对于一些QPS比较高（比如超过10000QPS，甚至达到30000,50000甚至更高) 的场景，默认的100就显得太低。<br>简单计算一下，QPS=10000时，客户端每秒发送10000个请求(通常建立有多个长连接)，每个连接只能最多跑100次请求，意味着平均每秒钟就会有100个长连接因此被nginx关闭。同样意味着为了保持QPS，客户端不得不每秒中重新新建100个连接。因此，就会发现有大量的TIME_WAIT的socket连接(即使此时keep alive已经在client和nginx之间生效)。因此对于QPS较高的场景，非常有必要加大这个参数，以避免出现大量连接被生成再抛弃的情况，减少TIME_WAIT。</p><p><strong>tcp_nodelay</strong></p><p>TCP_NODELAY 也是一个 socket 选项，启用后会禁用 Nagle 算法，尽快发送数据，某些情况下可以节约 200ms（Nagle 算法原理是：在发出去的数据还未被确认之前，新生成的小数据先存起来，凑满一个 MSS 或者等到收到确认后再发送）。Nginx 只会针对处于 keep-alive 状态的 TCP 连接才会启用 <code>tcp_nodelay</code>。</p><h5 id="优化连接参数"><a href="#优化连接参数" class="headerlink" title="优化连接参数"></a>优化连接参数</h5><p>这部分更多是更具业务场景来决定的。例如<code>client_max_body_size</code>用来决定请求体的大小，用来限制上传文件的大小。上面列出的参数可以作为起始参数。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">client_body_buffer_size</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">  <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line">  <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Buffers：另一个很重要的参数为buffer，如果buffer太小，Nginx会不停的写一些临时文件，这样会导致磁盘不停的去读写，现在我们先了解设置buffer的一些相关参数：</p></blockquote><p><strong>client_body_buffer_size</strong></p><p>允许客户端请求的最大单个文件字节数</p><p><strong>client_header_buffer_size</strong></p><p>用于设置客户端请求的Header头缓冲区大小，大部分情况1KB大小足够</p><p><strong>client_max_body_size</strong></p><p>设置客户端能够上传的文件大小，默认为1m</p><p><strong>large_client_header_buffers</strong></p><p>该指令用于设置客户端请求的Header头缓冲区大小</p><h5 id="超时时间优化"><a href="#超时时间优化" class="headerlink" title="超时时间优化"></a>超时时间优化</h5><p><strong>client_body_timeout</strong></p><p>设定客户端与服务器建立连接后发送request body的超时时间。如果客户端在此时间内没有发送任何内容，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http, server 和 location模块中定义。</p><p><strong>client_header_timeout</strong></p><p>设定客户端向服务器发送一个完整的request header的超时时间。如果客户端在此时间内没有发送一个完整的request header，那么Nginx返回HTTP 408错误（Request Timed Out）。它的默认值是60秒，在http 和 server模块中定义。</p><p><strong>send_timeout</strong></p><p>指定了向客户端传输数据的超时时间。默认值为60秒，可以在http, server 和 location模块中定义</p><h5 id="压缩优化"><a href="#压缩优化" class="headerlink" title="压缩优化"></a>压缩优化</h5><p><strong>Gzip 压缩</strong></p><p>开启Gzip，gzip可以帮助Nginx减少大量的网络传输工作，另外要注意<code>gzip_comp_level</code>的设置，太高的话，Nginx服务会浪费CPU的执行周期。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">  <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line">  <span class="attribute">gzip_proxied</span> any;</span><br><span class="line">  <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">  gzip_types</span><br><span class="line">    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml</span><br><span class="line">    text/javascript application/javascript application/x-javascript</span><br><span class="line">    text/x-json application/json application/x-web-app-manifest+json</span><br><span class="line">    text/css text/plain text/x-component</span><br><span class="line">    font/opentype application/x-font-ttf application/vnd.ms-fontobject</span><br><span class="line">    image/x-icon;</span><br><span class="line">  <span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\.(?!.*SV1)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(jpg|jpeg|png|gif|ico|css|js)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">365d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测总结"><a href="#压测总结" class="headerlink" title="压测总结"></a>压测总结</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/%E5%8E%8B%E6%B5%8Bcupp.png" alt="">服务器负载已达到最大，php-fpm+nginx模式进行优化不能再明显的提高PRS</p><h2 id="Swoole"><a href="#Swoole" class="headerlink" title="Swoole"></a>Swoole</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1024</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"msie6"</span>;</span><br><span class="line"><span class="attribute">upstream</span> swoole &#123;</span><br><span class="line">    <span class="comment"># 通过 IP:Port 连接</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:5200</span> weight=<span class="number">5</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="comment"># 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能</span></span><br><span class="line">    <span class="comment">#server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s;</span></span><br><span class="line">    <span class="comment">#server 192.168.1.2:5200 backup;</span></span><br><span class="line">    <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> dabao.zhimma.com;</span><br><span class="line">    <span class="attribute">index</span>       index.php index.html index default;</span><br><span class="line">    <span class="attribute">root</span> /data/wwwroot/dabao/api/public;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/<span class="variable">$server_name</span>.access.log  main;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="comment"># Nginx处理静态资源(建议开启gzip)，LaravelS处理动态资源。</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">@laravels</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 当请求PHP文件时直接响应404，防止暴露public/*.php</span></span><br><span class="line">    <span class="comment">#location ~* \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    return 404;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@laravels</span> &#123;</span><br><span class="line">        <span class="comment"># proxy_connect_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_send_timeout 60s;</span></span><br><span class="line">        <span class="comment"># proxy_read_timeout 120s;</span></span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-PORT <span class="variable">$remote_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Scheme <span class="variable">$scheme</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Protocol <span class="variable">$server_protocol</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Name <span class="variable">$server_name</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Addr <span class="variable">$server_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Server-Port <span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">"HttpOnly"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Set-Cookie <span class="string">"Secure"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Frame-Options <span class="string">"SAMEORIGIN"</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://swoole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /backend &#123;</span><br><span class="line">        <span class="attribute">alias</span> /data/wwwroot/dabao/web/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /backend/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h3><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole1.gif" alt=""></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/md/lnmp/swoole2.gif" alt=""></p><h2 id="php-fpm-配置文件解读"><a href="#php-fpm-配置文件解读" class="headerlink" title="php-fpm 配置文件解读"></a>php-fpm 配置文件解读</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid</span> = /usr/local/var/run/php-fpm.pid</span><br><span class="line"><span class="comment">#pid设置，一定要开启,上面是Mac平台的。默认在php安装目录中的var/run/php-fpm.pid。比如centos的在: /usr/local/php/var/run/php-fpm.pid</span></span><br><span class="line"><span class="attr">error_log</span>  = /usr/local/var/log/php-fpm.log</span><br><span class="line"><span class="comment">#错误日志，上面是Mac平台的，默认在php安装目录中的var/log/php-fpm.log，比如centos的在: /usr/local/php/var/log/php-fpm.log</span></span><br><span class="line"><span class="attr">log_level</span> = notice</span><br><span class="line"><span class="comment">#错误级别. 上面的php-fpm.log纪录的登记。可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</span></span><br><span class="line"><span class="attr">emergency_restart_threshold</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">emergency_restart_interval</span> = <span class="number">60</span>s</span><br><span class="line"><span class="comment">#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。0 表示 '关闭该功能'. 默认值: 0 (关闭).</span></span><br><span class="line"><span class="attr">process_control_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</span></span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="comment">#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: 'ip:port', 'port', '/path/to/unix/socket'. 每个进程池都需要设置。如果nginx和php在不同的机器上，分布式处理，就设置ip这里就可以了。</span></span><br><span class="line">listen.backlog = -1</span><br><span class="line"><span class="comment">#backlog数，设置 listen 的半连接队列长度，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考：http://www.3gyou.cc/?p=41</span></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line"><span class="comment">#允许访问FastCGI进程的IP白名单，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接。</span></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0666</span><br><span class="line"><span class="comment">#unix socket设置选项，如果使用tcp方式访问，这里注释即可。</span></span><br><span class="line"><span class="attr">user</span> = www</span><br><span class="line"><span class="attr">group</span> = www</span><br><span class="line"><span class="comment">#启动进程的用户和用户组，FPM 进程运行的Unix用户, 必须要设置。用户组，如果没有设置，则默认用户的组被使用。</span></span><br><span class="line"><span class="attr">pm</span> = dynamic </span><br><span class="line"><span class="comment">#php-fpm进程启动模式，pm可以设置为static和dynamic和ondemand</span></span><br><span class="line"><span class="comment">#如果选择static，则进程数就数固定的，由pm.max_children指定固定的子进程数。</span></span><br><span class="line"><span class="comment">#如果选择dynamic，则进程数是动态变化的,由以下参数决定：</span></span><br><span class="line">pm.max_children = 50 #子进程最大数</span><br><span class="line">pm.start_servers = 2 #启动时的进程数，默认值为: min_spare_servers + (max_spare_servers - min_spare_servers) / 2</span><br><span class="line">pm.min_spare_servers = 1 #保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</span><br><span class="line">pm.max_spare_servers = 3 #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</span><br><span class="line">pm.max_requests = 10000</span><br><span class="line"><span class="comment">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 '0' 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span></span><br><span class="line">pm.status_path = /status</span><br><span class="line"><span class="comment">#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</span></span><br><span class="line">ping.path = /ping</span><br><span class="line"><span class="comment">#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</span></span><br><span class="line">ping.response = pong</span><br><span class="line"><span class="comment">#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</span></span><br><span class="line">access.log = log/$pool.access.log</span><br><span class="line"><span class="comment">#每一个请求的访问日志，默认是关闭的。</span></span><br><span class="line">access.format = "%R - %u %t \"%m %r%Q%q\" %s %f %&#123;mili&#125;d %&#123;kilo&#125;M %C%%"</span><br><span class="line"><span class="comment">#设定访问日志的格式。</span></span><br><span class="line"><span class="attr">slowlog</span> = log/<span class="variable">$pool</span>.log.slow</span><br><span class="line"><span class="comment">#慢请求的记录日志,配合request_slowlog_timeout使用，默认关闭</span></span><br><span class="line"><span class="attr">request_slowlog_timeout</span> = <span class="number">10</span>s</span><br><span class="line"><span class="comment">#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 '0' 表示 'Off'</span></span><br><span class="line"><span class="attr">request_terminate_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的'max_execution_time'因为某些特殊原因没有中止运行的脚本有用. 设置为 '0' 表示 'Off'.当经常出现502错误时可以尝试更改此选项。</span></span><br><span class="line"><span class="attr">rlimit_files</span> = <span class="number">1024</span></span><br><span class="line"><span class="comment">#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</span></span><br><span class="line"><span class="attr">rlimit_core</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#设置核心rlimit最大限制值. 可用值: 'unlimited' 、0或者正整数. 默认值: 系统定义值.</span></span><br><span class="line"><span class="attr">chroot</span> =</span><br><span class="line"><span class="comment">#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</span></span><br><span class="line"><span class="attr">chdir</span> =</span><br><span class="line"><span class="comment">#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</span></span><br><span class="line"><span class="attr">catch_workers_output</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</span></span><br></pre></td></tr></table></figure><h2 id="Nginx错误日志说明"><a href="#Nginx错误日志说明" class="headerlink" title="Nginx错误日志说明"></a>Nginx错误日志说明</h2><table><thead><tr><th>错误信息</th><th>错误说明</th></tr></thead><tbody><tr><td>upstream prematurely（过早的） closed connection</td><td>请求uri的时候出现的异常，是由于upstream还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略</td></tr><tr><td>recv() failed (104: Connection reset by peer)</td><td>（1）服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉； （2）客户关掉了浏览器，而服务器还在给客户端发送数据； （3）浏览器端按了Stop</td></tr><tr><td>(111: Connection refused) while connecting to upstream</td><td>用户在连接时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while reading response header from upstream</td><td>用户在连接成功后读取数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(111: Connection refused) while sending request to upstream</td><td>Nginx和upstream连接成功后发送数据时，若遇到后端upstream挂掉或者不通，会收到该错误</td></tr><tr><td>(110: Connection timed out) while connecting to upstream</td><td>nginx连接后面的upstream时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(110: Connection timed out) while reading response header from upstream</td><td>nginx读取来自upstream的响应头时超时</td></tr><tr><td>(110: Connection timed out) while reading upstream</td><td>nginx读取来自upstream的响应时超时</td></tr><tr><td>(104: Connection reset by peer) while connecting to upstream</td><td>upstream发送了RST，将连接重置</td></tr><tr><td>upstream sent invalid header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>upstream sent no valid HTTP/1.0 header while reading response header from upstream</td><td>upstream发送的响应头无效</td></tr><tr><td>client intended to send too large body</td><td>用于设置允许接受的客户端请求内容的最大值，默认值是1M，client发送的body超过了设置值</td></tr><tr><td>reopening logs</td><td>用户发送kill  -WINCH命令</td></tr><tr><td>no servers are inside upstream</td><td>upstream下未配置server</td></tr><tr><td>no live upstreams while connecting to upstream</td><td>upstream下的server全都挂了</td></tr><tr><td>SSL_do_handshake() failed</td><td>SSL握手失败</td></tr><tr><td>SSL_write() failed (SSL:) while sending to client</td><td></td></tr><tr><td>(13: Permission denied) while reading upstream</td><td></td></tr><tr><td>(98: Address already in use) while connecting to upstream</td><td></td></tr><tr><td>(99: Cannot assign requested address) while connecting to upstream</td><td></td></tr><tr><td>ngx_slab_alloc() failed: no memory in SSL session shared cache</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>could not add new SSL session to the session cache while SSL handshaking</td><td>ssl_session_cache大小不够等原因造成</td></tr><tr><td>send() failed (111: Connection refused)</td></tr></tbody></table><h3 id="错误日志类型"><a href="#错误日志类型" class="headerlink" title="错误日志类型"></a>错误日志类型</h3><ul><li>类型1: upstream timed out</li><li>类型2: connect() failed</li><li>类型3: no live upstreams</li><li>类型4: upstream prematurely closed connection</li><li>类型5: 104: Connection reset by peer</li><li>类型6: client intended to send too large body</li><li>类型7: upstream sent no valid HTTP/1.0 header</li></ul><table><thead><tr><th>类型</th><th>错误日志</th><th>原因</th><th>解决办法</th></tr></thead><tbody><tr><td>1</td><td>upstream timed out (110: Connection timed out) while connecting to upstream</td><td>nginx与upstream建立tcp连接超时，nginx默认连接建立超时为200ms</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>1</td><td>upstream timed out (110: Connection timed out) while reading response header from upstream</td><td>nginx从upstream读取响应时超时，nginx默认的读超时为20s，读超时不是整体读的时间超时，而是指两次读操作之间的超时，整体读耗时有可能超过20s</td><td>排查upstream响应请求为什么过于缓慢</td></tr><tr><td>2</td><td>connect() failed (104: Connection reset by peer) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被reset</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td>2</td><td>connect() failed (111: Connection refused) while connecting to upstream</td><td>nginx与upstream建立tcp连接时被拒</td><td>排查upstream是否能正常建立tcp连接</td></tr><tr><td><strong>3</strong></td><td><strong>no live upstreams while connecting to upstream</strong></td><td><strong>nginx向upstream转发请求时发现upstream状态全都为down</strong></td><td><strong>排查nginx的upstream的健康检查为什么失败</strong></td></tr><tr><td>4</td><td>upstream prematurely closed connection</td><td>nginx在与upstream建立完tcp连接之后，试图发送请求或者读取响应时，连接被upstream强制关闭</td><td>排查upstream程序是否异常，是否能正常处理http请求</td></tr><tr><td>5</td><td>recv() failed (104: Connection reset by peer) while reading response header from upstream</td><td>nginx从upstream读取响应时连接被对方reset</td><td>排查upstream应用已经tcp连接状态是否异常</td></tr><tr><td>6</td><td>client intended to send too large body</td><td>客户端试图发送过大的请求body，nginx默认最大允许的大小为1m，超过此大小，客户端会受到http 413错误码</td><td>调整请求客户端的请求body大小；调大相关域名的nginx配置：client_max_body_size；</td></tr><tr><td>7</td><td>upstream sent no valid HTTP/1.0 header</td><td>nginx不能正常解析从upstream返回来的请求行</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;性能概念TPS、QPS、RPS&quot;&gt;&lt;a href=&quot;#性能概念TPS、QPS、RPS&quot; class=&quot;headerlink&quot; title=&quot;性能概念TPS、QPS、RPS&quot;&gt;&lt;/a&gt;性能概念TPS、QPS、RPS&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
      <category term="PHP-FPM" scheme="https://blog.zhimma.com/categories/Nginx/PHP-FPM/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
      <category term="PHP-FPM" scheme="https://blog.zhimma.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>Lumen接入Azure的blob存储配置</title>
    <link href="https://blog.zhimma.com/2019/08/16/Lumen%E6%8E%A5%E5%85%A5Azure%E7%9A%84blob%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.zhimma.com/2019/08/16/Lumen接入Azure的blob存储配置/</id>
    <published>2019-08-16T06:42:41.000Z</published>
    <updated>2019-12-02T04:01:12.210Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近在做的一个项目使用的是Azure服务器，其中数据库、redis、和对象存储和国内厂商都有不同，最直观的区别就是Azure基本都是SSL方式进行连接，相对国内云服务器厂商的服务接入没有那么无脑，今天简单记录下Azure提供的blob存储在lumen框架的接入</p><h3 id="几个轮子"><a href="#几个轮子" class="headerlink" title="几个轮子"></a>几个轮子</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer require league/flysystem</span><br><span class="line">composer require league/flysystem-azure-blob-storage</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Laravel/Lumen 提供了很强大的文件管理系统和云存储功能的集成</p><p><code>/Users/zhimma/Data/www/lumen/vendor/laravel/lumen-framework/config</code>目录复制一份到项目根目录下,主要检查<code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code>这个文件是否存在</p><p>下面进行配置：</p><ol><li><p><code>/Users/zhimma/Data/www/lumen/config/filesystems.php</code></p><p>在配置s3下方添加如下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">'azure'</span> =&gt; [</span><br><span class="line">    <span class="string">'driver'</span>    =&gt; <span class="string">'azure'</span>,</span><br><span class="line">    <span class="string">'name'</span>      =&gt; env(<span class="string">'AZURE_STORAGE_NAME'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">    <span class="string">'key'</span>       =&gt; env(<span class="string">'AZURE_STORAGE_KEY'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">    <span class="string">'container'</span> =&gt; env(<span class="string">'AZURE_STORAGE_CONTAINER'</span>, <span class="string">'xxx'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p><code>/Users/zhimma/Data/www/lumen/bootstrap/app.php</code></p><ol><li>添加<code>$app-&gt;configure(&#39;filesystems&#39;);</code>表示加载该配置文件项</li><li>添加<code>$app-&gt;register(\Illuminate\Filesystem\FilesystemServiceProvider::class);</code>加载该服务提供者</li></ol></li><li><p><code>/Users/zhimma/Data/www/lumen/app/Providers/AppServiceProvider.php</code></p><p>新增下面的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Storage::extend(<span class="string">'azure'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app, $config)</span> </span>&#123;</span><br><span class="line">        $endpoint = sprintf(<span class="string">'DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=%s;EndpointSuffix=core.chinacloudapi.cn'</span>,</span><br><span class="line">            $config[<span class="string">'name'</span>], $config[<span class="string">'key'</span>], $config[<span class="string">'url'</span>] ?? <span class="keyword">null</span>, $config[<span class="string">'prefix'</span>] ?? <span class="keyword">null</span>);</span><br><span class="line">        $client = BlobRestProxy::createBlobService($endpoint);</span><br><span class="line">        $adapter = <span class="keyword">new</span> AzureBlobStorageAdapter($client, $config[<span class="string">'container'</span>], $config[<span class="string">'prefix'</span>] ?? <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filesystem($adapter);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems" target="_blank" rel="noopener">https://learnku.com/docs/laravel/5.5/filesystem/1319#custom-filesystems</a></p></li></ol><h3 id="上传测试"><a href="#上传测试" class="headerlink" title="上传测试"></a>上传测试</h3><p>新增好路由后，我们进行上传测试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>  zhimma</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>    2019/5/27 12:00 PM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!$request-&gt;hasFile(<span class="string">'file'</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        $file = $request-&gt;file(<span class="string">'file'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!$file-&gt;isValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>($file-&gt;getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        $path = Storage::put(date(<span class="string">'Ymd'</span>), $file);</span><br><span class="line">        $url = env(<span class="string">'AZURE_BLOB_URL'</span>).<span class="string">'/'</span>.env(<span class="string">'AZURE_STORAGE_CONTAINER'</span>).<span class="string">'/'</span>.$path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success([<span class="string">'url'</span> =&gt; $url]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"httpCode"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">"statusCode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"https://xxx.blob.core.chinacloudapi.cn/xxx/20190816/FKRJQXqo1Rdm77mAW2biuBSaVx12mH4U52NtKlZI.png"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此配置完成</p><p>参考</p><blockquote><p><a href="https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/" target="_blank" rel="noopener">https://matthewdaly.co.uk/blog/2016/10/24/creating-an-azure-storage-adapter-for-laravel/</a></p><p><a href="https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen" target="_blank" rel="noopener">https://stackoverflow.com/questions/56267900/how-to-use-azure-blob-in-lumen</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近在做的一个项目使用的是Azure服务器，其中数据库、redis、和对象存储和国内厂商都有不同，最直观的区别就是Azure基本都是SSL方式进行连接，相对国内云服务器厂商的服务接入没有那么无脑，今天简单记录下Azure提供的blob存储在lume
      
    
    </summary>
    
      <category term="Azure" scheme="https://blog.zhimma.com/categories/Azure/"/>
    
    
      <category term="Azure" scheme="https://blog.zhimma.com/tags/Azure/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins初始化及常见问题整理</title>
    <link href="https://blog.zhimma.com/2019/06/19/Jenkins%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>https://blog.zhimma.com/2019/06/19/Jenkins初始化及常见问题整理/</id>
    <published>2019-06-19T02:21:41.000Z</published>
    <updated>2019-06-19T09:39:52.885Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="错误异常处理"><a href="#错误异常处理" class="headerlink" title="错误异常处理"></a>错误异常处理</h2><h3 id="1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h"><a href="#1-Failed-to-connect-to-repository-Error-performing-command-git-ls-remote-h" class="headerlink" title="1. Failed to connect to repository : Error performing command: git ls-remote -h"></a>1. Failed to connect to repository : Error performing command: git ls-remote -h</h3><p><strong>产生原因:</strong> </p><p>Jenkins服务器没有安装git</p><p><strong>解决方式：</strong></p><p><strong>1. Jenkins服务器上查看git是否已安装及安装位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ci ~]<span class="comment"># git version</span></span><br><span class="line">-bash: git: <span class="built_in">command</span> not found</span><br><span class="line">[root@ci ~]<span class="comment"># yum install git -y</span></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line">[root@ci ~]<span class="comment"># whereis git</span></span><br><span class="line">git: /usr/bin/git</span><br></pre></td></tr></table></figure><p><strong>2. 打开Jenkins的 主页面 &gt; 系统管理 &gt; Global Tool Configuration</strong></p><p>配置下git 的path   </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs1.gif" alt=""></p><h3 id="2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#2-stdout-stderr-Host-key-verification-failed-fatal-Could-not-read-from-remote-repository-Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists."></a>2. stdout: stderr: Host key verification failed. fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.</h3><p><strong>产生原因:</strong> </p><p>代码仓库没有添加允许jenkins服务器用户拉取代</p><p><strong>解决方式：</strong></p><blockquote><p>创建秘钥可以参考第三个错误的解决步骤</p></blockquote><ul><li><p>检查jenkins服务器ssh key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="comment"># cd .ssh</span></span><br><span class="line">[jenkins@ci ~]<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">-rw-------. 1 root root 1675 Jun 19 11:06 id_rsa</span><br><span class="line">-rw-r--r--. 1 root root  389 Jun 19 11:06 id_rsa.pub</span><br></pre></td></tr></table></figure><p>如果没有文件，则使用下面命令进行创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]<span class="variable">$ssh</span>-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/var/lib/jenkins/.ssh/id_rsa):</span><br><span class="line">// 一路回车即可</span><br></pre></td></tr></table></figure></li><li><p>在代码仓库添加jenkins服务器用户的公钥</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic3.png" alt=""></p></li><li><p>在jenkins管理端创建全局凭证并使用</p><ul><li><p>创建全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/qs2.gif" alt=""></p></li><li><p>使用全局凭证</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic4.gif" alt=""></p></li></ul></li></ul><h3 id="3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied"><a href="#3-Load-key-“-var-lib-jenkins-ssh-id-rsa”-Permission-denied" class="headerlink" title="3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied"></a>3. Load key “/var/lib/jenkins/.ssh/id_rsa”: Permission denied</h3><p><a href="https://blog.csdn.net/cdnight/article/details/81078191" target="_blank" rel="noopener">参考1</a></p><p>这里需要对Jenkins密钥进行配置</p><h4 id="3-1-切换jenkins用户不成功"><a href="#3-1-切换jenkins用户不成功" class="headerlink" title="3-1 切换jenkins用户不成功"></a>3-1 切换jenkins用户不成功</h4><p>jenkins系统本身有bug的，下面切换用户会失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su jenkins</span><br></pre></td></tr></table></figure><p>解决办法如下：</p><p><code>/etc/passwd</code>文件中的<code>/bin/bash</code>被yum安装的时候变成了<code>/bin/false</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic5.png" alt=""></p><p>然后我执行<code>cat /etc/passwd</code>命令，果然被改成了<code>/bin/false</code></p><p><code>cat /etc/passwd</code></p><p>接着执行<code>sudo vim /etc/passwd</code>命令,把<code>false</code>改为<code>bash</code></p><p><code>sudo vim /etc/passwd</code></p><p>改完后使用<code>grep jenkins /etc/passwd</code> 查看下是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins:x:997:995:Jenkins Automation Server:/var/lib/jenkins:/bin/bash</span><br></pre></td></tr></table></figure><h4 id="3-2-su-jenkins-bash-4-2问题"><a href="#3-2-su-jenkins-bash-4-2问题" class="headerlink" title="3-2 su jenkins  bash-4.2问题"></a>3-2 su jenkins  bash-4.2问题</h4><p>当我们切换到jenkins用户后，命令提示符的用户名不是jenkins而变成了<br><code>-bash-4.2#</code></p><p>网上一查，原因是在安装jenkins时，jenkins只是创建了jenkins用户，并没有为其创建home目录。所以系统就不会在创建用户的时候，自动拷贝/etc/skel目录下的用户环境变量文件到用户家目录，也就导致这些文件不存在，出现-bash-4.2#的问题了<br>以下命令是在切换到jenkins用户下执行的！（只是用户现在显示的是-bash-4.2）</p><p>这个时候呢，参考网上的做法我执行下面步骤： </p><ol><li><p>vim ~/.bash_profile<br>执行上面的命令，即使没有.bash_profile文件，linux会自动创建。 </p></li><li><p>然后再添加这句</p><p><code>export PS1=&#39;[\u@\h \W]\$&#39;</code></p></li><li><p>我们最后再刷新.bash_profile文件，使其起作用</p><p><code>source ~/.bash_profile</code></p></li></ol><h4 id="3-2-su-jenkins-bash-4-2再解决"><a href="#3-2-su-jenkins-bash-4-2再解决" class="headerlink" title="3-2 su jenkins  bash-4.2再解决"></a>3-2 su jenkins  bash-4.2再解决</h4><p><a href="https://www.mgchen.com/227.html" target="_blank" rel="noopener">参考</a></p><p>在上面操作后，我使用su jenkins 还是会有bash-4.2界面，只需把命令变为su - jenkins可以解决，同事给了一个其他的方法</p><p>​    将/etc/skel/目录下 .bashrc和 .bash_profile 文件拷贝到用户的家目录下，然后对复制过去的文件授予该用户、用户组权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/skel/.bashrc /var/lib/jenkins/</span><br><span class="line">cp /etc/skel/.bash_profile /var/lib/jenkins/</span><br><span class="line">chown jenkins.jenkins /var/lib/jenkins/.bashrc</span><br><span class="line">chown jenkins.jenkins /var/lib/jenkins/.bash_profile</span><br></pre></td></tr></table></figure><p>​    然后退出重新登录，就恢复正常了。</p><p><strong>/etc/skel/目录作用：</strong></p><p>​       用来存放新用户环境变量文件，添加新用户时，将该目录下文件拷贝到新用户家目录中。</p><p>​       默认情况下该目录下都是隐藏文件（以.点开头的文件）；</p><p>​       通过修改、添加、删除该目录下的文件，可为新添加的用户提供统一的、标准的、初始化用户环境。</p><p>####3-3 su jenkins  需要输密码</p><p>上面我们解决了bash-4.2，下次从root切换jenkins用户的时候，发现需要输入密码，下面解决下这个错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>添加<code>jenkins ALL=(ALL) NOPASSWD: ALL</code></p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/Jenkins/pic6.png" alt=""></p><p>然后执行<code>/etc/init.d/jenkins restart</code></p><h4 id="3-4-Jenkins密钥配置"><a href="#3-4-Jenkins密钥配置" class="headerlink" title="3-4 Jenkins密钥配置"></a>3-4 Jenkins密钥配置</h4><p><code>su - jenkins</code>切换到jenkins用户后，使用下面命令生成秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@ci ~]$ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/var/lib/jenkins/.ssh/id_rsa):</span><br><span class="line">// 一路回车即可</span><br></pre></td></tr></table></figure><p>生成后，</p><ol><li>把公钥添加到代码管理工具gitlab或者其他平台，使得jenkins用户有权限拉取代码</li><li>把公钥添加到需要发布代码的服务器，使得jenkins所在服务器有权限进行scp 或 ssh操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;错误异常处理&quot;&gt;&lt;a href=&quot;#错误异常处理&quot; class=&quot;headerlink&quot; title=&quot;错误异常处理&quot;&gt;&lt;/a&gt;错误异常处理&lt;/h2&gt;&lt;h3 id=&quot;1-Failed-to-connect-to-repository-Er
      
    
    </summary>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Go零零碎碎</title>
    <link href="https://blog.zhimma.com/2019/06/17/Go%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
    <id>https://blog.zhimma.com/2019/06/17/Go零零碎碎/</id>
    <published>2019-06-17T09:08:40.000Z</published>
    <updated>2019-07-22T08:26:17.708Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型：基本数据类型int、float、bool、string、数组和结构体struct都属于值类型,使用这些类型的变量是直接使用指向存在内存中的值，值类型的变量的值通常存储在栈中</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型：指针、slice切片、map、管道chan、interface等都是引用类型</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>golang的统一编码为utf-8，golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8，所以字母数字占一字节，汉字占3字节</p><p>要获取一个字符串的长度，有以下2种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 芝麻开门"</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">"str 的长度:"</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"str 的RuneCountInString长度:"</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">"str 的rune convert长度："</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang中还有一个<strong>byte</strong>数据类型，与<strong>rune</strong>相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于int8，常用来处理ascii字符</li><li>rune 等同于int32，常用来处理unicode或utf-8字符</li><li>循环一个字符串时，如果有中文，需要转切片，不然会出现乱码，因为是按照字符串的字节长度遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 芝麻开门"</span></span><br><span class="line"><span class="comment">// 返回字符串的长度，相当于PHP的strlen</span></span><br><span class="line">fmt.Println(<span class="string">"str 的长度:"</span>, <span class="built_in">len</span>(str))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"str 的RuneCountInString长度:"</span>, utf8.RuneCountInString(str))</span><br><span class="line">fmt.Println(<span class="string">"str 的rune convert长度："</span>, <span class="built_in">len</span>([]<span class="keyword">rune</span>(str)))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">runeStr := []<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runeStr); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, runeStr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">str 的长度: 18</span></span><br><span class="line"><span class="comment">str 的RuneCountInString长度: 10</span></span><br><span class="line"><span class="comment">str 的rune convert长度： 10</span></span><br><span class="line"><span class="comment">h</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">芝</span></span><br><span class="line"><span class="comment">麻</span></span><br><span class="line"><span class="comment">开</span></span><br><span class="line"><span class="comment">门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 字符串函数</span></span><br><span class="line"><span class="comment">// 判断一个字符串是否包含指定的字符串</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计一个字符串有几个指定的字符，判断字符重复次数</span></span><br><span class="line">fmt.Println(strings.Count(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较：不区分大小写==</span></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">"hello world"</span>, <span class="string">"Hello World"</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串第一次出现的index值</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串在另一个字符串最后一次出现的位置</span></span><br><span class="line">fmt.Println(strings.LastIndex(<span class="string">"hello world"</span>, <span class="string">"o"</span>)) <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换 n=-1表示全部替换</span></span><br><span class="line">fmt.Println(strings.Replace(<span class="string">"hello world"</span>, <span class="string">"hello"</span>, <span class="string">"你好"</span>, <span class="number">1</span>)) <span class="comment">// 你好 world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查分字符串为数组，类似PHP中的explode</span></span><br><span class="line">strArr := strings.Split(<span class="string">"hello world"</span>, <span class="string">"o w"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"strArr 类型 %T,值%v\n"</span>, strArr, strArr) <span class="comment">// strArr 类型 []string,值[hell orld]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr); i++ &#123;</span><br><span class="line">fmt.Println(strArr[i])</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hell</span></span><br><span class="line"><span class="comment">orld</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字符串大小写转换</span></span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">"HELLO WORLD"</span>)) <span class="comment">// hello world</span></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">"hello world"</span>)) <span class="comment">// HELLO WORLD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串两边的字符</span></span><br><span class="line">fmt.Println(strings.TrimRight(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>)) <span class="comment">// ~hello world</span></span><br><span class="line">fmt.Println(strings.TrimLeft(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>))  <span class="comment">// hello world~</span></span><br><span class="line">fmt.Println(strings.Trim(<span class="string">"~hello world~"</span>, <span class="string">"~"</span>))      <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 评断字符串头尾是否存在指定字符</span></span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">"hello world"</span>, <span class="string">"hello"</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join联合组合字符串</span></span><br><span class="line">fmt.Println(strings.Join(strArr, <span class="string">"o w"</span>)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">fmt.Println(strings.Repeat(<span class="string">"go "</span>, <span class="number">3</span>)) <span class="comment">// go go go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义并初始化一个长度为3的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr, arr1) <span class="comment">// [1 2 3] [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个长度为6的数组，最后一个元素值为-1</span></span><br><span class="line">arr2 := [...]<span class="keyword">int</span>&#123;<span class="number">5</span>: <span class="number">-1</span>&#125;</span><br><span class="line">fmt.Println(arr2) <span class="comment">// [0 0 0 0 0 -1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个长度为3的int型数组，初始值是3个0,数组“零值”状态</span></span><br><span class="line"><span class="keyword">var</span> arr3 [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(arr3) <span class="comment">// [0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line">arr4 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">arr5 := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;, &#123;<span class="string">"AA"</span>, <span class="string">"BB"</span>&#125;, &#123;<span class="string">"AAA"</span>, <span class="string">"BBB"</span>&#125;&#125;</span><br><span class="line">fmt.Println(arr4, arr5) <span class="comment">// [[0 0] [0 0] [0 0]] [[a b] [AA BB] [AAA BBB]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new声明数组</span></span><br><span class="line">arr6 := <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr6类型%T，值%v"</span>, arr6, arr6) <span class="comment">// arr6类型*[3]int，值&amp;[0 0 0]</span></span><br><span class="line"></span><br><span class="line">arr7 := <span class="built_in">new</span>([<span class="number">2</span>]<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr7类型%T，值%v"</span> , arr7 , arr7) <span class="comment">// arr7类型*[2]int，值&amp;[0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">for_range</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">string</span>&#123;<span class="string">"go"</span>, <span class="string">"php"</span>, <span class="string">"java"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">"key = %v , value = %v"</span>, key, value)</span><br><span class="line"><span class="comment">// key = 0 , value = gokey = 1 , value = phpkey = 2 , value = java</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h3><h4 id="定义和创建"><a href="#定义和创建" class="headerlink" title="定义和创建"></a>定义和创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   sliceDemo1()</span><br><span class="line">   sliceDemo2()</span><br><span class="line">   sliceDemo3()</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo1() &#123;</span><br><span class="line">   var arr [5]int = [...]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">   var slice = arr[1:3]</span><br><span class="line">   // slice value=[2 3] , cap=4 , len=2</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo2() &#123;</span><br><span class="line">   var slice []int = make([]int, 5, 10)</span><br><span class="line">   fmt.Println(slice) // [0 0 0 0 0]</span><br><span class="line">   slice[1] = 5</span><br><span class="line">   slice[3] = 10</span><br><span class="line">   // slice value=[0 5 0 10 0] , cap=10 , len=5</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br><span class="line">func sliceDemo3() &#123;</span><br><span class="line">   // 声明和初始化一个切片</span><br><span class="line">   var slice []string = []string&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;</span><br><span class="line">   fmt.Printf(&quot;slice value=%v , cap=%v , len=%v&quot;, slice, cap(slice), len(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三种方式说明及区别"><a href="#三种方式说明及区别" class="headerlink" title="三种方式说明及区别"></a>三种方式说明及区别</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>sliceDemo1</strong>：让切片引用一个已经存在的数组创建切片</p><p><strong>sliceDemo2</strong>：使用make来创建，可以指定切片的大小和容量，如果没有给切片赋值，则会使用默认值，(int、float=&gt;0, strint=&gt;””, bool=&gt;false)；make方式创建的切片对应的数组由make底层维护，对外不开见，只能通过slice访问各个元素</p><p><strong>sliceDemo3</strong>：定义一个切片直接指定具体数组</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>sliceDemo1方式是直接引用数组，这个数组是事先存在的，对程序员可见</p><p>sliceDemo2通过make创建切片，make也会创建一个数组，是由切片在底层维护，该数组对程序员不可见    </p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [<span class="number">8</span>]<span class="keyword">int</span>&#123;<span class="number">22</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">55</span>, <span class="number">54</span>, <span class="number">33</span>&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    [1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">[1 22 23 31 33 44 54 55]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">fmt.Println(bubble1(arr))</span><br><span class="line">fmt.Println(bubble2(arr))</span><br><span class="line">fmt.Println(bubble3(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble1</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8] <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">fmt.Println(data[i])</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble2</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(data); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] &gt; data[j] &#123;</span><br><span class="line">tmp := data[i]</span><br><span class="line">data[i] = data[j]</span><br><span class="line">data[j] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubble3</span><span class="params">(data [8]<span class="keyword">int</span>)</span> [8]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(data)<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[j] &gt; data[j+<span class="number">1</span>] &#123;</span><br><span class="line">tmp := data[j]</span><br><span class="line">data[j] = data[j+<span class="number">1</span>]</span><br><span class="line">data[j+<span class="number">1</span>] = tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map相当于PHP中的关联数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mapDemo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 声明方式1</span></span><br><span class="line">   <span class="keyword">var</span> map1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   map1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">   map1[<span class="string">"name"</span>] = <span class="string">"zhimma"</span></span><br><span class="line">   map1[<span class="string">"address"</span>] = <span class="string">"xian"</span></span><br><span class="line">   fmt.Println(map1) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式2</span></span><br><span class="line">   map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   map2[<span class="string">"name"</span>] = <span class="string">"zhimma"</span></span><br><span class="line">   map2[<span class="string">"address"</span>] = <span class="string">"xian"</span></span><br><span class="line">   fmt.Println(map2) <span class="comment">// map[name:zhimma address:xian]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明方式3</span></span><br><span class="line">   map3 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">      <span class="string">"name"</span>:    <span class="string">"zhimma"</span>,</span><br><span class="line">      <span class="string">"address"</span>: <span class="string">"xian"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(map3) <span class="comment">// // map[name:zhimma address:xian]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针相关概念"><a href="#指针相关概念" class="headerlink" title="指针相关概念"></a>指针相关概念</h2><p><strong>变量</strong>：变量是基本类型，变量存的就是值，也叫值类型</p><p><strong>地址</strong>：用于引用计算机的内存地址，可理解为内存地址的标签，通俗一点讲就是一个房子在小区门牌号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量name并赋值</span></span><br><span class="line">name := <span class="string">"zhimma"</span></span><br><span class="line">fmt.Println(<span class="string">"name 的地址是"</span>, &amp;name) <span class="comment">// name 的地址是 0xc000092030</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针</strong>：指针变量存的是一个<strong>地址</strong>，这个地址指向的空间存的才是值，指针是一个指向另一个变量内存地址的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"i 的地址是"</span>, &amp;i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">"ptr=%v\n"</span>, ptr)</span><br><span class="line">fmt.Printf(<span class="string">"ptr的地址是%v\n"</span>, &amp;ptr)</span><br><span class="line">fmt.Printf(<span class="string">"ptr指向的值是%v\n"</span>, *ptr)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    i 的地址是 0xc00001a080</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">ptr=0xc00001a080</span></span><br><span class="line"><span class="comment">ptr的地址是0xc00000c030</span></span><br><span class="line"><span class="comment">ptr指向的值是1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&amp;:取地址符，指针 := &amp;变量</p><p><em>:取值符， 变量 := </em>指针</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>定义匿名函数有2种方式</p><ul><li><p>定义时直接使用（这种方式只使用一次）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">totalNum := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(totalNum) <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将匿名函数赋值给变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数赋值给变量sunFunc</span></span><br><span class="line">sumFunc := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">total := sumFunc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局匿名函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globalFunc = <span class="function"><span class="keyword">func</span><span class="params">(params <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"this is globalFunc and receive params str is'"</span> + params + <span class="string">"'"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := globalFunc(<span class="string">"hello world"</span>)</span><br><span class="line">fmt.Println(str) <span class="comment">// this is globalFunc and receive params str is'hello world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数用来分配内存，主要分配值类型，比如int、float32、struct等，返回的是指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num 的类型是%T,值是%v,地址是%v"</span>, num, num, &amp;num) </span><br><span class="line">    <span class="comment">// num 的类型是int,值是100,地址是0xc00001a178</span></span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"num1 的类型是%T,值是%v,地址是%v"</span>, num1, num1, &amp;num1)                </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a190,地址是0xc00000c030</span></span><br><span class="line">fmt.Printf(<span class="string">"num1 的类型是%T,值是%v,地址是%v,指向的值是%v"</span>, num1, num1, &amp;num1, *num1) </span><br><span class="line">    <span class="comment">// num1 的类型是*int,值是0xc00001a098,地址是0xc00000c030,指向的值是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;常见数据类型&quot;&gt;&lt;a href=&quot;#常见数据类型&quot; class=&quot;headerlink&quot; title=&quot;常见数据类型&quot;&gt;&lt;/a&gt;常见数据类型&lt;/h2&gt;&lt;h3 id=&quot;值类型&quot;&gt;&lt;a href=&quot;#值类型&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker数据管理-volume/bind mount/tmpfs mount</title>
    <link href="https://blog.zhimma.com/2019/04/10/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-volume-bind-mount-tmpfs-mount/"/>
    <id>https://blog.zhimma.com/2019/04/10/Docker数据管理-volume-bind-mount-tmpfs-mount/</id>
    <published>2019-04-10T03:11:26.000Z</published>
    <updated>2019-04-10T03:39:30.009Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><code>数据卷</code>是一个可供一个或多个容器使用的特殊目录，它绕过<code>UFS</code>，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><h2 id="v-mount-如何选择"><a href="#v-mount-如何选择" class="headerlink" title="-v/-mount 如何选择"></a>-v/-mount 如何选择</h2><p>最初，<code>-v</code> 和 <code>-volume</code> 用于独立的容器，<code>--mount</code> 用于 swarm server。但 docker 17.06 之后，也可以使用 <code>--mount</code>。两者的区别在于，<code>-v</code> 将所有选项组合在一个字段中，<code>--mount</code> 则将它们分开。</p><blockquote><p>新用户应使用 <code>--mount</code> 语法，老用户推荐使用 <code>--mount</code>。</p></blockquote><ul><li><code>-v/--volume</code>，由（<code>:</code>）分隔的三个字段组成，<code>&lt;卷名&gt;:&lt;容器路径&gt;:&lt;选项列表&gt;</code>。选项列表，如：<code>ro</code>只读。</li><li><code>--mount</code>，由多个键值对组成，由<code>,</code>分隔，每个由一个<code>&lt;key=&lt;value&gt;&gt;</code>元组组成。<ul><li><code>type</code>，值可以为 <code>bind</code>，<code>volume</code>，<code>tmpfs</code>。</li><li><code>source</code>，对于命名卷，是卷名。对于匿名卷，这个字段被省略。可能被指定为 <code>source</code> 或 <code>src</code>。</li><li><code>destination</code>，文件或目录将被挂载到容器中的路径。可以指定为 <code>destination</code>，<code>dst</code> 或 <code>target</code>。</li><li><code>volume-opt</code> 可以多次指定。</li></ul></li></ul><h2 id="选择合适的挂载方式"><a href="#选择合适的挂载方式" class="headerlink" title="选择合适的挂载方式"></a>选择合适的挂载方式</h2><p>Docker提供了3种方法将数据从Docker宿主机挂载（mount）到容器：<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>。一般来说，<code>volumes</code>总是最好的选择。</p><p>不管你选择哪种挂载方式，从容器中看都是一样的。数据在容器的文件系统中被展示为一个目录或者一个单独的文件。</p><p>一个简单区分<code>volumes</code>，<code>bind mounts</code>和<code>tmpfs mounts</code>不同点的方法是：<strong>思考数据在宿主机上是如何存在的。</strong></p><ul><li><strong>Volumes</strong>由Docker管理，存储在宿主机的某个地方（在linux上是<code>/var/lib/docker/volumes/</code>）。非Docker应用程序不能改动这一位置的数据。Volumes是Docker最好的数据持久化方法。</li><li><strong>Bind mounts</strong>的数据可以存放在宿主机的任何地方。数据甚至可以是重要的系统文件或目录。非Docker应用程序可以改变这些数据。</li><li><strong>tmpfs mounts</strong>的数据只存储在宿主机的内存中，不会写入到宿主机的文件系统。</li></ul><h2 id="详细对比"><a href="#详细对比" class="headerlink" title="详细对比"></a>详细对比</h2><p><strong>Volumes</strong>：由Docker创建和管理。你可以通过<code>docker volume create</code>命令显式地创建<code>volume</code>，Docker也可以在创建容器或服务是自己创建volume。</p><p>例如下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">☁  Docker  docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name demo \</span><br><span class="line">  --mount type=volume,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line">7eb04d34a87ecd4a7996f8ad4da83bd613d2e992f6860faf730b876a66efd19f</span><br><span class="line">☁  Docker  docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               0c06952c157c3b6550e7f71a9c6463a1b70c893c15b0d8e0b8d05ad398ced427</span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure><blockquote><p>第一行：先查看下volume列表</p><p>第四行：创建container，并使用type=volume类型，指向container内部app目录</p><p>第十行：查看最新的volume列表</p></blockquote><p>当你创建了一个volume，它会被存放在宿主机的一个目录下。当你将这个volume挂载到某个容器时，这个目录就是挂载到容器的东西。这一点和<code>bind mounts</code>类似，除了volumes是由Docker创建的，和宿主机的核心（<code>core functionality</code>）隔离。</p><p>一个volume可以同时被挂载到几个容器中。即使没有正在运行的容器使用这个volume，volume依然存在，不会被自动清除。可以通过<code>docker volume prune</code>清除不再使用的volumes。</p><p>volumes也支持<code>volume driver</code>，可以将数据存放在另外的机器或者云上。</p><p><strong>Bind mounts</strong>：Docker早期就支持这个特性。与volumes相比，<code>Bind mounts</code>支持的功能有限。使用<code>bind mounts</code>时，可以将你主机上的任何文件或目录（<strong>绝对路径</strong>）挂载到容器中。</p><blockquote><p>警告：使用<code>Bind mounts</code>的一个副作用是，容器中运行的程序可以修改宿主机的文件系统，包括创建，修改，删除重要的系统文件或目录。这个功能可能会有安全问题。</p></blockquote><p><strong>tmpfs mounts</strong>：<code>tmpfs mounts</code>的数据不会落盘。在容器的生命周期内，它可以被用来存储一些不需要持久化的状态或敏感数据。例如，<code>swarm</code>服务通过<code>tmpfs mounts</code>来将<a href="https://docs.docker.com/engine/swarm/secrets/" target="_blank" rel="noopener">secrets</a>挂载到一个服务的容器中去。</p><h2 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h2><h3 id="适合volume的场景"><a href="#适合volume的场景" class="headerlink" title="适合volume的场景"></a>适合volume的场景</h3><ul><li>在不同的容器中共享数据，如果未显式创建它，则会在第一次将其装入容器时创建。当该容器停止或被移除时，该卷仍然存在。多个容器可以同时安装相同的卷，可以是读写也可以是只读。仅在您明确删除卷时才会删除卷</li><li>当Docker主机不能保证具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时分离。</li><li>如果要将容器的数据存储在远程主机或云提供程序上，而不是本地存储。</li><li>当你需要备份或迁移数据的时候，当您需要能够将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是更好的选择。您可以使用卷停止容器，然后备份卷的目录（例如/var/lib/docker/volumes/）</li></ul><h3 id="适合bind-mounts的场景"><a href="#适合bind-mounts的场景" class="headerlink" title="适合bind mounts的场景"></a>适合bind mounts的场景</h3><ul><li>宿主机和容器共享配置文件。Docker提供的DNS解决方案就是如此，将宿主机的<code>/etc/resolv.conf</code>挂载到每个容器中。</li><li>开发环境需要在宿主机和容器中共享代码。docker的开发就是如此，毕竟容器中一般是没有编辑器的</li><li>当Docker主机的文件或目录结构保证与容器所需的绑定安装一致时</li></ul><h2 id="适合tmpfs-mounts的场景"><a href="#适合tmpfs-mounts的场景" class="headerlink" title="适合tmpfs mounts的场景"></a>适合tmpfs mounts的场景</h2><p><code>tmpfs mounts</code>主要用在你既不想在容器内，又不想在宿主机文件系统保存数据的时候。这可能是出于安全原因，也可能是你的应用需要写非常多的非持久化数据，<code>tmpfs mounts</code>这时候可以保证容器性能。    </p><p>##本文转自<a href="https://michaelyou.github.io/2017/09/17/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-Volume%EF%BC%8C-bind-mount%E5%92%8Ctmpfs-mount/" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数据卷&lt;/code&gt;是一个可供一个或多个容器使用的特殊目录，它绕过&lt;code&gt;UFS&lt;/code&gt;，可以提供很多有用的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据卷 可以在容器之间共享和重用&lt;/li&gt;
&lt;li&gt;对 数据卷 的修改会立马生效&lt;/
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Docker" scheme="https://blog.zhimma.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记8-Go语言并发</title>
    <link href="https://blog.zhimma.com/2019/03/22/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91/"/>
    <id>https://blog.zhimma.com/2019/03/22/Go语言学习笔记8-Go语言并发/</id>
    <published>2019-03-22T06:33:29.000Z</published>
    <updated>2019-03-22T07:53:18.522Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言通过编译器运行时（runtime）,从语言上支持了并发的特性。Go 语言的并发通过goroutine 特性完成。<br>goroutine 类似于线程，但可以根据需要创建多个goroutine并发工作<br>goroutine 是由Go 语言的运行时调度完成，而线程是由操作系统调度完成</p><p>Go 语言还提供channel 在多个goroutine 间进行通信。goroutine 和 channel是Go 语言秉承CSP并发模式的重要实现基础。</p><h2 id="Go-语言goroutine"><a href="#Go-语言goroutine" class="headerlink" title="Go 语言goroutine"></a>Go 语言goroutine</h2><p>在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。<br>开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。</p><p>如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go 语言中被称为 <strong>goroutine</strong>。</p><p>goroutine 的概念类似于线程，但 goroutine 是由Go 程序运行时进行调度和管理。Go 程序会智能地将goroutine 中的任务合理地分配给每个CPU</p><p>Go 程序从main 包的main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的goroutine</p><h3 id="使用普通函数创建-goroutine"><a href="#使用普通函数创建-goroutine" class="headerlink" title="使用普通函数创建 goroutine"></a>使用普通函数创建 goroutine</h3><p>Go 语言程序中使用<strong>go</strong>关键字为一个函数创建一个goroutine。一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数</p><p><strong>格式</strong></p><p>为一个普通函数创建goroutine的写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>使用 <strong>go</strong>关键字创建goroutine时，被调用函数的返回值会被忽略</p><p>如果需要在goroutine中返回数据，需要使用channel特性，通过通道(channel)把数据从goroutine中作为返回值传出</p><p><strong>例子</strong></p><p>使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> running()</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input) <span class="comment">// 接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">running</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times++</span><br><span class="line">fmt.Println(<span class="string">"tick"</span> , times)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行输出如下：<br>tick 1<br>tick 2<br>tick 3<br>tick 4<br>tick 5</p><p>代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。</p><p>这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。</p><h3 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a>使用匿名函数创建goroutine</h3><p>go 关键字后也可以为匿名函数或者闭包启动goroutine</p><p><strong>使用匿名函数创建goroutine</strong></p><p>使用匿名函数或者闭包创建goroutine时，除了将函数定义部分卸载go 的后面之外，还需要加上匿名函数的调用参数，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;(调用参数列表)</span><br></pre></td></tr></table></figure><p><strong>使用匿名函数创建goroutine例子</strong></p><p>在main() 函数中创建一个匿名函数并未匿名函数启动goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">times ++</span><br><span class="line">fmt.Println(<span class="string">"tick"</span> , times)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。</p><p>终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数</p><h2 id="Go语言GOMAXPROCS-调整并发的运行性能"><a href="#Go语言GOMAXPROCS-调整并发的运行性能" class="headerlink" title="Go语言GOMAXPROCS(调整并发的运行性能)"></a>Go语言GOMAXPROCS(调整并发的运行性能)</h2><p>在 Go 程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br></pre></td></tr></table></figure><p>这里的逻辑CPU数量可以有以下几种数值：</p><ul><li>&lt;1不修改任何数值</li><li>=1单核心执行</li><li>>1多喝并发执行</li></ul><p>一般情况下，可以使用 <code>runtime.NumCPU()</code>查询 CPU 数量，并使用<code>runtime.GOMAXPROCS()</code> 函数进行设置，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure><p>GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。</p><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>下面让我们来了解并发和并行之间的区别：</p><ul><li>并发：把任务在不同的时间点交给处理器进行处理，在同一时间点，任务并不会同时运行</li><li>并行：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行</li></ul><p>两个概念的区别是：任务是否同时执行。举一个生活中的例子：打电话和吃饭。</p><p>吃饭时，电话来了，需要停止吃饭去接电话。电话接完后回来继续吃饭，这个过程是并发执行。</p><p>吃饭时，电话来了，边吃饭边接电话。这个过程是并行执行。</p><p>GO 语言在 GOMAXPROCS 数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。</p><h3 id="goroutine-和-coroutine的区别"><a href="#goroutine-和-coroutine的区别" class="headerlink" title="goroutine 和 coroutine的区别"></a>goroutine 和 coroutine的区别</h3><p>coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p><ul><li>goroutine 可能发生并行执行；</li><li>但 coroutine 始终顺序执行。</li></ul><p>狭义的说，</p><p>goroutine 可能发生在多线程环境下，goroutine无法控制自己获取高优先度支持</p><p>coroutine始终发生在单线程，coroutine 程序需要主动交出控制器，宿主才能获得控制权并将控制权交给其他coroutine</p><p>goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。</p><p>coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。</p><p>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p><h2 id="Go语言通道-chan"><a href="#Go语言通道-chan" class="headerlink" title="Go语言通道(chan)"></a>Go语言通道(chan)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言通过编译器运行时（runtime）,从语言上支持了并发的特性。Go 语言的并发通过goroutine 特性完成。&lt;br&gt;goroutine 类似于线程，但可以根据需要创建多个goroutine并发工作&lt;br&gt;goroutine 是由Go 语言的运行时调度完成，而线
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记7-包(package)</title>
    <link href="https://blog.zhimma.com/2019/03/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-%E5%8C%85-package/"/>
    <id>https://blog.zhimma.com/2019/03/20/Go语言学习笔记7-包-package/</id>
    <published>2019-03-20T08:07:57.000Z</published>
    <updated>2019-03-20T10:29:08.045Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>终于学到包了，前面有忘得差不多了，特别是接口，晕晕乎乎的，期待学完之后的项目实战</p><p>Go 语言的源码复用建立在包(package) 基础之上。Go 语言的入口main() 函数所在的包叫main，main 包想要引用别的代码，必须同样以包的方式进行。</p><p>Go 于洋的包与文件夹一一对应，所有与包相关的操作，必须依赖工作目录（GOPATH）</p><h2 id="GOPATH详解"><a href="#GOPATH详解" class="headerlink" title="GOPATH详解"></a>GOPATH详解</h2><p>GOPATH 是Go 语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  go env // 执行 go env 指令，将输出当前 Go 开发包的环境变量状态。 </span><br><span class="line">GOARCH="amd64" // GOARCH 表示目标处理器架构</span><br><span class="line">GOBIN="" // GOBIN 表示编译器和链接器的安装位置。 </span><br><span class="line">GOCACHE="/Users/zhimma/Library/Caches/go-build"</span><br><span class="line">GOEXE=""</span><br><span class="line">GOFLAGS=""</span><br><span class="line">GOHOSTARCH="amd64"</span><br><span class="line">GOHOSTOS="darwin"</span><br><span class="line">GOOS="darwin" // GOOS 表示目标操作系统 </span><br><span class="line">GOPATH="/Users/zhimma/go" // GOPATH 表示当前工作目录</span><br><span class="line">GOPROXY=""</span><br><span class="line">GORACE=""</span><br><span class="line">GOROOT="/usr/local/go" // GOROOT 表示 Go 开发包的安装目录</span><br><span class="line">GOTMPDIR=""</span><br><span class="line">GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"</span><br><span class="line">GCCGO="gccgo"</span><br><span class="line">CC="clang"</span><br><span class="line">CXX="clang++"</span><br><span class="line">CGO_ENABLED="1"</span><br><span class="line">GOMOD=""</span><br><span class="line">CGO_CFLAGS="-g -O2"</span><br><span class="line">CGO_CPPFLAGS=""</span><br><span class="line">CGO_CXXFLAGS="-g -O2"</span><br><span class="line">CGO_FFLAGS="-g -O2"</span><br><span class="line">CGO_LDFLAGS="-g -O2"</span><br><span class="line">PKG_CONFIG="pkg-config"</span><br></pre></td></tr></table></figure><p>在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。</p><table><thead><tr><th>平  台</th><th>GOPATH 默认值</th><th>举 例</th></tr></thead><tbody><tr><td>Windows 平台</td><td>%USERPROFILE%/go</td><td>C:\Users\用户名\go</td></tr><tr><td>Unix 平台</td><td>$HOME/go</td><td>/home/用户名/go</td></tr></tbody></table><h3 id="使用GOPATH的工程结构"><a href="#使用GOPATH的工程结构" class="headerlink" title="使用GOPATH的工程结构"></a>使用GOPATH的工程结构</h3><p>在GOPATH 指定的工作目录下，代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过go build、go install或者go get 等指令后，会将产生的二进制可执行文件放在<code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code>下。</p><p>如果需要将整个源码添加到版本管理工具中时，只需要添加 <code>$GOPATH/src</code> 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</p><h3 id="设置和使用GOPATH"><a href="#设置和使用GOPATH" class="headerlink" title="设置和使用GOPATH"></a>设置和使用GOPATH</h3><p>下面以Linux为例进行演示</p><h4 id="设置当前目录为GOPATH"><a href="#设置当前目录为GOPATH" class="headerlink" title="设置当前目录为GOPATH"></a>设置当前目录为GOPATH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br></pre></td></tr></table></figure><h4 id="建立GOPATH中的源码目录"><a href="#建立GOPATH中的源码目录" class="headerlink" title="建立GOPATH中的源码目录"></a>建立GOPATH中的源码目录</h4><p>使用下面指令创建GOPATH中的src 目录，在src目录下还有一个hello目录，该目录用于保存源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/hello</span><br></pre></td></tr></table></figure><h4 id="添加main-go源码文件"><a href="#添加main-go源码文件" class="headerlink" title="添加main.go源码文件"></a>添加main.go源码文件</h4><p>使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 $GOPATH/src/hello 目录下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译源码并运行"><a href="#编译源码并运行" class="headerlink" title="编译源码并运行"></a>编译源码并运行</h4><p>此时我们已经设定了 GOPATH，因此在 Go 语言中可以通过 GOPATH 找到工程的位置。</p><p>在命令行中执行如下指令编译源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install hello</span><br></pre></td></tr></table></figure><p>编译完成的可执行文件会保存在 $GOPATH/bin 目录下。</p><p>在 bin 目录中执行 ./hello，命令行输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="package-创建包"><a href="#package-创建包" class="headerlink" title="package(创建包)"></a>package(创建包)</h2><p>包 是多个Go 源码的集合，是一种高级的代码复用方案，Go 语言默认为我们提供了很多包，如fmt、os、io包等。</p><p>包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>包的特性如下：</p><ul><li>一个目录下的同级文件归属一个包。</li><li>包名可以与其目录不同名。</li><li>包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。</li></ul><h2 id="包中的标识符"><a href="#包中的标识符" class="headerlink" title="包中的标识符"></a>包中的标识符</h2><p>如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的<strong>首字母大写</strong>就可以让引用者可以访问这些标识符了。</p><h2 id="import-导入包"><a href="#import-导入包" class="headerlink" title="import 导入包"></a>import 导入包</h2><p>要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用<code>/</code>进行路径分隔。</p><h3 id="默认导入的写法"><a href="#默认导入的写法" class="headerlink" title="默认导入的写法"></a>默认导入的写法</h3><p>导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的</p><h4 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h4><p>单行导入格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包2"</span></span><br></pre></td></tr></table></figure><h4 id="2-多行导入"><a href="#2-多行导入" class="headerlink" title="2) 多行导入"></a>2) 多行导入</h4><p>当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"包1"</span></span><br><span class="line">    <span class="string">"包2"</span></span><br><span class="line">    …</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="导入包后自定义引用的包名"><a href="#导入包后自定义引用的包名" class="headerlink" title="导入包后自定义引用的包名"></a>导入包后自定义引用的包名</h3><p>在默认导入包的基础上，在导入包路径前添加标识符即可形成自定义引用包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customName <span class="string">"path/to/package"</span></span><br></pre></td></tr></table></figure><p>其中，path/to/package 为要导入的包路径，customName 为自定义的包名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    renameLib <span class="string">"chapter08/importadd/mylib"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(renameLib.Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h3><p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"path/to/package"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，path/to/package 表示要导入的包名，下画线<code>_</code>表示匿名导入包。</p><p>匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。</p><h3 id="包在程序启动前的初始化入口：init"><a href="#包在程序启动前的初始化入口：init" class="headerlink" title="包在程序启动前的初始化入口：init"></a>包在程序启动前的初始化入口：init</h3><p>在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。</p><p>init() 函数的特性如下：</p><ul><li>每个源码可以使用 1 个 init() 函数。</li><li>init() 函数会在程序执行前（main() 函数执行前）被自动调用。</li><li>调用顺序为 main() 中引用的包，以深度优先顺序初始化。</li></ul><p>例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.init→B.init→A.init→main</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>同一个包中的多个 init() 函数的调用顺序不可预期。</li><li>init() 函数不能被其他函数调用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;终于学到包了，前面有忘得差不多了，特别是接口，晕晕乎乎的，期待学完之后的项目实战&lt;/p&gt;
&lt;p&gt;Go 语言的源码复用建立在包(package) 基础之上。Go 语言的入口main() 函数所在的包叫main，main 包想要引用别的代码，必须同样以
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记6-接口</title>
    <link href="https://blog.zhimma.com/2019/03/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/03/14/Go语言学习笔记6-接口/</id>
    <published>2019-03-14T08:03:29.000Z</published>
    <updated>2019-03-20T08:06:43.078Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p><p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p><p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p><h2 id="Go语言接口声明定义"><a href="#Go语言接口声明定义" class="headerlink" title="Go语言接口声明定义"></a>Go语言接口声明定义</h2><p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p><h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成，接口的形式代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名<span class="number">1</span>(参数列表<span class="number">1</span>) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>(参数列表<span class="number">2</span>) 返回值列表<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各个部分的说明：</p><ul><li><p>接口类型名： 使用 type 将接口定义为自定义的类型名。Go 语言在接口命名时，一并会在单词后面添加 <strong>er</strong>，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer…</p></li><li><p>方法名： 当方法名首字母大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问</p></li><li><p>参数列表、返回值列表： 参数列表和返回值列表中的参数变量名可以被忽略，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> write <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发中常见接口及写法"><a href="#开发中常见接口及写法" class="headerlink" title="开发中常见接口及写法"></a>开发中常见接口及写法</h3><p>Go 语言提供的很多包中都有接口，例如 io 包中提供的Writer 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口可以调用 Write() 方法写入一个字节数组([]byte)，返回值告知写入字节数（n int）和可能发生的错误（err error）</p><h2 id="Go语言实现接口的条件"><a href="#Go语言实现接口的条件" class="headerlink" title="Go语言实现接口的条件"></a>Go语言实现接口的条件</h2><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用</p><h3 id="条件一：接口的方法与实现接口的类型方式格式一致"><a href="#条件一：接口的方法与实现接口的类型方式格式一致" class="headerlink" title="条件一：接口的方法与实现接口的类型方式格式一致"></a>条件一：接口的方法与实现接口的类型方式格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该接口。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><p>数据写入器的抽象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，入参接收interface&#123;&#125; 类型的 data，返回一个 error 结构表示可能发生的错误</span></span><br><span class="line">WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="comment">// file 的 WriteData() 方法使用指针接收器。输入一个 interface&#123;&#125; 类型的 data，返回 error。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *file)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"实现了DataWriter接口的WriteData方法"</span> , data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化结构file</span></span><br><span class="line"><span class="comment">// 实例化 file 赋值给 f，f 的类型为 *file。</span></span><br><span class="line">f := <span class="built_in">new</span>(file)</span><br><span class="line"><span class="comment">// 声明一个DataWriter类型的writer接口变量</span></span><br><span class="line"><span class="keyword">var</span> writer DataWriter</span><br><span class="line"><span class="comment">// 将接口复赋值给f，也就是*file类型</span></span><br><span class="line">    <span class="comment">// 将 *file 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</span></span><br><span class="line">writer = f</span><br><span class="line"><span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">writer.WriteData(<span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p><h4 id="1-函数名不一致导致的报错"><a href="#1-函数名不一致导致的报错" class="headerlink" title="1) 函数名不一致导致的报错"></a>1) 函数名不一致导致的报错</h4><h4 id="2-实现接口的方法签名不一致导致的报错"><a href="#2-实现接口的方法签名不一致导致的报错" class="headerlink" title="2) 实现接口的方法签名不一致导致的报错"></a>2) 实现接口的方法签名不一致导致的报错</h4><h3 id="条件二：接口中所有方法均被实现"><a href="#条件二：接口中所有方法均被实现" class="headerlink" title="条件二：接口中所有方法均被实现"></a>条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p><p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    <span class="comment">// 能否写入</span></span><br><span class="line">    CanWrite() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (<span class="keyword">type</span> *file) as <span class="keyword">type</span> DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></table></figure><p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p><p>Go 语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p><p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p><h2 id="Go语言类型与接口的关系"><a href="#Go语言类型与接口的关系" class="headerlink" title="Go语言类型与接口的关系"></a>Go语言类型与接口的关系</h2><p>类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。</p><h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口见彼此独立，不知道对方的实现</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p><p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p><p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Socket 结构的Write方法实现了io.Writer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时，Socket 结构也实现了 io.Close 接口：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6100I14b.jpg" alt=""></p><p>在代码中使用Socket结构实现的Writer接口和Closer接口代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingWriter</span><span class="params">(writer io.Writer)</span></span> &#123;</span><br><span class="line">writer.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingCloser</span><span class="params">(closer io.Closer)</span></span> &#123;</span><br><span class="line">closer.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(Socket)</span><br><span class="line">usingWriter(s)</span><br><span class="line">usingCloser(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个服务需要满足能够开启和写日志的功能</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()  <span class="comment">// 开启服务</span></span><br><span class="line">    Log(<span class="keyword">string</span>)  <span class="comment">// 日志输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日志器 定义能输出日志的日志器结构。</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(l <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 GameService 结构。</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">    Logger  <span class="comment">// 在 GameService 中嵌入 Logger 日志器，以实现日志功能。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现Service的Start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Service = <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></table></figure><p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>Go语言中不同结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口</p><p>接口与接口嵌套组合而成了新接口，只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用</p><h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go 语言的io 包中定义写入器（Writer）、关闭器（Closer）和写入关闭器（WriteClose）3个接口，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WriterCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</span></span><br><span class="line"><span class="keyword">var</span> wc io.WriteCloser = <span class="built_in">new</span>(device)</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">wc.Write(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeOnly io.Writer = <span class="built_in">new</span>(device)</span><br><span class="line"></span><br><span class="line">writeOnly.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) io.WriteCloser的实现及调用过程如图 1 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ61125141Z.jpg" alt="img"></p><p>2) io.Writer 的实现调用过程如图 2 所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180816/1-1PQ6112952232.jpg" alt="img"></p><p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。&lt;/p&gt;
&lt;p&gt;Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记5-结构体</title>
    <link href="https://blog.zhimma.com/2019/03/12/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://blog.zhimma.com/2019/03/12/Go语言学习笔记5-结构体/</id>
    <published>2019-03-12T07:16:13.000Z</published>
    <updated>2019-03-14T08:00:27.289Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型<br>Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性</p><p>Go 语言中的类型可以被实例化，使用<code>new</code> 或<code>&amp;</code>构造的类型实例的类型是类型的指针</p><p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p><ul><li>字段拥有自己的类型和值</li><li>字段名必须唯一</li><li>字段的类型也可以是结构体，甚至是字段所在结构体的类型</li></ul><p><strong>关于 Go 语言的类(class)</strong></p><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p><p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的<strong>内嵌</strong>配合<strong>接口</strong>比面向对象具有更高的扩展性和灵活性。</p><p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法</p><h2 id="Go-语言结构体定义"><a href="#Go-语言结构体定义" class="headerlink" title="Go 语言结构体定义"></a>Go 语言结构体定义</h2><p>Go 语言的关键字<strong>type</strong> 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使用结构体更便于使用</p><p>结构体的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">    y <span class="keyword">int</span></span><br><span class="line">    xx, yy <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言实例化结构体-结构体分配内存并初始化"><a href="#Go语言实例化结构体-结构体分配内存并初始化" class="headerlink" title="Go语言实例化结构体-结构体分配内存并初始化"></a>Go语言实例化结构体-结构体分配内存并初始化</h3><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。因此必须在定义结构体并实例化后才能使用结构体的字段</p><p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的</p><p>Go 语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p><h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整形、字符串等类型一样，以var 的方式声明结构体即可完成实例化</p><p>基本实例化格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ins T</span><br></pre></td></tr></table></figure><p>其中，T 为结构体类型，ins 为结构体的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p point</span><br><span class="line">p.x = <span class="number">10</span></span><br><span class="line">p.y = <span class="number">20</span></span><br><span class="line">fmt.Println(p) <span class="comment">// &#123;10 20&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针类型的结构体"><a href="#指针类型的结构体" class="headerlink" title="指针类型的结构体"></a>指针类型的结构体</h3><p>Go 语言中，还可以使用 new 关键字对类型（包括结构体、整形。浮点数。字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体</p><p>使用new 的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 为类型，可以是结构体、整形、字符串等</li><li>ins ：T 类型被实例化后保存到ins 变量中，ins 的类型为 *T，属于指针</li></ul><p>Go 语言让我们可以像访问普通结构体一样使用<code>.</code>访问结构体指针的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    structDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">structDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">Name        <span class="keyword">string</span></span><br><span class="line">HealthPoint <span class="keyword">int</span></span><br><span class="line">MagicPoint  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">factory := <span class="built_in">new</span>(Player)</span><br><span class="line">factory.Name = <span class="string">"鲁班"</span></span><br><span class="line">factory.HealthPoint = <span class="number">300</span></span><br><span class="line">fmt.Println(factory) <span class="comment">// &amp;&#123;鲁班 300 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p><blockquote><p>在 Go 语言中，访问结构体指针的成员变量时可以继续使用<code>.</code>。这是因为 Go 语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。</p></blockquote><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <strong>&amp;</strong> 取地址操作时，视为对该类型进行一次new 的实例化操作，取地址格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T 表示结构体类型</li><li>ins 为结构体的实例，类型为 <strong>*T</strong> ，是指针类型</li></ul><p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等。对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span>    <span class="comment">// 指令名称</span></span><br><span class="line">    Var     *<span class="keyword">int</span>    <span class="comment">// 指令绑定的变量</span></span><br><span class="line">    Comment <span class="keyword">string</span>    <span class="comment">// 指令的注释</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">cmd := &amp;Command&#123;&#125;</span><br><span class="line">cmd.Name = <span class="string">"version"</span></span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = <span class="string">"show version"</span></span><br></pre></td></tr></table></figure><p>取地址实例化是最广泛的一种结构体实例化方式。可以使用函数封装上面的初始化过程，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCommand</span><span class="params">(name <span class="keyword">string</span>, varref *<span class="keyword">int</span>, comment <span class="keyword">string</span>)</span> *<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Command&#123;</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cmd = newCommand(</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Go语言初始化结构体的成员变量"><a href="#Go语言初始化结构体的成员变量" class="headerlink" title="Go语言初始化结构体的成员变量"></a>Go语言初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化。初始化有两种形式：</p><ol><li>字段“键值对”形式</li><li>多个值的列表形式</li></ol><p>键值对形式的初始化适合选择性填充字段较多的结构体；</p><p>多个值的列表形式适合填充字段较少的结构体</p><h3 id="使用键值对初始化结构体"><a href="#使用键值对初始化结构体" class="headerlink" title="使用键值对初始化结构体"></a>使用键值对初始化结构体</h3><p>结构体可以使用<strong>键值对</strong>初始化字段，每个键对应结构体中的一个字段。键的值对应字段需要初始化的值,键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中</p><p>结构体实例化后字段的默认值是字段类型的默认值。例如：数值为 0，字符串为空字符串，布尔为 false，指针为 nil 等</p><h4 id="键值对初始化结构体格式"><a href="#键值对初始化结构体格式" class="headerlink" title="键值对初始化结构体格式"></a>键值对初始化结构体格式</h4><p>如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名&#123;</span><br><span class="line">    字段<span class="number">1</span>: 字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>：字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>结构体类型：定义结构体时的类型名称。</li><li>字段1、字段2：结构体的成员字段名。结构体类型名的字段初始化列表中，字段名只能出现一次。</li><li>字段1的值、字段2的值：结构体成员字段的初始值。</li></ul><blockquote><p>键值之间以<code>:</code>分隔；键值对之间以<code>,</code>分隔。</p></blockquote><h4 id="键值对初始化结构体的例子"><a href="#键值对初始化结构体的例子" class="headerlink" title="键值对初始化结构体的例子"></a>键值对初始化结构体的例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    child *People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relation := &amp;People&#123;</span><br><span class="line">    name: <span class="string">"爷爷"</span>,</span><br><span class="line">    child: &amp;People&#123;</span><br><span class="line">        name: <span class="string">"爸爸"</span>,</span><br><span class="line">        child: &amp;People&#123;</span><br><span class="line">            name: <span class="string">"孩子"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</p></blockquote><h3 id="使用多个值得列表初始化结构体"><a href="#使用多个值得列表初始化结构体" class="headerlink" title="使用多个值得列表初始化结构体"></a>使用多个值得列表初始化结构体</h3><p>Go 语言可以在键值对初始化的基础上忽略键，也就是说，可以使用多个值的列表初始化结构体的字段</p><h4 id="多个值列表初始化结构体的书写格式"><a href="#多个值列表初始化结构体的书写格式" class="headerlink" title="多个值列表初始化结构体的书写格式"></a>多个值列表初始化结构体的书写格式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体名&#123;</span><br><span class="line">    字段<span class="number">1</span>的值，</span><br><span class="line">    字段<span class="number">2</span>的值，</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ul><li>必须初始化结构体的所有字段</li><li>每一个初始值得填充顺序必须与结构体中的声明顺序一致</li><li>键值对与值列表的初始化形式不能混用</li></ul><h4 id="多个值列表初始化结构体的实例"><a href="#多个值列表初始化结构体的实例" class="headerlink" title="多个值列表初始化结构体的实例"></a>多个值列表初始化结构体的实例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province    <span class="keyword">string</span></span><br><span class="line">    City        <span class="keyword">string</span></span><br><span class="line">    ZipCode     <span class="keyword">int</span></span><br><span class="line">    PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">addr := Address&#123;</span><br><span class="line">    <span class="string">"四川"</span>,</span><br><span class="line">    <span class="string">"成都"</span>,</span><br><span class="line">    <span class="number">610000</span>,</span><br><span class="line">    <span class="string">"0"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(addr) <span class="comment">// &#123;四川 成都 610000 0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无需通过 <code>type</code>关键字定义就可以直接使用</p><h4 id="匿名结构体定义格式和初始化写法"><a href="#匿名结构体定义格式和初始化写法" class="headerlink" title="匿名结构体定义格式和初始化写法"></a>匿名结构体定义格式和初始化写法</h4><p>匿名结构体的初始化写法由<strong>结构体定义</strong>和<strong>键值对初始化</strong>两部分组成<br>结构体定义时没有结构体类型名，只有字段和字段类型的定义<br>键值对初始化部分由可选的多个键值对组成，如下格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;&#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>： 字段<span class="number">1</span>的值,</span><br><span class="line">    初始化字段<span class="number">2</span>： 字段<span class="number">2</span>的值,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用匿名结构体的例子"><a href="#使用匿名结构体的例子" class="headerlink" title="使用匿名结构体的例子"></a>使用匿名结构体的例子</h4><p>在本例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data）。打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 打印消息类型, 传入匿名结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsgType</span><span class="params">(msg *<span class="keyword">struct</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    id   <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用动词%T打印msg的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">    msg := &amp;<span class="keyword">struct</span> &#123;  <span class="comment">// 定义部分</span></span><br><span class="line">        id   <span class="keyword">int</span></span><br><span class="line">        data <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;  <span class="comment">// 值初始化部分</span></span><br><span class="line">        <span class="number">1024</span>,</span><br><span class="line">        <span class="string">"hello"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    printMsgType(msg) <span class="comment">// *struct &#123; id int; data string &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义 printMsgType() 函数，参数为 msg，类型为 *struct{id int data string}。因为类型没有使用 type 定义，所以需要在用到的地方每次进行定义。</li><li>第 11 行，使用字符串格式化中的<code>%T</code>动词，将 msg 的类型名打印出来。</li><li>第 15 行，对匿名结构体进行实例化，同时初始化成员。</li><li>第 16 和 17 行，定义匿名结构体的字段。</li><li>第 19 和 20 行，给匿名结构体字段赋予初始值。</li><li>第 22 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li></ul><blockquote><p>匿名结构体的类型名是结构体包含字段成员的详细描述。匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p></blockquote><h2 id="Go语言的构造函数"><a href="#Go语言的构造函数" class="headerlink" title="Go语言的构造函数"></a>Go语言的构造函数</h2><p>Go 语言的类型或结构体没有构造函数的功能，结构体的初始化过程可以使用函数封装实现</p><h3 id="TODO-没搞懂"><a href="#TODO-没搞懂" class="headerlink" title="TODO 没搞懂"></a>TODO 没搞懂</h3><h2 id="Go语言方法和接收器"><a href="#Go语言方法和接收器" class="headerlink" title="Go语言方法和接收器"></a>Go语言方法和接收器</h2><p>Go语言中的方法是一种作用于特定类型变量的函数。这种特定类型变量叫做<strong>接收器(Receiver)</strong></p><p>如果将特定类型理解为结构体或类时，接收器的概念就类似于其他语言中的 this 或者 self</p><p>在Go语言中，接收器的类型可以使任何类型，不仅仅是结构体，任何类型都可以拥有方法</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在 Go 语言中“方法”的概念与其他语言一致，只是 Go 语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</p><h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><h4 id="面向过程实现方法"><a href="#面向过程实现方法" class="headerlink" title="面向过程实现方法"></a>面向过程实现方法</h4><p>面向过程中没有方法 的概念，只能通过结构体和函数，有使用者使用函数参数和调用关系来形成接近方法的概念：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个物品放入背包的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(b *Bag, itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bag := <span class="built_in">new</span>(Bag)</span><br><span class="line">    Insert(bag, <span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert() 函数将 <em>Bag 参数放在第一位，强调 Insert 会操作 </em>Bag 结构体。但实际使用中，并不是每个人都会习惯将操作对象放在首位。一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念。随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p><h3 id="Go语言的结构体方法"><a href="#Go语言的结构体方法" class="headerlink" title="Go语言的结构体方法"></a>Go语言的结构体方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bag)</span> <span class="title">Insert</span><span class="params">(itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">new</span>(Bag)</span><br><span class="line">    b.Insert(<span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法只能有一个接收器，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180815/1-1PQ5135I3337.jpg" alt=""></p><h3 id="接收器-方法作用的目标"><a href="#接收器-方法作用的目标" class="headerlink" title="接收器-方法作用的目标"></a>接收器-方法作用的目标</h3><p>接收器的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收器变量 接收器类型)</span> 方法名<span class="params">(参数列表)</span><span class="params">(返回参数)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对各部分的说明：</p><ul><li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li><li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：格式与函数定义一致。</li></ul><p>接收器根据接收器的类型可以分为指针接收器、非指针接收器。两种接收器在使用时会产生不同的效果。根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p><h4 id="指针类型接收器"><a href="#指针类型接收器" class="headerlink" title="指针类型接收器"></a>指针类型接收器</h4><p>指针类型的接收器由一个结构体的指针组成，更接近与面向对象中的this 或者 self<br>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 定义属性结构</span></span><br><span class="line"><span class="keyword">type</span> Property <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span>  <span class="comment">// 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">SetValue</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 修改p的成员变量</span></span><br><span class="line">    p.value = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化属性</span></span><br><span class="line">    p := <span class="built_in">new</span>(Property)</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    p.SetValue(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 打印值</span></span><br><span class="line">    fmt.Println(p.Value()) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非指针类型接收器"><a href="#非指针类型接收器" class="headerlink" title="非指针类型接收器"></a>非指针类型接收器</h4><p>当方法作用于非指针接收器时，Go 语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义点结构</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非指针接收器的加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(other Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="comment">// 成员值与参数相加后返回新的结构</span></span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X + other.X, p.Y + other.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化点</span></span><br><span class="line">    p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// 与另外一个点相加</span></span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Println(result) <span class="comment">// &#123;3 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改</p><h4 id="指针和非指针接收器的使用"><a href="#指针和非指针接收器的使用" class="headerlink" title="指针和非指针接收器的使用"></a>指针和非指针接收器的使用</h4><p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器。大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p><h2 id="Go语言为任意类型添加方法"><a href="#Go语言为任意类型添加方法" class="headerlink" title="Go语言为任意类型添加方法"></a>Go语言为任意类型添加方法</h2><p>Go语言可以对任何类型添加方法。给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型</p><h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型。之后就可以为自定义类型添加各种方法。我们习惯于使用面向过程的方法判断一个值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将 v 比作整型对象，那么判断 v 值就可以增加一个IsZero() 方法，通过这个方法就可以判断v 值是否为0，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v.IsZero()&#123;</span><br><span class="line">    <span class="comment">// v = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为基本类型添加方法的详细流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 将int定义为MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 为MyInt添加IsZero()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为MyInt添加Add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">Add</span><span class="params">(other <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> other + <span class="keyword">int</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b MyInt = <span class="number">2</span></span><br><span class="line">    fmt.Println(b.IsZero()) <span class="comment">// false</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    fmt.Println(b.Add(<span class="number">2</span>)) <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言类型内嵌和结构体内嵌"><a href="#Go语言类型内嵌和结构体内嵌" class="headerlink" title="Go语言类型内嵌和结构体内嵌"></a>Go语言类型内嵌和结构体内嵌</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为<strong>类型内嵌</strong>或<strong>匿名字段类型内嵌</strong>，写法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">ins := &amp;Data &#123;</span><br><span class="line">    <span class="keyword">int</span>: <span class="number">10</span>，</span><br><span class="line">    <span class="keyword">float32</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="keyword">bool</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型内嵌其实仍然拥有自己的字段名，只是字段名就是其类型本身而已，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个</p><p>结构体实例化后，如果匿名的字段类型为结构体，那么可以直接访问匿名结构体里的所有成员，这种方式被称为结<strong>构体内嵌</strong></p><h3 id="声明结构体内嵌"><a href="#声明结构体内嵌" class="headerlink" title="声明结构体内嵌"></a>声明结构体内嵌</h3><p>结构体类型内嵌比普通类型内嵌的概念复杂一些，下面通过一个实例来理解。</p><p>计算机图形学中的颜色有两种类型，一种是包含红、绿、蓝三原色的基础颜色；另一种是在基础颜色之外增加透明度的颜色。透明度在颜色中叫 Alpha，范围为 0～1 之间。0 表示完全透明，1 表示不透明。使用传统的结构体字段的方法定义基础颜色和带有透明度颜色的过程代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 基础颜色</span></span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 红、绿、蓝三种颜色分量</span></span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整颜色定义</span></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 将基本颜色作为成员</span></span><br><span class="line">    Basic BasicColor</span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    <span class="comment">// 设置基本颜色分量</span></span><br><span class="line">    c.Basic.R = <span class="number">1</span></span><br><span class="line">    c.Basic.G = <span class="number">1</span></span><br><span class="line">    c.Basic.B = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 设置透明度</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 显示整个结构体内容</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c) <span class="comment">// &#123;Basic:&#123;R:1 G:1 B:0&#125; Alpha:1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然合理但是写法很复杂。使用 Go 语言的结构体内嵌写法重新调整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    R, G, B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    BasicColor</span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line">    c.R = <span class="number">1</span></span><br><span class="line">    c.G = <span class="number">1</span></span><br><span class="line">    c.B = <span class="number">0</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第14-16 行，可以直接对 Color 的 R、G、B 成员进行设置，编译器通过 Color 的定义知道 R、G、B 成员来自 BasicColor 内嵌的结构体。</p><h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go 语言的结构体内嵌有如下特性：</p><p><strong>1. 内嵌的结构体可以直接访问其成员变量</strong></p><p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p><p><strong>2. 内嵌结构体的字段名是它的类型名</strong></p><p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Color</span><br><span class="line">c.BasicColor.R = <span class="number">1</span></span><br><span class="line">c.BasicColor.G = <span class="number">1</span></span><br><span class="line">c.BasicColor.B = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p><h2 id="Go语言结构体内嵌模拟类的继承"><a href="#Go语言结构体内嵌模拟类的继承" class="headerlink" title="Go语言结构体内嵌模拟类的继承"></a>Go语言结构体内嵌模拟类的继承</h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p><p>Go 语言 的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p><p>下面的代码使用 Go 语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p><p>人和鸟的特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 可飞行的</span></span><br><span class="line"><span class="keyword">type</span> Flying <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Flying)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can fly"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可行走的</span></span><br><span class="line"><span class="keyword">type</span> Walkable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Walkable)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can calk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 人类能行走</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 鸟类能行走</span></span><br><span class="line">    Flying   <span class="comment">// 鸟类能飞行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化鸟类</span></span><br><span class="line">    b := <span class="built_in">new</span>(Bird)</span><br><span class="line">    fmt.Println(<span class="string">"Bird: "</span>)</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line">    <span class="comment">// 实例化人类</span></span><br><span class="line">    h := <span class="built_in">new</span>(Human)</span><br><span class="line">    fmt.Println(<span class="string">"Human: "</span>)</span><br><span class="line">    h.Walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></table></figure><p>使用 Go 语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go 语言会在编译时检查能否使用这些特性。</p><h2 id="Go语言初始化内嵌结构体"><a href="#Go语言初始化内嵌结构体" class="headerlink" title="Go语言初始化内嵌结构体"></a>Go语言初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p><p>车辆结构的组装和初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引擎</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    Power <span class="keyword">int</span>    <span class="comment">// 功率</span></span><br><span class="line">    Type  <span class="keyword">string</span> <span class="comment">// 类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Car&#123;</span><br><span class="line">        <span class="comment">// 初始化轮子</span></span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: <span class="number">18</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 初始化引擎</span></span><br><span class="line">        Engine: Engine&#123;</span><br><span class="line">            Type:  <span class="string">"1.4T"</span>,</span><br><span class="line">            Power: <span class="number">143</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化内嵌匿名结构体</strong></p><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要<strong>再次声明结构</strong>才能赋予数据。具体请参考下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct &#123;</span><br><span class="line">    Size int</span><br><span class="line">&#125;</span><br><span class="line">// 车</span><br><span class="line">type Car struct &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    // 引擎</span><br><span class="line">    Engine struct &#123;</span><br><span class="line">        Power int    // 功率</span><br><span class="line">        Type  string // 类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    c := Car&#123;</span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: 18,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: struct &#123;</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        &#125;&#123;</span><br><span class="line">            Type:  &quot;1.4T&quot;,</span><br><span class="line">            Power: 143,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%+v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型&lt;br&gt;Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性&lt;/p&gt;
&lt;p&gt;Go 语言中的类型可以被实例化，使用&lt;code&gt;new&lt;/code&gt; 或&lt;co
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记4-函数</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go语言学习笔记4-函数/</id>
    <published>2019-03-07T08:59:45.000Z</published>
    <updated>2019-03-12T07:15:24.688Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p><p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul><li>函数本身可以作为值进行传递。</li><li>支持匿名函数和闭包（closure）。</li><li>函数可以满足接口。</li></ul><h2 id="Go语言函数声明-函数定义"><a href="#Go语言函数声明-函数定义" class="headerlink" title="Go语言函数声明(函数定义)"></a>Go语言函数声明(函数定义)</h2><p>普通函数需要先声明才能调用，一个函数的声明包含参数和函数名等，编译器通过声明才能了解函数应该怎样在调用代码和函数体之间传递参数和返回值</p><h3 id="普通函数的声明形式"><a href="#普通函数的声明形式" class="headerlink" title="普通函数的声明形式"></a>普通函数的声明形式</h3><p>Go语言的函数声明以<code>func</code>标识，后面紧接着函数名、参数列表、返回参数列表及函数体，具体形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对各个部分进行说明：</p><ul><li><p>函数名：由字母、数字、下划线组成。其中，函数名的第一个字母不能为数字，在同一个包内，函数名称不能重复</p><blockquote><p>包(package) 是Go源码的一种组织方式，一个包可以认为是一个文件夹</p></blockquote></li><li><p>参数列表：一个参数由参数变量和参数类型组成，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中，参数列表中的变量作为函数的局部变量而存在。</p></li><li><p>返回参数列表：可以是返回值类型列表，也可以是类似参数列表中变量名和类型名的组合。函数在声明有返回值时，必须在函数体中使用return 语句提供返回值列表</p></li><li><p>函数体：能够被重复调用的代码片段</p></li></ul><h3 id="参数类型的缩写"><a href="#参数类型的缩写" class="headerlink" title="参数类型的缩写"></a>参数类型的缩写</h3><p>在参数列表中，如果有多个参数变量，则以逗号<code>,</code>分隔；如果相邻变量时同类型，则可以将类型省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a ,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，a 和 b 的参数类型均是 int 类型，则可以省略 a 的类型，在 b 后面有类型说明，这个类型也是 a 的类型</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地取得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数中可能发生的错误。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToMysql()</span><br></pre></td></tr></table></figure><p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误。</p><p><strong>Go 语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</strong></p><h4 id="同一类型返回值"><a href="#同一类型返回值" class="headerlink" title="同一类型返回值"></a>同一类型返回值</h4><p>如果返回值是同一类型，则用括号将多个返回值类型括起来，用逗号分割每个返回值的类型</p><p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go 语言支持对返回值进行命名，这样返回值就可以和参数一样拥有参数变量名和类型</p><p>命名的返回值变量的默认值为类型的默认值，即数值为 0 ，字符串为空字符串，布尔值为false，指针为 nil 等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a, b := foo()</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p><p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p><p>Go语言的函数调用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure><p>下面是对各个部分的说明：</p><ul><li>函数名：需要调用的函数名。</li><li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li><li>返回值变量列表：多个返回值使用逗号分隔。</li></ul><h3 id="函数示例-将秒转为具体时间"><a href="#函数示例-将秒转为具体时间" class="headerlink" title="函数示例-将秒转为具体时间"></a>函数示例-将秒转为具体时间</h3><p>在本例中，使用一个数值表示时间中的“秒”值，然后使用<code>resolveTime()</code>函数将传入的秒数转换为天、小时和分钟等时间单位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SecondsPerMinute = <span class="number">60</span></span><br><span class="line"><span class="keyword">var</span> SecondsPerHour = <span class="number">60</span> * SecondsPerMinute</span><br><span class="line"><span class="keyword">var</span> SecondsPerDay = <span class="number">24</span> * SecondsPerHour</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(resolveTime(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">_, hour, minute := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">day, _, _ := resolveTime(<span class="number">1000</span>)</span><br><span class="line">fmt.Println(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveTime</span><span class="params">(seconds <span class="keyword">int</span>)</span> <span class="params">(day, hour, minutes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">day = seconds / SecondsPerDay</span><br><span class="line">hour = seconds / SecondsPerHour</span><br><span class="line">minutes = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中传入参数和返回参数 在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用</p><h2 id="函数变量-把函数作为值保存到变量中"><a href="#函数变量-把函数作为值保存到变量中" class="headerlink" title="函数变量-把函数作为值保存到变量中"></a>函数变量-把函数作为值保存到变量中</h2><p>在Go语言中，函数也是一种类型，可以和其他类型一样被保存在变量中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span> = <span class="title">foo</span></span></span><br><span class="line"><span class="function">    <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"foo func"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言匿名函数"><a href="#Go语言匿名函数" class="headerlink" title="Go语言匿名函数"></a>Go语言匿名函数</h2><p>Go 语言支持匿名函数，即在需要使用函数时在定义函数，匿名函数没有函数名，只有函数体，函数可以被作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式被传递</p><p>匿名函数经常被用于实现回调函数、闭包等</p><h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的定义就是没有名字的普通函数定义</p><h3 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h3><p>匿名函数可以在声明后调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   fmt.Prinln(data) </span><br><span class="line">&#125;(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h3><p>匿名函数体可以被赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>匿名函数的用途非常广泛，匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p><h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现。用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line"></span><br><span class="line">    for _, v := range list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数作为回调函数的设计在 Go 语言的系统包中也比较常见，strings 包中就有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string &#123;</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言函数类型实现接口"><a href="#Go语言函数类型实现接口" class="headerlink" title="Go语言函数类型实现接口"></a>Go语言函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将分别对比<strong>结构体</strong>与<strong>函数</strong>实现<code>接口</code>的过程。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h2 id="Go语言闭包"><a href="#Go语言闭包" class="headerlink" title="Go语言闭包"></a>Go语言闭包</h2><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此简单的说：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></table></figure><p>一个函数类型就像结构体一样，可以被实例化。函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期静态的概念，而闭包是运行期动态的概念。</p><h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上的变量的引用可以进行修改，修改引用的变量就会对变量进行实际的修改。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">fmt.Println(str); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="闭包的记忆效应"><a href="#闭包的记忆效应" class="headerlink" title="闭包的记忆效应"></a>闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addValue</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">value++</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个累加器，初始值1</span></span><br><span class="line">value := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(value()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(value()) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span> , value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个累加器，初始值为1</span></span><br><span class="line">otherValue := addValue(<span class="number">1</span>)</span><br><span class="line">fmt.Println(otherValue()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>value 与 otherValue的函数地址不同，因此它们是两个不同的闭包实例</p></blockquote><p>闭包的记忆效应进程被用于实现类似于设计模式中工厂模式的生成器。</p><h2 id="Go语言可变参数-变参函数"><a href="#Go语言可变参数-变参函数" class="headerlink" title="Go语言可变参数(变参函数)"></a>Go语言可变参数(变参函数)</h2><p>所谓可变参数，是指参数数量不固定的函数形式。<br>Go语言支持可变参数特性，函数声明和调用时没有固定数量的参数，同时也提供了一套方法进行可变参数的多级传参</p><p>Go语音的可变参数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(固定参数列表，v ... T)</span><span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数一般被放置在函数列表的末尾，前面是固定参数列表，当没有固定参数时，所有变量将是可变参数</li><li>v 为可变参数变量，类型为<code>[]T</code>,也就是拥有多个T 元素的 T 类型的切片v 和 T 之前由<code>...</code>组成</li><li>T 为可变参数的类型，当T 为<code>interface{}</code>时，传入的可以使任意类型</li></ul><h3 id="fmt包中的例子"><a href="#fmt包中的例子" class="headerlink" title="fmt包中的例子"></a>fmt包中的例子</h3><p>可变参数有两种类型：所有参数都是可变参数的形式，如<code>fmt.Println</code>,以及部分是可变参数的形式，如 <code>fmt.Printf</code>，可变参数只能出现在参数的后半部分，因此不可变的参数只能放在参数的前半部分。</p><h4 id="所有参数都是可变参数：fmt-Println"><a href="#所有参数都是可变参数：fmt-Println" class="headerlink" title="所有参数都是可变参数：fmt.Println"></a>所有参数都是可变参数：fmt.Println</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Println</code> 在使用时，传入的值类型不收限制，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"string"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="部分参数是可变参数：-fmt-Printf"><a href="#部分参数是可变参数：-fmt-Printf" class="headerlink" title="部分参数是可变参数： fmt.Printf"></a>部分参数是可变参数： fmt.Printf</h4><p><code>fmt.Printf</code> 的第一个参数为参数列表， 后面的参数是可变参数，<code>fmt.Printf</code>函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Printf()</code> 函数在调用时，第一个函数始终必须传入字符串，对应参数是 format，后面的参数数量可以变化</p><h2 id="Go语音defer-延迟执行语句"><a href="#Go语音defer-延迟执行语句" class="headerlink" title="Go语音defer(延迟执行语句)"></a>Go语音defer(延迟执行语句)</h2><p>Go语音的defer 语句会将其后面跟随的语句进行延迟处理。<br>在defer 归属的函数即将返回时，将延迟处理的语句按defer 的逆序进行执行，也就是说，先被defer 的语句最后执行，最后defer 的语句，最后被执行</p><h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"第一行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第二行"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"第三行"</span>)</span><br><span class="line">fmt.Println(<span class="string">"最后一行"</span>)</span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 最后一行</span></span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure><ul><li>代码的延迟顺序与最终执行顺序是反向的</li><li>延迟调用是在 defer 所在函数结束时执行，函数结束可以是正常返回，也可以是出错时返回</li></ul><h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较繁琐的事情，比如打开和关闭文件、和解锁接受请求和回复请求、加锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p><p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理释放资源的问题</p><h4 id="使用-defer-延迟释放资源"><a href="#使用-defer-延迟释放资源" class="headerlink" title="使用 defer 延迟释放资源"></a>使用 defer 延迟释放资源</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟调用close ，此时close 不会被调用</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">info , err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">size := info.Size()</span><br><span class="line"><span class="comment">// defer 机制触发，调用close关闭文件</span></span><br><span class="line"><span class="keyword">return</span>  size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源</p></blockquote><h2 id="Go语言处理运行时错误"><a href="#Go语言处理运行时错误" class="headerlink" title="Go语言处理运行时错误"></a>Go语言处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p><ul><li><p>一个可能造成错误的函数，需要返回值中返回一个错误接口(error) 。如果调用是成功的，错误接口将返回<code>nil</code> , 否则返回错误</p></li><li><p>在函数调用后需要检查错误，如果发生错误，需要进行必要的错误处理</p></li></ul><p>Go 语言没有类似 Java或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做。Go 语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源。同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p><p>Go 语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数。同时，Go 语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p><h2 id="Go语言宕机-panic-，程序终止执行"><a href="#Go语言宕机-panic-，程序终止执行" class="headerlink" title="Go语言宕机(panic)，程序终止执行"></a>Go语言宕机(panic)，程序终止执行</h2><h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go 语言中可以在程序中手动触发宕机，让程序崩溃，这样使开发者可以及时的发现错误，同时减少可能的损失</p><p>Go 语言宕机时，会将堆栈和goroutine 信息输出到控制台，所以宕机也可以方便的知晓发生错误的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crash"</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:4 +0x39</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>panic() 的参数可以是任意类型，后文将提到的 <code>recover</code> 参数会接收从 panic() 中发出的内容。</p><h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当<code>panic()</code> 触发的宕机发生时， <code>panic()</code> 后面的代码将不会被运行，但是在 <code>panic()</code> 函数前面已经运行的<code>defer</code>语句依然会在宕机时发生作用，例如下面的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后执行的事情1"</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crash"</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">宕机后执行的事情1</span></span><br><span class="line"><span class="comment">panic: crash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">/Users/zhimma/go/src/awesomeProject/0312.go:8 +0xf1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宕机时，defer 语句会优先被执行</p><p><u><strong>测试了下，结果好像不一定，有时候先panic,有时候先defer，以后了解了再来补充吧</strong></u></p><h2 id="Go语言恢复-recover-宕机-防止程序崩溃"><a href="#Go语言恢复-recover-宕机-防止程序崩溃" class="headerlink" title="Go语言恢复(recover)宕机,防止程序崩溃"></a>Go语言恢复(recover)宕机,防止程序崩溃</h2><p>无论是代码运行错误，还是由<strong>Runtime</strong>层抛出的 panic 奔溃，还是主动出发的 panic 奔溃，都可以配合<strong>defer</strong> 和 <strong>recover</strong> 实现错误捕捉和恢复，让代码在发生奔溃后允许继续运行</p><p>在其他语言中，宕机往往以异常的形式存在。底层抛出异常，上层逻辑通过 <strong>try/catch</strong> 机制捕获异常，没有被捕获的严重异常会导致宕机，不活的异常可以被忽略，让代码继续运行</p><p>Go 语言没有异常系统，其使用 panic 触发宕机类似其他语言的抛出异常，那么 <strong>recover</strong>  的宕机恢复机制就是对应的 <strong>try/catch</strong> 机制</p><h3 id="让程序崩溃时继续执行"><a href="#让程序崩溃时继续执行" class="headerlink" title="让程序崩溃时继续执行"></a>让程序崩溃时继续执行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> panicContext <span class="keyword">struct</span> &#123;</span><br><span class="line">function <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"开始运行"</span>)</span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"手动宕机前-----"</span>)</span><br><span class="line"><span class="built_in">panic</span>((&amp;panicContext&#123;</span><br><span class="line"><span class="string">"手动触发panic"</span>,</span><br><span class="line">&#125;))</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"手动宕机后"</span>)</span><br><span class="line"></span><br><span class="line">recoverDemo(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"赋值宕机前"</span>)</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">"赋值宕机后"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"结束宕机"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverDemo</span><span class="params">(entry <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 发生宕机时，获取panic传递的上下文并打印</span></span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> runtime.Error: <span class="comment">// 运行时错误</span></span><br><span class="line">fmt.Println(<span class="string">"runtime error"</span>, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"error"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">entry()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开始运行</span><br><span class="line">手动宕机前-----</span><br><span class="line">error &amp;&#123;手动触发panic&#125;</span><br><span class="line">手动宕机后</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">结束宕机</span><br></pre></td></tr></table></figure><h3 id="panic和recover的关系"><a href="#panic和recover的关系" class="headerlink" title="panic和recover的关系"></a>panic和recover的关系</h3><p>panic 和 defer 的组合有如下特性：</p><ul><li>有 panic 没 recover，程序宕机。</li><li>有 panic 也有 recover 捕获，程序不会宕机。执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li></ul><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>虽然 panic/recover 能模拟其他语言的异常机制，但并不建议代表编写普通函数也经常性使用这种特性。</p><p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛直到程序整体崩溃。</p><p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。&lt;/p&gt;
&lt;p&gt;Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。&lt;/p&gt;
&lt;p&gt;Go 语言的函
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记3-流程控制</title>
    <link href="https://blog.zhimma.com/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://blog.zhimma.com/2019/03/07/Go语言学习笔记3-流程控制/</id>
    <published>2019-03-07T06:54:49.000Z</published>
    <updated>2019-03-07T08:58:00.197Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p> Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else (分支结构)"></a>if else (分支结构)</h2><p>在Go语言中可以通过 if 关键字进行条件判断，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p></blockquote><h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>Go 语言规定与 if 匹配的左括号<code>{</code>必须与 if 和表达式放在同一行，如果尝试将<code>{</code>放在其他位置，将会触发编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Connect 是一个带有返回值的函数，<code>err:=Connect()</code> 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p><p><code>err！=nil</code>才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>Go语言中所有的循环类型均可以使用for 关键字来完成</p><p>基于语句和表达式的基本for 循环格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束表达式&#123;</span><br><span class="line">    循环体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环体不停地进行循环，直到条件表达式返回 false 时自动退出循环，执行 for 的<code>}</code>之后的语句</p></blockquote><p>for 循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code> 语句强制退出循环。for 的初始语句、条件表达式、结束语句的详细介绍如下。</p><h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其<strong><u>作用域</u></strong>将被局限在这个for 的范畴内</p><p>注意：初始语句可以被忽略，但是初始语句之后的分号必须填写，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stop := <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; step &gt; <span class="number">0</span>; step-- &#123;</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p><h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>对每次循环开始前计算的表达式，如果表达式为true ,则循环继续，否则结束循环，条件表达式可以被忽略，被忽律条件的条件表达式默认形成无限循环</p><h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; ; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无线循环"><a href="#无线循环" class="headerlink" title="无线循环"></a>无线循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p><h3 id="Demo-九九乘法表"><a href="#Demo-九九乘法表" class="headerlink" title="Demo 九九乘法表"></a>Demo 九九乘法表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">1</span>; x &lt;= <span class="number">9</span>; x++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">1</span>; y &lt;= x; y++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*%d=%d "</span>, x, y, x*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1 </span><br><span class="line">2*1=2 2*2=4 </span><br><span class="line">3*1=3 3*2=6 3*3=9 </span><br><span class="line">4*1=4 4*2=8 4*3=12 4*4=16 </span><br><span class="line">5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 </span><br><span class="line">6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 </span><br><span class="line">7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 </span><br><span class="line">8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 </span><br><span class="line">9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81</span><br></pre></td></tr></table></figure><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>Go 语言可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong> 及<strong>通道（channel）</strong>。通过 <code>for range</code>遍历的返回值有一定的规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map 返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><h3 id="遍历数组、切片——获得索引和元素"><a href="#遍历数组、切片——获得索引和元素" class="headerlink" title="遍历数组、切片——获得索引和元素"></a>遍历数组、切片——获得索引和元素</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值。下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; &#123;</span><br><span class="line">fmt.Println(key, <span class="string">"=&gt;"</span>, value)</span><br><span class="line"><span class="comment">// 0 =&gt; 1</span></span><br><span class="line"><span class="comment">// 1 =&gt; 2</span></span><br><span class="line"><span class="comment">// 2 =&gt; 3</span></span><br><span class="line"><span class="comment">// 3 =&gt; 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历字符串——获得索引和元素"><a href="#遍历字符串——获得索引和元素" class="headerlink" title="遍历字符串——获得索引和元素"></a>遍历字符串——获得索引和元素</h3><p>Go 语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引（base0）和字符串中的每一个字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">"你好，zhimma"</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"key:%d value:0x%x\n"</span>, key, value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">key:0 value:0x4f60 type:int32</span></span><br><span class="line"><span class="comment">            key:3 value:0x597d type:int32</span></span><br><span class="line"><span class="comment">            key:6 value:0xff0c type:int32</span></span><br><span class="line"><span class="comment">            key:9 value:0x7a type:int32</span></span><br><span class="line"><span class="comment">            key:10 value:0x68 type:int32</span></span><br><span class="line"><span class="comment">            key:11 value:0x69 type:int32</span></span><br><span class="line"><span class="comment">            key:12 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:13 value:0x6d type:int32</span></span><br><span class="line"><span class="comment">            key:14 value:0x61 type:int32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 变量，实际类型是 rune，实际上就是 int32，以十六进制打印出来就是字符的编码。</p><h3 id="遍历map——获得map的键和值"><a href="#遍历map——获得map的键和值" class="headerlink" title="遍历map——获得map的键和值"></a>遍历map——获得map的键和值</h3><p>对于 map 类型来说，<code>for range</code> 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们总是一对一对的出现。下面的代码演示了如何遍历 map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> family &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, key, value)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</p></blockquote><h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p><code>for range</code>可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    c &lt;- <span class="number">3</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h2><p>分支选择可以理解为一种批量的if语句，使用 switch 语句可方便地对大量的值进行判断。</p><p>在 Go 语言中的 switch，不仅可以基于常量进行判断，还可以基于表达式进行判断。</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go 语言改进了 switch 的语法设计，避免人为造成失误。Go 语言的 switch 中的每一个 case 与 case 间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"other"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"other"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，每个case 均是字符串格式，且使用了default 分支，Go语言规定每个 switch 只能有一个default 分支</p><h5 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h5><p>当出现多个 case 要放在一起的时候，可以像下面代码这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"mum"</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mum"</span> , <span class="string">"dad"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"family"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不通的 case 表达式使用逗号分隔</p></blockquote><h5 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h5><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> num &lt; <span class="number">20</span> || num &gt; <span class="number">20</span>:</span><br><span class="line">fmt.Println(<span class="string">"num value is "</span>, num)</span><br><span class="line"><span class="comment">// num value is  10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况的 switch 后面不再跟判断变量，连判断的目标都没有了。</p></blockquote><h2 id="goto-语句——跳转到指定的标签"><a href="#goto-语句——跳转到指定的标签" class="headerlink" title="goto 语句——跳转到指定的标签"></a>goto 语句——跳转到指定的标签</h2><p>goto 语句通过标签进行代码间的无条件跳转。goto 语句可以在快速跳出循环、避免重复退出上有一定帮助，使用 goto 语句能简化一些代码的实现过程。</p><h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>多层循环中，传统方式退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> breakAgain <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 外循环</span></span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="comment">// 内循环</span></span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="comment">// 满足某个条件时, 退出循环</span></span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 设置退出标记</span></span><br><span class="line">                breakAgain = <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 退出本次循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记, 还需要退出一次循环</span></span><br><span class="line">        <span class="keyword">if</span> breakAgain &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 goto方式优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">10</span>; x++ &#123;</span><br><span class="line">        <span class="keyword">for</span> y := <span class="number">0</span>; y &lt; <span class="number">10</span>; y++ &#123;</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="comment">// 跳转到标签</span></span><br><span class="line">                <span class="keyword">goto</span> breakHere</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 手动返回, 避免执行进入标签</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第13行 ：标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 16 行代码。</p><p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p><h3 id="统一错误处理"><a href="#统一错误处理" class="headerlink" title="统一错误处理"></a>统一错误处理</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = secondCheckError()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure><p>使用 goto 语句实现上面同样的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    err = secondCheckError()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> onExit</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break (跳出循环)"></a>break (跳出循环)</h2><p>break 语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>代码块。break 语句还可以在语句后面添加标签，表示退出摸个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和<code>select</code>的代码块上</p><p>下面看下跳出指定循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">fmt.Println(i , j)</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">break</span> OuterLoop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 1 行，外层循环的标签。</li><li>第 2 行和第 3 行，双层循环。</li><li>第 5 行，使用 switch 进行数值分支判断。</li><li>第 8 和第 11 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 1 行。</li></ul><h2 id="continue-中断本次循环，继续下一次循环"><a href="#continue-中断本次循环，继续下一次循环" class="headerlink" title="continue(中断本次循环，继续下一次循环)"></a>continue(中断本次循环，继续下一次循环)</h2><p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用</p><p>在 continue 语句后添加标签时，表示开始标签对应的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OuterLoops:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">switch</span> j &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(i, j)</span><br><span class="line"><span class="keyword">continue</span> OuterLoops</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>第 7 行将结束当前循环，开启下一次的外层循环，而不是第 3 行的循环。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。&lt;/p&gt;
&lt;p&gt; Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记2-容器</title>
    <link href="https://blog.zhimma.com/2019/03/06/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%B9%E5%99%A8/"/>
    <id>https://blog.zhimma.com/2019/03/06/Go语言学习笔记2-容器/</id>
    <published>2019-03-06T06:13:39.000Z</published>
    <updated>2019-03-07T06:53:43.851Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组(Array) 是一段固定长度的连续内存区域<br>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br>Go 的数组和切片都是从C语言延续过来的设计。</p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>数组变量名：数组声明及使用时的变量名</li><li>元素数量：数组的元素数量。可以是一个表达式，但最终通过编译期计算的结果必须是整形数值</li><li>T 可以是任意基本类型，包括 T 为数组本身。但类型为数组本身时，可以实现多维数组</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team [<span class="number">3</span>] <span class="keyword">string</span></span><br><span class="line">team[<span class="number">0</span>] = <span class="string">"JD"</span></span><br><span class="line">team[<span class="number">1</span>] = <span class="string">"TaoBao"</span></span><br><span class="line">team[<span class="number">2</span>] = <span class="string">"Wechat"</span></span><br><span class="line">fmt.Println(team) <span class="comment">// [JD TaoBao Wechat]</span></span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>数组可以在声明时使用初始化列表进行元素设置，参考下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式编写时，需要保证大括号后面的元素数量与数组的大小一致</p></blockquote><p>但一般情况下，这个过程可以交给编译器，让编译器在编译时，根据元素个数确定数组大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span> , <span class="string">"TaoBao"</span> , <span class="string">"Wechat"</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>...</code>表示让编译器确定数组大小。上面例子中，编译器会自动为这个数组设置元素个数为 3</p></blockquote><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组也和遍历切片类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> team = [...]<span class="keyword">string</span>&#123;<span class="string">"JD"</span>, <span class="string">"TaoBao"</span>, <span class="string">"Wechat"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> team &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0 JD</span></span><br><span class="line"><span class="comment">1 TaoBao</span></span><br><span class="line"><span class="comment">2 Wechat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个拥有相同类型元素的<strong>可变</strong>长度的序列，Go语言切片的内部包含<strong>地址</strong>、<strong>大小</strong>、<strong>容量</strong>，切片一般用于快速地操作一块数据集合。如果将数据集合比作切糕的话，切片就是你要的“那一块”。切的过程包含从哪里开始(这个就是切片的地址)及切多大(这个就是切片的大小)。容量可以理解为装切片的口袋大小</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3154340Y9.jpg" alt=""></p><h3 id="生成切片-从数组或切片生成新的切片"><a href="#生成切片-从数组或切片生成新的切片" class="headerlink" title="生成切片(从数组或切片生成新的切片)"></a>生成切片(从数组或切片生成新的切片)</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身</p><p>从连续内存区域生成切片是常见的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice[开始位置:结束位置]</span><br></pre></td></tr></table></figure><ul><li>slice表示目标切片对象</li><li>开始位置对应目标切片对象的索引</li><li>结束位置对应目标切片的结束索引</li></ul><h4 id="从数组生成切片："><a href="#从数组生成切片：" class="headerlink" title="从数组生成切片："></a>从数组生成切片：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr , arr[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">// [1 2 3] [2]</span></span><br></pre></td></tr></table></figure><p><code>[2]</code>就是<code>arr[1:2]</code>切片操作的结果</p><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置-开始位置。</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取。</li><li>当缺省开始位置时，表示从连续区域开头到结束位置。</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾。</li><li>两者同时缺省时，与数组本身等效。</li><li>两者同时为0时，等效于空切片，一般用于切片复位。</li></ul><p>根据索引位置取切片 slice 元素值时，取值范围是<strong>（0～len(slice)-1）</strong>，超界会报运行时错误</p><p>生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>具体，下面使用一些实例演示：</p><h5 id="指定范围生成切片"><a href="#指定范围生成切片" class="headerlink" title="指定范围生成切片"></a>指定范围生成切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个array</span></span><br><span class="line">build := [<span class="number">30</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++ &#123;</span><br><span class="line">build[i] = i +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间取值</span></span><br><span class="line">fmt.Println(build[<span class="number">10</span>:<span class="number">15</span>]) <span class="comment">// [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">// 中间部分到结尾所有元素</span></span><br><span class="line">fmt.Println(build[<span class="number">20</span>:]) <span class="comment">// [21 22 23 24 25 26 27 28 29 30]</span></span><br><span class="line"><span class="comment">// 开始到中间所有元素</span></span><br><span class="line">fmt.Println(build[:<span class="number">8</span>]) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p><h5 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h5><p>生成切片的格式中，当开始和结束都范围都被忽略，则生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上是一致的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[:]) <span class="comment">// [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重置切片，清空所有元素"><a href="#重置切片，清空所有元素" class="headerlink" title="重置切片，清空所有元素"></a>重置切片，清空所有元素</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">originSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(originSlice[<span class="number">0</span>:<span class="number">0</span>]) <span class="comment">// []</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明新的切片"><a href="#声明新的切片" class="headerlink" title="声明新的切片"></a>声明新的切片</h4><p>除了可以从原有的数组或者切片中生成切片，你也可以声明一个新的切片<br>每一种类型都可以拥有其切片类型，表示多个类型元素的连续集合。因此切片类型也可以被声明。切片类型声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><ul><li>Name 表示切片的变量名</li><li>T 表示切片对应的元素类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明字符串切片</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 声明整形切片</span></span><br><span class="line"><span class="keyword">var</span> intSlice []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 声明一个空切片</span></span><br><span class="line"><span class="keyword">var</span> emptySlice = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strSlice, intSlice, emptySlice) <span class="comment">// [] [] []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出3个切片大小</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(strSlice), <span class="built_in">len</span>(intSlice), <span class="built_in">len</span>(emptySlice)) <span class="comment">// 0 0 0</span></span><br><span class="line"><span class="comment">// 切片判定空的结果</span></span><br><span class="line">fmt.Println(strSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(intSlice == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(emptySlice == <span class="literal">nil</span>) <span class="comment">// true true false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是动态结构，只能与nil判定相等，不能互相判等时。</p><p>声明新的切片后，可以使用<code>append()</code>函数来添加元素。</p><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><p>如果需要动态的创建一个切片，可以使用make()内建函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,size,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><ul><li>T : 切片的元素类型</li><li>size : 就是为这个类型分配多少个元素</li><li>cap : 预分配元素数量，这个值设定不影响size,只是能提前分配空间，降低多次分配空间造成的性能问题。</li></ul><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b) <span class="comment">// [0 0] [0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b)) <span class="comment">// 2 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a), <span class="built_in">cap</span>(b)) <span class="comment">// 2 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。<br>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p></blockquote><p>使用 make() 函数生成的切片一定发生了内存分配操作。但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p><p>切片不一定必须经过 make() 函数才能使用。生成切片、声明后使用 append() 函数均可以正常使用切片</p><h3 id="使用append-为切片添加元素"><a href="#使用append-为切片添加元素" class="headerlink" title="使用append()为切片添加元素"></a>使用append()为切片添加元素</h3><ul><li>Go语言的内建函数 append() 可以为切片动态添加元素</li><li>每个切片会指向一片内存空间，这片空间能容纳一定数量的元素</li><li>当空间不能容纳足够多的元素时，切片就会进行“扩容”。“扩容”操作往往发生在 append() 函数调用时</li><li>切片在扩容时，容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, i)</span><br><span class="line">fmt.Printf(<span class="string">"len: %d,cap: %d,pointer: %p\n"</span>, <span class="built_in">len</span>(numbers), <span class="built_in">cap</span>(numbers), numbers)</span><br><span class="line"><span class="comment">// len : 1,cap:1,pointer:0xc000014080</span></span><br><span class="line"><span class="comment">// len : 2,cap:2,pointer:0xc0000140b0</span></span><br><span class="line"><span class="comment">// len : 3,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 4,cap:4,pointer:0xc0000160c0</span></span><br><span class="line"><span class="comment">// len : 5,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 6,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 7,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 8,cap:8,pointer:0xc00001a080</span></span><br><span class="line"><span class="comment">// len : 9,cap:16,pointer:0xc00008a000</span></span><br><span class="line"><span class="comment">// len : 10,cap:16,pointer:0xc00008a000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append() 函数除了添加一个元素外，也可以一次性添加很多元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> company []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加一个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"JD"</span>)</span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">company = <span class="built_in">append</span>(company , <span class="string">"taobao"</span> , <span class="string">"t.tt"</span>)</span><br><span class="line"><span class="comment">// 添加切片</span></span><br><span class="line">newCompany := []<span class="keyword">string</span>&#123;<span class="string">"mi"</span> , <span class="string">"坚果"</span>&#125;</span><br><span class="line">company = <span class="built_in">append</span>(company , newCompany...)</span><br><span class="line"></span><br><span class="line">fmt.Println(company) <span class="comment">// [JD taobao t.tt mi 坚果]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第 13 行，在newCompany后面加上了<code>...</code>，表示将 newCompany 整个添加到 car 的后面。</p></blockquote><h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>使用内建的 copy() 函数，可以迅速地将一个切片的数据复制到另外一个切片空间中，copy() 函数的使用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(originSlice,srcSlice []T)<span class="keyword">int</span></span><br></pre></td></tr></table></figure><ul><li>originSlice 为数据来源切片</li><li>srcSlice为复制的目标。目标切片必须分配过空间且足够承载复制的元素个数，来源和目标的类型一致，copy 的返回值表示实际发生复制的元素个数。</li></ul><h3 id="删除切片元素"><a href="#删除切片元素" class="headerlink" title="删除切片元素"></a>删除切片元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seq := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>&#125;</span><br><span class="line"><span class="comment">// 指定删除位置       </span></span><br><span class="line">index := <span class="number">2</span></span><br><span class="line"><span class="comment">// 查看删除位置之前的元素和之后的元素</span></span><br><span class="line">fmt.Println(seq[:index], seq[index+<span class="number">1</span>:])<span class="comment">// [a b] [d e]</span></span><br><span class="line"><span class="comment">// 将删除点前后的元素连接起来 </span></span><br><span class="line">seq = <span class="built_in">append</span>(seq[:index], seq[index+<span class="number">1</span>:]...)</span><br><span class="line">fmt.Println(seq) <span class="comment">// [a b d e]</span></span><br></pre></td></tr></table></figure><p>代码的删除过程可以使用下图来描述。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ3164544530.jpg" alt=""></p><p>Go 语言中切片删除元素的本质是：以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p><blockquote><p>连续容器的元素删除无论是在任何语言中，都要将删除点前后的元素移动到新的位置。随着元素的增加，这个过程将会变得极为耗时。因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高，就需要反思是否需要更换其他的容器（如双链表等能快速从删除点删除元素）。</p></blockquote><h2 id="map-Go语言映射"><a href="#map-Go语言映射" class="headerlink" title="map(Go语言映射)"></a>map(Go语言映射)</h2><p>在业务和算法中需要使用任意类型的关联关系时，就需要使用到映射，如学号和学生的对应、名字与档案的对应等。</p><p>Go语言提供的映射关系容器为 map，map使用散列表（hash）实现。</p><h3 id="添加数据到map"><a href="#添加数据到map" class="headerlink" title="添加数据到map"></a>添加数据到map</h3><p>Go语言中 map 的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]vluesType</span><br></pre></td></tr></table></figure><ul><li>keyTyp 表示键类型</li><li>valueType 表示键对应值类型</li></ul><p>一个map 里，符合keyType和valueType 的映射总是成对出现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scene := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//  这里的map是内部实现的类型</span></span><br><span class="line">scene[<span class="string">"route"</span>] = <span class="number">666</span></span><br><span class="line">fmt.Println(scene[<span class="string">"route"</span>]) <span class="comment">// 666</span></span><br><span class="line"></span><br><span class="line">v := scene[<span class="string">"route2"</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尝试查找一个不存在的键，那么返回的将是 ValueType 的默认值</p></blockquote><p>某些情况下，需要明确知道查询中某个键是否在 map 中存在，可以使用一种特殊的写法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := scene[<span class="string">"route"</span>]</span><br></pre></td></tr></table></figure><p>在默认获取键值的基础上，多取了一个变量 ok，可以判断键 route 是否存在于 map 中。</p><p>map 还可以在声明时填充内容，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"W"</span> : <span class="string">"forward"</span>,</span><br><span class="line"><span class="string">"A"</span>: <span class="string">"left"</span>,</span><br><span class="line"><span class="string">"D"</span>: <span class="string">"right"</span>,</span><br><span class="line"><span class="string">"S"</span>: <span class="string">"backward"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[W:forward A:left D:right S:backward]</span></span><br></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><h4 id="遍历key-和-value"><a href="#遍历key-和-value" class="headerlink" title="遍历key 和 value"></a>遍历key 和 value</h4><p>map 的遍历过程使用 <code>for range</code>循环完成，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">family := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"dad"</span>:      <span class="string">"zhimma dad"</span>,</span><br><span class="line"><span class="string">"mom"</span>:      <span class="string">"zhimma mom"</span>,</span><br><span class="line"><span class="string">"daughter"</span>: <span class="string">"zhimma"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span>  family&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span> , key ,value)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello dad zhimma dad</span></span><br><span class="line"><span class="comment">hello mom zhimma mom</span></span><br><span class="line"><span class="comment">hello daughter zhimma</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只遍历value"><a href="#只遍历value" class="headerlink" title="只遍历value"></a>只遍历value</h4><p>遍历时，可以同时获得键和值。如只遍历值，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>将不需要的键改为匿名变量形式。</p><h4 id="只遍历key"><a href="#只遍历key" class="headerlink" title="只遍历key"></a>只遍历key</h4><p>只遍历键时，使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span>  family&#123;</span><br></pre></td></tr></table></figure><p>无须将值改为匿名变量形式，忽略值即可</p><h3 id="map-元素删除和清空"><a href="#map-元素删除和清空" class="headerlink" title="map 元素删除和清空"></a>map 元素删除和清空</h3><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对 ，<code>delete()</code>函数的格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span> , 键)</span><br></pre></td></tr></table></figure><ul><li>map 为要删除的map实例</li><li>键为要删除的 map 键值对中的键</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">numMap := make(map[string]int)</span><br><span class="line"></span><br><span class="line">numMap[&quot;aroute&quot;] = 66</span><br><span class="line">numMap[&quot;brazil&quot;] = 4</span><br><span class="line">numMap[&quot;china&quot;] = 960</span><br><span class="line">delete(numMap , &quot;brazil&quot;)</span><br><span class="line">for k, v := range numMap &#123;</span><br><span class="line">fmt.Println(k , v)</span><br><span class="line">/**</span><br><span class="line">aroute 66</span><br><span class="line">china 960</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h4><p>有意思的是,Go语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是<strong>重新 make 一个新的 map</strong>。不用担心垃圾回收的效率，Go 语言中的并行垃圾回收效率比写一个清空函数高效多了。</p><h2 id="sync-Map-在并发环境中使用的map"><a href="#sync-Map-在并发环境中使用的map" class="headerlink" title="sync.Map(在并发环境中使用的map)"></a>sync.Map(在并发环境中使用的map)</h2><p>Go 语言中的 map 在并发情况下，只读是线程安全的，同时读写线程不安全。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个int到int的映射</span></span><br><span class="line">n := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 不停地对map进行写入</span></span><br><span class="line">n[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一段并发代码</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_ = n[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码会报错，输出如下：<br><code>fatal error: concurrent map read and map write</code></p><p>运行时输出提示：并发的 map 读写。也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题。map 内部会对这种并发操作进行检查并提前发现</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高。Go 语言在 1.9 版本中提供了一种效率较高的并发安全的 <code>sync.Map</code>。<code>sync.Map</code> 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p><code>sync.Map</code>有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。Range 参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scenes sync.Map</span><br><span class="line"><span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">scenes.Store(<span class="string">"greece"</span>, <span class="number">97</span>)</span><br><span class="line">scenes.Store(<span class="string">"london"</span>, <span class="number">100</span>)</span><br><span class="line">scenes.Store(<span class="string">"egypt"</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">fmt.Println(scenes.Load(<span class="string">"london"</span>))</span><br><span class="line"><span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">scenes.Delete(<span class="string">"london"</span>)</span><br><span class="line"><span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">scenes.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"iterate:"</span>, k, v)</span><br><span class="line"><span class="comment">// iterate: greece 97</span></span><br><span class="line"><span class="comment">//i terate: egypt 200</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>sync.Map 没有提供获取 map 数量的方法，替代方法是获取时遍历自行计算数量。sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h2><p>列表是一种非连续存储的容器，由多个节点组成，节点通过一些变量记录彼此之前的关系。列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示：</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31I54a30.jpg" alt=""></p><p>如果在这个基础上，再从 C 开始将自己的号码给自己知道号码的人，这样就形成了双链表结构，如下图所示。</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31IJRI.jpg" alt=""></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环。这个过程就是列表遍历。<br>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除。这个过程就是列表元素的删除操作，如下图所示</p><p><img src="http://c.biancheng.net/uploads/allimg/180813/1-1PQ31J0524T.jpg" alt=""></p><p>在Go语言中，将列表使用 container/list 包来实现，内部的实现原理是双链表。列表能够高效地进行任意位置的元素插入和删除操作。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><code>list</code> 的初始化有两种方法：New 和声明。两种方法的初始化效果都是一致的。</p><h4 id="通过container-list-包的-New-方法初始化-list"><a href="#通过container-list-包的-New-方法初始化-list" class="headerlink" title="通过container/list 包的 New 方法初始化 list"></a>通过container/list 包的 New 方法初始化 list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure><h4 id="通过声明初始化list"><a href="#通过声明初始化list" class="headerlink" title="通过声明初始化list"></a>通过声明初始化list</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure><p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制。因此，列表的元素可以是任意类型。这既带来便利，也会引来一些问题。给一个列表放入了非期望类型的值，在取出值后，将 interface{} 转换为期望类型时将会发生宕机。</p><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 <code>PushFront</code>和 <code>PushBack</code>。</p><p>这两个方法都会返回一个 <code>*list.Element</code> 结构。如果在以后的使用中需要删除插入的元素，则只能通过 <code>*list.Element</code> 配合<code>Remove()</code>方法进行删除，这种方法可以让删除更加效率化，也是双链表特性之一</p><p>下面代码展示给list添加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br></pre></td></tr></table></figure><p>列表插入元素的方法如下表所示。</p><table><thead><tr><th>方  法</th><th>功  能</th></tr></thead><tbody><tr><td>InsertAfter(v interface {}, mark <em> Element) </em> Element</td><td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td></tr><tr><td>InsertBefore(v interface {}, mark <em> Element) </em>Element</td><td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td></tr><tr><td>PushBackList(other *List)</td><td>添加 other 列表元素到尾部</td></tr><tr><td>PushFrontList(other *List)</td><td>添加 other 列表元素到头部</td></tr></tbody></table><h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表的插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值及和其他节点之间的关系等信息。从列表中删除元素时，需要用到这个结构进行快速删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入age</span></span><br><span class="line">l.PushBack(<span class="string">"age"</span>)</span><br><span class="line"><span class="comment">// 头部插入18+</span></span><br><span class="line">l.PushFront(<span class="string">"18+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"><span class="comment">// 在fist之后添加high</span></span><br><span class="line">l.InsertAfter(<span class="string">"high"</span>, element)</span><br><span class="line"><span class="comment">// 在fist之前添加noon</span></span><br><span class="line">l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">l.Remove(element)</span><br></pre></td></tr></table></figure><p>下表中展示了每次操作后列表的实际元素情况。</p><table><thead><tr><th>操作内容</th><th>列表元素</th></tr></thead><tbody><tr><td>l.PushBack(“age”)</td><td>age</td></tr><tr><td>l.PushFront(“18+”)</td><td>18+, age</td></tr><tr><td>element := l.PushBack(“fist”)</td><td>18+, age, fist</td></tr><tr><td>l.InsertAfter(“high”, element)</td><td>18+, age, fist, high</td></tr><tr><td>l.InsertBefore(“noon”, element)</td><td>18+, age, noon, fist, high</td></tr><tr><td>l.Remove(element)</td><td>18+, age, noon, high</td></tr></tbody></table><h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><p>遍历双链表需要配合 <code>Front()</code>函数获取头元素，遍历时只要元素不为空就可以继续进行。每一次遍历调用元素的 <code>Next</code>，如代码中第 6 行所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">    <span class="comment">// 67</span></span><br><span class="line">    <span class="comment">// canon</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次；每次循环会进行一次 i!=nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i=i.Next()。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记1-基本语法</title>
    <link href="https://blog.zhimma.com/2019/03/05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://blog.zhimma.com/2019/03/05/Go语言学习笔记1-基本语法/</id>
    <published>2019-03-05T08:48:28.000Z</published>
    <updated>2019-03-07T07:55:34.994Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="变量声明-使用var关键字"><a href="#变量声明-使用var关键字" class="headerlink" title="变量声明(使用var关键字)"></a>变量声明(使用var关键字)</h2><blockquote><p>变量（Variable）的功能是存储用户的数据,不同的逻辑有不同的对象类型，也就有不同的变量类型</p></blockquote><p>Go语言使用<strong>var</strong>关键字进行变量的声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">e</span> <span class="title">struct</span></span>&#123;</span><br><span class="line">    x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行，声明一个整形类型的变量，用来保存整数数值</li><li>第二行，声明一个字符串类型的变量</li><li>第三行，声明一个32位浮点切片类型的变量，浮点切片表示由多个浮点类型组成的数据结构</li><li>第四行，声明一个返回值为bool类型的函数变量，这种形式一般用于回调函数，即将函数以变量的形式保存下来，在需要的时候重新调用这个函数</li><li>声明一个结构体类型的变量，这个结构体拥有一个整形的x字段</li></ul><h3 id="标准格式声明"><a href="#标准格式声明" class="headerlink" title="标准格式声明"></a>标准格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量的声明是以var关键字开头，要声明的变量名放中间，将其类型放在后面，行尾无需分号</p><h3 id="批量格式声明"><a href="#批量格式声明" class="headerlink" title="批量格式声明"></a>批量格式声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c []<span class="keyword">float32</span></span><br><span class="line">d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用var和括号，可以将一组变量定义放在一起</p><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p><ul><li>整型和浮点型变量的默认值为 0</li><li>字符串变量的默认值为空字符串</li><li>布尔型变量默认为 bool</li><li>切片、函数、指针变量的默认为 nil</li></ul><p>在声明变量的时候也可以进行赋初始值</p><h3 id="变量初始化标准格式"><a href="#变量初始化标准格式" class="headerlink" title="变量初始化标准格式"></a>变量初始化标准格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><h3 id="编译器推导类型"><a href="#编译器推导类型" class="headerlink" title="编译器推导类型"></a>编译器推导类型</h3><p>在标准格式的基础上，可以省略部分变量类型，编译器会尝试根据等号右边的表达式推导变量的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><p>等号右边的部分在编译原理里被称做右值（rvalue）</p><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p>var 的变量声明还有一种精简写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"zhimma"</span></span><br></pre></td></tr></table></figure><blockquote><p> 左值变量必须是没有定义过的变量</p></blockquote><p>在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br><span class="line">conn2, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8080"</span>)</span><br></pre></td></tr></table></figure><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><p>多重赋值时，变量的左值和右值按从左到右的顺序赋值<br>多重赋值在 Go 语言的错误处理和函数返回值中会大量地使用。</p><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在使用多重赋值时，如果不需要在左值中接收变量，可以使用匿名变量（anonymous variable）</p><p>匿名变量的表现是一个下划线<code>_</code>,使用匿名变量时，只需要在变量声明的地方使用下画线替换即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">a, _ := GetData()</span><br><span class="line">_, b := GetData()</span><br><span class="line">fmt.Println(a, b)<span class="comment">// 100 200</span></span><br></pre></td></tr></table></figure><p><strong>匿名变量不占用命名空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</strong></p><p>匿名变量：</p><ul><li>可以理解为一种占位符。</li><li>本身这种变量不会进行空间分配，也不会占用一个变量的名字。</li><li>在<code>for range</code> 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li></ul><h2 id="Go语言类型"><a href="#Go语言类型" class="headerlink" title="Go语言类型"></a>Go语言类型</h2><p>Go语言 中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异，切片类型有着指针的便利性，但比指针更为安全，很多高级语言都配有切片进行安全和高效率的内存操作。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整型分为以下两个大类：</p><ul><li>按长度分为：int8、int16、int32、int64</li><li>还有对应的无符号整型：uint8、uint16、uint32、uint64</li></ul><p>其中，uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。</p><h3 id="浮点类型（小数类型）"><a href="#浮点类型（小数类型）" class="headerlink" title="浮点类型（小数类型）"></a>浮点类型（小数类型）</h3><p>Go语言</p><p>支持两种浮点型数：float32 和 float64。这两种浮点型数据格式遵循 IEEE 754 标准：</p><ul><li>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。</li><li>float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</li></ul><p>打印浮点数时，可以使用 fmt 包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi) <span class="comment">//按默认宽度和精度输出整型</span></span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)<span class="comment">//按默认宽度，2 位精度输出（小数点后的位数）。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.141593</span></span><br><span class="line"><span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>布尔型数据只有 true（真）和 false（假）两个值，布尔型无法参与数值运算，也无法与其他类型进行转换</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在Go语言中以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。</p><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转移符</th><th>含  义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr></tbody></table><h4 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h4><p>在源码中，将字符串的值以双引号书写的方式是字符串的常见表达方式，被称为字符串字面量（string literal）<br>这种双引号字面量不能跨行。如果需要在源码中嵌入一个多行字符串时，就必须使用<strong>`</strong>字符，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><blockquote><p>在<strong>`</strong>间的所有代码均不会被编译器识别，而只是作为字符串的一部分</p></blockquote><h3 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h3><p>字符串中的每一个元素叫做<strong>“字符”</strong>，在遍历或者单个获取字符串元素时可以获得字符</p><p>Go语言的字符有以下两种：</p><ol><li><strong>uint8</strong>类型，也叫<strong>byte</strong>型，代表了<strong>ASCLL</strong>码中的一个字符</li><li><strong>rune</strong>类型，代表一个<strong>UTF-8</strong>字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个 int32。</li></ol><p>使用<code>fmt.Printf</code>中的<code>%T</code>动词可以输出、变量的实际类型，使用这个方法可以查看 byte 和 rune 的本来类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, a, a) <span class="comment">// 97 uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">rune</span> = <span class="string">'你'</span></span><br><span class="line">fmt.Printf(<span class="string">"%d %T\n"</span>, b, b) <span class="comment">// 20320 int32</span></span><br></pre></td></tr></table></figure><blockquote><p>可以发现，byte 类型的 a 变量，实际类型是 uint8，其值为 ‘a’，对应的 ASCII 编码为 97<br>rune 类型的 b 变量的实际类型是 int32，对应的 Unicode 码就是 20320<br>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p></blockquote><h2 id="Go数据类型转换"><a href="#Go数据类型转换" class="headerlink" title="Go数据类型转换"></a>Go数据类型转换</h2><p>Go语言使用类型前置加括号的方式进行数据类型转换，一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><blockquote><p>T代表要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><p>类型转换时，需要考虑两种类型的关系和范围，是否会发生数值截断等</p></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>相对于变量，常量是恒定不变的值，例如圆周率。<br>可以在编译时，对常量表达式进行计算求值，并在运行期使用该计算结果，计算结果无法被修改。常量表示起来非常简单，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">4.14159</span></span><br></pre></td></tr></table></figure><p>常量的声明和变量声明非常类似，只是把 var 换成了 const。</p><p>多个变量可以一起声明，类似的，常量也是可以多个一起声明的，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.141592</span></span><br><span class="line">    e = <span class="number">2.718281</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量因为在编译期确定，所以可以用于数组声明，如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> arr [size]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="模拟枚举-const和iota模拟枚举"><a href="#模拟枚举-const和iota模拟枚举" class="headerlink" title="模拟枚举(const和iota模拟枚举)"></a>模拟枚举(const和iota模拟枚举)</h2><p>Go语言现阶段没有枚举，可以使用 const 常量配合 iota 模拟枚举，请看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weapon <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">     Arrow Weapon = <span class="literal">iota</span>    <span class="comment">// 开始生成枚举值, 默认为0</span></span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出所有枚举值</span></span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower) <span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="comment">// 使用枚举类型并赋初值</span></span><br><span class="line"><span class="keyword">var</span> weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>枚举类型其实本质是一个 int 一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。</p><h2 id="Go语言type关键字-类型别名"><a href="#Go语言type关键字-类型别名" class="headerlink" title="Go语言type关键字(类型别名)"></a>Go语言type关键字(类型别名)</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名的写法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a NewInt</span><br><span class="line">fmt.Printf(&quot;a type : %T\n&quot;, a) // a type : main.NewInt</span><br><span class="line"></span><br><span class="line">var b IntAlias</span><br><span class="line">fmt.Printf(&quot;b type %T\n&quot;, b) // b type int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明如下：</p><ul><li>第 8 行，将 NewInt 定义为 int 类型，这是常见定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型。NewInt 本身依然具备int的特性。</li><li>第 11 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。</li><li>第 15 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。</li><li>第 16 行，使用<code>%T</code>格式化参数，显示 a 变量本身的类型。</li><li>第 18 行，将 b 声明为 IntAlias 类型，此时打印 b 的值为 0。</li><li>第 19 行，显示 b 变量的类型。</li></ul><p>结果显示a的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型。b 类型是 int。IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。</p><h2 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h2><p>指针（pointer）概念在Go语言中被拆分为两个核心概念：</p><ol><li>类型指针，运行对这个指针类型的数据进行修改，传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算</li><li>切片，由指向起始元素的原始指针、元素数量和容量组成</li></ol><p>受益于这样的约束和拆分，Go 语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p>要明白指针，需要知道几个概念：<strong>指针地址</strong>、<strong>指针类型</strong>和<strong>指针取值</strong>，下面将展开细说。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置</p><p>Go 语言中使用<code>&amp;</code>作符放在变量前面对变量进行“取地址”操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中v代表被取地址的变量，被取地址的v使用ptr变量进行接收，ptr的类型就为<code>*T</code>,称做 T 的指针类型，<code>*</code>代表指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cat <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"banana"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p %p"</span>, &amp;cat, &amp;str) <span class="comment">// 0xc042052088 0xc0420461b0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>第 8 行，声明整型 cat 变量。</li><li>第 9 行，声明字符串 str 变量。</li><li>第 10 行，使用 fmt.Printf 的动词<code>%p</code>输出 cat 和 str 变量取地址后的指针值，指针值带有<code>0x</code>的十六进制前缀。</li></ul><p>输出值在每次运行是不同的，代表 cat 和 str 两个变量在运行时的地址。</p><p><strong>提示：变量、指针和地址三者的关系是：每个变量都拥有地址，指针的值就是地址</strong></p><h3 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h3><p>在对普通变量使用<code>&amp;</code>操作符获取地址获得这个变量的指针后，可以对指针使用<code>*</code>操作，也就是指针取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 声明一个字符串类型变量</span></span><br><span class="line"><span class="keyword">var</span> house = <span class="string">"陕西西安"</span></span><br><span class="line"><span class="comment">// 对字符串取地址，ptr类型为*string</span></span><br><span class="line">ptr := &amp;house</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出ptr类型</span></span><br><span class="line">fmt.Printf(<span class="string">"ptr type: %T\n"</span> , ptr) <span class="comment">// ptr type: *string</span></span><br><span class="line"><span class="comment">// 输出ptr指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">"address: %p\n"</span> , ptr) <span class="comment">// address: 0xc00000e1e0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针进行取值操作</span></span><br><span class="line">value := *ptr</span><br><span class="line"><span class="comment">// 取值后类型</span></span><br><span class="line">fmt.Printf(<span class="string">"value type: %T\n"</span> , value) <span class="comment">// value type: string</span></span><br><span class="line"><span class="comment">// 指针去之后就是指向变量的值</span></span><br><span class="line">fmt.Printf(<span class="string">"value: %s\n"</span> , value) <span class="comment">//value: 陕西西安</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</strong></p><h3 id="变量、指针地址、指针变量、取地址、取值的相互关系和特性"><a href="#变量、指针地址、指针变量、取地址、取值的相互关系和特性" class="headerlink" title="变量、指针地址、指针变量、取地址、取值的相互关系和特性"></a>变量、指针地址、指针变量、取地址、取值的相互关系和特性</h3><p>如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 交换变量值</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line"><span class="comment">// 输出变量值</span></span><br><span class="line">fmt.Println(x, y) <span class="comment">// 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">t := *a</span><br><span class="line"><span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">*a = *b</span><br><span class="line"><span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">*b = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>*</code>操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指向的变量</p><p><code>*</code>操作符的根本意义就是操作指针指向的变量，当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p></blockquote><h3 id="创建指针的另一种方法——new-函数"><a href="#创建指针的另一种方法——new-函数" class="headerlink" title="创建指针的另一种方法——new() 函数"></a>创建指针的另一种方法——new() 函数</h3><p>Go 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(T) <span class="comment">// T代表类型</span></span><br></pre></td></tr></table></figure><p>一般这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line">*str = <span class="string">"zhimma"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str) <span class="comment">// zhimma</span></span><br></pre></td></tr></table></figure><blockquote><p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存。被创建的指针指向的值为默认值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;变量声明-使用var关键字&quot;&gt;&lt;a href=&quot;#变量声明-使用var关键字&quot; class=&quot;headerlink&quot; title=&quot;变量声明(使用var关键字)&quot;&gt;&lt;/a&gt;变量声明(使用var关键字)&lt;/h2&gt;&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="Go" scheme="https://blog.zhimma.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://blog.zhimma.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Nginx单域名配置多Vue工程和多PHP接口</title>
    <link href="https://blog.zhimma.com/2019/03/01/Nginx%E5%8D%95%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE%E5%A4%9AVue%E5%B7%A5%E7%A8%8B%E5%92%8C%E5%A4%9APHP%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.zhimma.com/2019/03/01/Nginx单域名配置多Vue工程和多PHP接口/</id>
    <published>2019-03-01T09:42:33.000Z</published>
    <updated>2019-03-01T10:03:18.633Z</updated>
    
    <content type="html"><![CDATA[<p>先简单说下需求吧：</p><p>前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即<code>小程序端</code>，<code>boss后台管理端</code>，<code>console客户端</code>，按照最简单的业务来解析域名，则需要6个域名。</p><p>由于种种原因吧，只能提供一个域名，所以就要借助Nginx的重定向或者rewrite功能；</p><p>大致流程和这里基本保持一致，<a href="https://blog.zhimma.com/2019/02/01/Nginx单域名配置多Vue工程和PHP接口/">点击查看Nginx单域名配置多Vue工程和PHP接口</a></p><p>先贴一下代码吧：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> btg.ma;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="comment">##----boss api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/b &#123;</span><br><span class="line">       // 目录重定向</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/boss-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@bossBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@bossBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            // 兼容路由模式-个人猜想</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/b/(.*)$</span> /boss/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /boss/b/(.*)$ /boss/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----boss web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /boss/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/boss/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/boss/f/(.*)</span> /boss/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----console api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/console-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@consoleBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@consoleBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/b/(.*)$</span> /console/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /console/b/(.*)$ /console/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----console web-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /console/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/console/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/console/f/(.*)</span> /console/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##----crs api-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/b &#123;</span><br><span class="line">       <span class="attribute">alias</span>  /Users/zhimma/Data/www/Btg_Base_Crs/crs-api/src/public/;</span><br><span class="line">       <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@crsBackend</span>;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>; </span><br><span class="line">            <span class="attribute">fastcgi_index</span> /index.php; </span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="variable">$request_filename</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">include</span> fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@crsBackend</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123; </span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/b/(.*)$</span> /crs/b/index.php?s=<span class="variable">$1</span> <span class="literal">last</span>;    </span><br><span class="line">            <span class="attribute">rewrite</span> /crs/b/(.*)$ /crs/b/index.php<span class="variable">$is_args</span><span class="variable">$args</span> <span class="literal">last</span>;  </span><br><span class="line">            break;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##----crs-----##</span></span><br><span class="line">    <span class="comment">################################################################</span></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /crs/f &#123;</span><br><span class="line">        <span class="attribute">alias</span> /Users/zhimma/Data/www/Btg_Base_Crs/web/crs/;</span><br><span class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/crs/f/(.*)</span> /crs/f/index.html <span class="literal">last</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">      <span class="attribute">rewrite</span> ~.*$ /index.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#location /favicon.ico &#123;</span></span><br><span class="line">    <span class="comment">#    root /data/wwwroot/mk.vchangyi.com/web_test/backend;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/btg.ma.access.log main;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/btg.ma.<span class="literal">error</span>.log <span class="literal">error</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果就成为这样子：</p><p><code>domain/origin/type</code></p><p>域名+管理端+前后端，<strong>f</strong>代表<code>frontend</code>,<strong>b</strong>代表<code>backend</code></p><p><strong>boss:</strong></p><p>前台页面：<code>btg.ma/boss/f</code></p><p>后台接口地址：<code>btg.ma/boss/b</code></p><p><strong>console:</strong></p><p>前台页面：<code>btg.ma/console/f</code></p><p>后台接口地址：<code>btg.ma/console/b</code></p><p><strong>crs:</strong></p><p>前台页面：<code>btg.ma/crs/f</code></p><p>后台接口地址：<code>btg.ma/crs/b</code></p><p><strong><em>done</em></strong>;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先简单说下需求吧：&lt;/p&gt;
&lt;p&gt;前后端分离项目，一个域名可以访问所有的客户端，例如，我们的项目中前端有单独的访问域名，后端有单独的接口域名，我们的项目存在3个客户端，即&lt;code&gt;小程序端&lt;/code&gt;，&lt;code&gt;boss后台管理端&lt;/code&gt;，&lt;code&gt;conso
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/categories/Vue/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
      <category term="Vue" scheme="https://blog.zhimma.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Nginx目录路径重定向</title>
    <link href="https://blog.zhimma.com/2019/03/01/Nginx%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://blog.zhimma.com/2019/03/01/Nginx目录路径重定向/</id>
    <published>2019-03-01T09:41:48.000Z</published>
    <updated>2019-03-01T10:07:55.645Z</updated>
    
    <content type="html"><![CDATA[<p>如果希望域名后边跟随的路径指向本地磁盘的其他目录,而不是默认的web目录时,需要设置nginx目录访问重定向</p><p>应用场景:<code>domain.com/image</code>自动跳转到<code>domain.com/folderName/image</code>目录。</p><h2 id="Nginx目录路径重定向的几种实现方式"><a href="#Nginx目录路径重定向的几种实现方式" class="headerlink" title="Nginx目录路径重定向的几种实现方式:"></a>Nginx目录路径重定向的几种实现方式:</h2><h3 id="Nginx修改root映射"><a href="#Nginx修改root映射" class="headerlink" title="Nginx修改root映射"></a>Nginx修改root映射</h3><p>修改root映射实现nginx目录访问重定向是最简单的方式, 推荐采用这一种.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image &#123;</span><br><span class="line">    <span class="attribute">root</span>   /folderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Nginx-rewrite内部跳转实现访问重定向"><a href="#通过Nginx-rewrite内部跳转实现访问重定向" class="headerlink" title="通过Nginx rewrite内部跳转实现访问重定向"></a>通过Nginx rewrite内部跳转实现访问重定向</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>     /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx设置别名alias映射实现"><a href="#Nginx设置别名alias映射实现" class="headerlink" title="Nginx设置别名alias映射实现"></a>Nginx设置别名alias映射实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span>  /image  &#123;</span><br><span class="line">    <span class="attribute">alias</span>  /folderName/image;  <span class="comment">#这里写绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过nginx的permanent-301绝对跳转实现"><a href="#通过nginx的permanent-301绝对跳转实现" class="headerlink" title="通过nginx的permanent 301绝对跳转实现"></a>通过nginx的permanent 301绝对跳转实现</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /image &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span>   http://dashidan.com/folderName/image/<span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过判断uri实现页面跳转"><a href="#通过判断uri实现页面跳转" class="headerlink" title="通过判断uri实现页面跳转"></a>通过判断uri实现页面跳转</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> ( <span class="variable">$request_uri</span> <span class="regexp">~* ^(/image))</span>&#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/image/(.*)$</span> /folderName/image/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上转自<code>https://dashidan.com/article/webserver/nginx/4.html</code></p><p>具体实例，<a href="https://dashidan.com/article/webserver/nginx/4.html" target="_blank" rel="noopener">请参考这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果希望域名后边跟随的路径指向本地磁盘的其他目录,而不是默认的web目录时,需要设置nginx目录访问重定向&lt;/p&gt;
&lt;p&gt;应用场景:&lt;code&gt;domain.com/image&lt;/code&gt;自动跳转到&lt;code&gt;domain.com/folderName/image&lt;/c
      
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.zhimma.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://blog.zhimma.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-基础方法Basic Steps</title>
    <link href="https://blog.zhimma.com/2019/02/20/Jenkins-%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95Basic-Steps/"/>
    <id>https://blog.zhimma.com/2019/02/20/Jenkins-基础方法Basic-Steps/</id>
    <published>2019-02-20T06:38:25.000Z</published>
    <updated>2019-02-21T12:01:37.486Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>这篇开始来学习一个最基础的pipeline组件，这个也是一个独立的插件，在安装pipeline的时候默认会自动安装，插件的名称是<a href="https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Basic+Steps+Plugin" target="_blank" rel="noopener">Pipeline: Basic Steps</a>,你可以去你自己jenkins环境，插件管理下的installed下面找到这个插件</p><p>下面具体介绍下该插件包含的各个方法    </p><h3 id="deleteDir-方法"><a href="#deleteDir-方法" class="headerlink" title="deleteDir()方法"></a>deleteDir()方法</h3><p>默认递归删除WORKSPACE下的文件和文件夹,这个方法是没有参数，也不需要参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">deleteDir()  <span class="comment">// clean up current work directory</span></span><br><span class="line">sh(<span class="string">"ls -al $&#123;env.WORKSPACE&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/deleteDir.png" alt=""></p><h3 id="dir-方法"><a href="#dir-方法" class="headerlink" title="dir()方法"></a>dir()方法</h3><p>如果使用了dir语句块，这个方法就是改变当前的工作目录</p><p>在dir语句块里执行的其他路径或者相对路径，都是和dir里面设置的文件路径相关，这个和WORKSPACE相对文件路径已经没有关系了。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    println env.WORKSPACE</span><br><span class="line">    dir(<span class="string">"$&#123;env.WORKSPACE&#125;/testdata"</span>)&#123;</span><br><span class="line">    sh <span class="string">"pwd"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/dir.png" alt=""></p><h3 id="echo-和-error-方法"><a href="#echo-和-error-方法" class="headerlink" title="echo() 和 error()方法"></a>echo() 和 error()方法</h3><p>echo就是和groovy中的println没有任何区别,如果看打印的效果。一般来说使用echo就是打印info debug级别的日志输出用</p><p>如果遇到错误，就可以使用error(‘error message’)    ，如果出现执行到error方法，jenkins job会退出并显示失败效果。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"dir"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    echo(<span class="string">"this is echo info"</span>)</span><br><span class="line">    error(<span class="string">"this is error info"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/error.png" alt=""></p><h3 id="fileExists-方法"><a href="#fileExists-方法" class="headerlink" title="fileExists()方法"></a>fileExists()方法</h3><p>这是判断一个文件是否存在，返回值是布尔类型，true就表示文件存在，false表示文件不存在</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">json_file = <span class="string">"$&#123;env.WORKSPACE&#125;/testdata/test_json.json"</span></span><br><span class="line"><span class="keyword">if</span>(fileExists(json_file) == <span class="literal">true</span>) &#123;</span><br><span class="line">echo(<span class="string">"json file is exists"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">error(<span class="string">"here haven't find json file"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/fileExists.png" alt=""></p><h3 id="pwd-方法"><a href="#pwd-方法" class="headerlink" title="pwd()方法"></a>pwd()方法</h3><p>其实这个方法和linux下的shell命令pwd是一样的。由于jenkins支持windows和linux，但是linux是pwd，windows上是dir,所以这个插件就干脆支持一个方法，统称为pwd()</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">sh(<span class="string">"pwd"</span>)</span><br><span class="line">println <span class="string">"==========="</span></span><br><span class="line">println pwd()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/pwd.png" alt=""></p><h3 id="isUnix-方法"><a href="#isUnix-方法" class="headerlink" title="isUnix()方法"></a>isUnix()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(&quot;Demo&quot;) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">if(isUnix() == true) &#123;</span><br><span class="line">echo(&quot;this jenkins job running on a linux-like system&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">error(&quot;the jenkins job running on a windows system&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/isUnix.png" alt=""></p><h3 id="mail指令"><a href="#mail指令" class="headerlink" title="mail指令"></a>mail指令</h3><h4 id="Jenkins服务器上配置smtp服务"><a href="#Jenkins服务器上配置smtp服务" class="headerlink" title="Jenkins服务器上配置smtp服务"></a>Jenkins服务器上配置smtp服务</h4><p><strong>subject</strong></p><p>必填，邮件标题主题，Type: <code>String</code></p><p><strong>body</strong></p><p>必填，邮件正文，Type: <code>String</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pipeline&#123;</span><br><span class="line"></span><br><span class="line">agent any</span><br><span class="line">stages&#123;</span><br><span class="line">stage(<span class="string">"Demo"</span>) &#123;</span><br><span class="line">steps&#123;</span><br><span class="line">    script &#123;</span><br><span class="line">script &#123;</span><br><span class="line">mail <span class="string">to:</span> <span class="string">'admin@163.com'</span>,</span><br><span class="line"><span class="symbol">                    subject:</span> <span class="string">"Running Pipeline: $&#123;currentBuild.fullDisplayName&#125;"</span>,</span><br><span class="line"><span class="symbol">                    body:</span> <span class="string">"Something is wrong with $&#123;env.BUILD_URL&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;这篇开始来学习一个最基础的pipeline组件，这个也是一个独立的插件，在安装pipeline的时候默认会自动安装，插件的名称是&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Pipelin
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-Pipeline语法入门</title>
    <link href="https://blog.zhimma.com/2019/02/18/Jenkins-Pipeline%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.zhimma.com/2019/02/18/Jenkins-Pipeline语法入门/</id>
    <published>2019-02-18T14:28:14.000Z</published>
    <updated>2019-02-19T10:21:32.770Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>流水线最基础的部分是 “step”。基本上, step告诉 Jenkins 要做什么，以及作为声明式(Declarative)和脚本化(Scripted)流水线语法的基本构建块。</p><h2 id="Declarative-Pipeline-声明管道"><a href="#Declarative-Pipeline-声明管道" class="headerlink" title="Declarative Pipeline-声明管道"></a>Declarative Pipeline-声明管道</h2><p>有效的Declarative Pipeline必须包含在一个pipeline块内，例如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    <span class="comment">/* insert Declarative Pipeline here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Declarative Pipeline中有效的基本语句和表达式遵循与Groovy语法相同的规则 ，但有以下例外：</p><ul><li>Pipeline的顶层必须是块(block)，其实就是<code>pipeline { }</code></li><li>没有分号作为语句分隔符。每个声明必须在自己的一行</li><li>块只能包含章节， 指令，步骤<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或赋值语句</li><li>属性引用语句被视为无参数方法调用。所以例如，input被视为input（）</li></ul><blockquote><p>第一点：    就是声明指定的代码块</p><p>第二点：分号写了也是多余的。Groovy代码还可以写分号，Jenkins Pipeline代码就不需要，每行只写一个声明语句块或者调用方法语句</p><p>第三点：只能包含<a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-sections" target="_blank" rel="noopener">Sections</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-directives" target="_blank" rel="noopener">Directives</a>, <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">Steps</a>或者赋值语句</p><p>第四点：没懂，懂了再回来补充</p></blockquote><h3 id="Sections-章节-节段"><a href="#Sections-章节-节段" class="headerlink" title="Sections-章节/节段"></a>Sections-章节/节段</h3><p>Declarative Pipeline 代码中的Sections指的是必须包含一个或者多个指令或者步骤的<strong>代码区域块</strong>。Sections不是一个关键字或者指令，只是一个<strong>逻辑概念</strong>。</p><h3 id="agent指令-代理"><a href="#agent指令-代理" class="headerlink" title="agent指令-代理"></a><a href="https://blog.csdn.net/u011541946/article/details/83278214" target="_blank" rel="noopener">agent指令-代理</a></h3><p>agent部分指定整个Pipeline或特    定阶段将在Jenkins环境中执行的位置，具体取决于该agent 部分的放置位置。该部分必须在pipeline块内的顶层定义 ，但阶段级使用是可选的</p><blockquote><p>简单来说，agent部分主要作用就是告诉Jenkins，选择那台节点机器去执行Pipeline代码；这个指令是必须要有的，也就在你顶层pipeline {…}的下一层，必须要有一个agent{…}</p><p>agent这个指令对应的多个可选参数。</p><p>这里注意一点，在具体某一个stage {…}里面也可以使用agent指令。这种用法不多，一般我们在顶层使用agent，这样，接下来的全部stage都在一个agent机器下执行代码。</p><p>为了支持Pipeline作者可能拥有的各种用例，该agent部分支持几种不同类型的参数。这些参数可以应用于pipeline块的顶层，也可以应用在每个stage指令内。</p></blockquote><h4 id="参数1：any"><a href="#参数1：any" class="headerlink" title="参数1：any"></a>参数1：any</h4><p>作用：在任何可用的代理上执行Pipeline或stage</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种是最简单的，如果你Jenkins平台环境只有一个master，那么这种写法就最省事情</p><h4 id="参数2：none"><a href="#参数2：none" class="headerlink" title="参数2：none"></a>参数2：none</h4><p>作用：当在<code>pipeline</code>块的顶层应用时，将不会为整个Pipeline运行分配全局代理，并且每个<code>stage</code>部分将需要包含其自己的<code>agent</code>部分,就像上面说的在具体某一个stage {…}里面也可以使用agent指令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>)&#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">               label <span class="string">'具体的节点名称'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数3：label"><a href="#参数3：label" class="headerlink" title="参数3：label"></a>参数3：label</h4><p>作用：使用提供的标签在Jenkins环境中可用的代理机器上执行Pipeline或stage内执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">       label <span class="string">'具体一个节点label名称'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="参数4：node"><a href="#参数4：node" class="headerlink" title="参数4：node"></a>参数4：node</h4><p>作用：和上面label功能类似，但是node运行其他选项，例如customWorkspace</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post指令"><a href="#post指令" class="headerlink" title="post指令"></a><a href="https://blog.csdn.net/u011541946/article/details/83278531" target="_blank" rel="noopener">post指令</a></h3><p><code>post</code>部分定义将在Pipeline运行或阶段结束时运行的操作</p><p><code>post</code>部分定义一个或多个<a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#declarative-steps" target="_blank" rel="noopener">steps</a>,这些阶段根Pipeline或stage的完成情况而运行,<code>post</code> 支持以下 <a href="https://jenkins.io/zh/doc/book/pipeline/syntax/#post-conditions" target="_blank" rel="noopener">post-condition</a> 块中的其中之一: <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code>, <code>unstable</code>, 和 <code>aborted</code></p><blockquote><p>简单来说，post可以放在顶层，也就是和agent{…}同级，也可以放在stage里面。一般放顶层的比较多。而且pipeline代码中post代码块不是必须的，使用post的场景基本上执行完一个构建，进行发送消息通知，例如构建失败会发邮件通知</p></blockquote><p>简单示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">        stages &#123;</span><br><span class="line">            stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">          <span class="comment">//写相关post部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="post条件的基本用法"><a href="#post条件的基本用法" class="headerlink" title="post条件的基本用法"></a>post条件的基本用法</h4><p>在post代码块区域，支持多种条件指令，这些指令有always，changed，failure，success，unstable，和aborted。下面分别来介绍这些条件的基本用法。</p><h5 id="条件1：always"><a href="#条件1：always" class="headerlink" title="条件1：always"></a>条件1：always</h5><p>作用：无论Pipeline运行的完成状态如何都会执行这段代码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">//写相关清除/恢复环境等操作代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个always场景，很容易想到的场景就是，事后清理环境。例如测试完了，对数据库进行恢复操作，恢复到测试之前的环境。</p><h5 id="条件2：changed"><a href="#条件2：changed" class="headerlink" title="条件2：changed"></a>条件2：changed</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        changed &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个场景，大部分是写发邮件状态。例如，你最近几次构建都是成功，突然变成不是成功状态，里面就触发发邮件通知。当然，使用changed这个指令没success和failure要频率高</p><h5 id="条件3：failure"><a href="#条件3：failure" class="headerlink" title="条件3：failure"></a>条件3：failure</h5><p>作用：只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能触发运行。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">            label <span class="string">'xxx-agent-机器'</span></span><br><span class="line">            customWorkspace <span class="string">"$&#123;env.JOB_NAME&#125;/$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">            sh <span class="string">"pwd"</span>  <span class="comment">//这个是Linux的执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Post &#123;</span><br><span class="line">        failure &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                <span class="comment">// 例如发邮件代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个failure条件一般来说，百分百会写到Pipeline代码中，内容无非就是发邮件通知，或者发微信群，钉钉机器人，还有国外的slack聊天群组等。</p><h3 id="stages和steps指令"><a href="#stages和steps指令" class="headerlink" title="stages和steps指令"></a>stages和steps指令</h3><ol><li><p><strong>stages</strong>被外层的<code>pipeline { }</code>包裹，内部包含多个<strong>stage</strong></p></li><li><p>每个<strong>stage</strong>代码块内包含多个<strong>steps { }</strong>，一个<strong>stage</strong>下至少有一个<strong>steps { }</strong>，一般也就是一个<strong>steps { }</strong></p></li><li><p>我们可以在一个steps下写调用一个或者几个方法，也就是两三行代码。具体的代码实现，可以放在别的包里面</p></li><li><p>stages下可以包含多个stage, 在一个Declarative Pipeline脚本中，只允许出现一次stages</p><p>以后我们大部分的pipeline代码都在每一个stage里面的steps下,如下示例</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Build"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Build"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Test"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Test"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">"Deploy"</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                println <span class="string">"Deploy"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面println是Groovy的语法，就是一个打印语句。不管以后pipeline代码有多么复杂，都是以这个为基础骨架，例如添加一些try catch语句还有其他的指令。</p></blockquote><h3 id="stage指令"><a href="#stage指令" class="headerlink" title="stage指令"></a>stage指令</h3><p>该stage指令在该stages部分中，应包含步骤部分，可选agent部分或其他特定于阶段的指令。实际上，Pipeline完成的所有实际工作都将包含在一个或多个stage指令中。</p><blockquote><p>stage一定是在stages{…}里面，一个pipeline{…}中至少有一个stages{…}和一个stage{…}.这里多说一句，一个stage{…}中至少有一个steps{…}。stage{…}还有一个特点就是，里面有一个强制的字符串参数，例如下面的”Example”，这个字符串参数就是描述这个stage是干嘛的，这个字符串参数是不支持变量的，只能你自己取名一个描述字段。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="environment指令"><a href="#environment指令" class="headerlink" title="environment指令"></a>environment指令</h3><p><strong>environment</strong>指令定义一个键-值，该键-值对将被定义为所有步骤的环境变量，或者是特定于阶段的步骤， 这取决于 <code>environment</code> 指令在流水线内的位置。</p><p>解释一下什么意思，environment{…}, 大括号里面写一些键值对，也就是定义一些变量并赋值，这些变量就是<strong>环境变量</strong>。环境变量的作用范围，取决你environment{…}所写的位置，你可以写在顶层环境变量，让所有的stage下的step共享这些变量，也可以单独定义在某一个stage下，只能供这个stage去调用变量，其他的stage不能共享这些变量。</p><p>一般来说，我们基本上上定义全局环境变量，如果是局部环境变量，我们直接用def关键字声明就可以，没必要放environment{…}里面</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        boolStatus = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Demo'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(boolStatus == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">// Todo</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="options指令"><a href="#options指令" class="headerlink" title="options指令"></a>options指令</h3><p>该options指令允许在Pipeline本身内配置Pipeline专用选项，Pipeline提供了许多这些选项，例如buildDiscarder，但它们也可能由插件提供，例如 timestamps。</p><p>一个pipeline{…}内只运行出现<strong>一次<code>options{…}</code></strong>, 下面看一个下这个retry的使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    option &#123;</span><br><span class="line">        retry(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">"Demo"</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">//Tode</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的整个pipeline{…}, 如果在<a href="https://www.baidu.com/s?wd=jenkins&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">jenkins</a>上job执行失败，会继续执行，如果再遇到失败，继续执行一次，总共执行三次</p><p>把options{…}放在顶层里，也可以放在具体的某一个stage下，意味这这个stage下所有代码，如果遇到失败，最多执行三次。    </p></blockquote><h3 id="parameters指令"><a href="#parameters指令" class="headerlink" title="parameters指令"></a>parameters指令</h3><p><strong>parameters</strong>是参数的意思，parameters指令提供用户在触发Pipeline时应提供的参数列表，这些用户指定的参数的值通过该params对象可用于Pipeline步骤。</p><p>我们很多人听过<strong>参数化构建(Build with Parameters)</strong>，也可能知道如何在一个jenkins job上，通过UI创建不同的参数，例如有<strong>字符串参数</strong>，<strong>布尔选择参数</strong>，<strong>下拉多选参数</strong>等。这些参数即可以通过UI点击创建，也可以通过pipeline代码去写出来。我们先来看看了解有那些具体参数类型，然后挑选几个，分别用UI和代码方式去实现创建这些参数。</p><h4 id="字符串参数"><a href="#字符串参数" class="headerlink" title="字符串参数"></a>字符串参数</h4><p>就是定义一个字符串参数，用户可以在Jenkins UI上输入字符串，常见使用这个参数的场景有，用户名，收件人邮箱，文件网络路径，主机名称的或者url等</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any   </span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'DEPLOY_ENV'</span>, <span class="string">defaultValue:</span> <span class="string">'staging'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔值参数"><a href="#布尔值参数" class="headerlink" title="布尔值参数"></a>布尔值参数</h4><p>就是定义一个布尔类型参数，用户可以在Jenkins UI上选择是还是否，选择是表示代码会执行这部分，如果选择否，会跳过这部分。一般需要使用布尔值的场景有，执行一些特定集成的脚本或则工作，或者事后清除环境，例如清楚Jenkins的workspace这样的动作。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        booleanParam(<span class="string">name:</span> <span class="string">'DEBUG_BUILD'</span>, <span class="string">defaultValue:</span> <span class="literal">true</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本参数"><a href="#文本参数" class="headerlink" title="文本参数"></a>文本参数</h4><p>文本（text）的参数就是支持写很多行的字符串，这个变量我好像没有使用过，例如想给发送一段欢迎的消息，你可以采用text的参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        text(<span class="string">name:</span> <span class="string">'Welcome_text'</span>, <span class="string">defaultValue:</span> <span class="string">'One\nTwo\nThree\n'</span>, <span class="string">description:</span> <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的\n表示换行，上面写了三行的text</p></blockquote><h4 id="选择参数"><a href="#选择参数" class="headerlink" title="选择参数"></a>选择参数</h4><p>选择（choice）的参数就是支持用户从多个选择项中，选择一个值用来表示这个变量的值。工作中常用的场景，有选择服务器类型，选择版本号等。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        choice(<span class="string">name:</span> <span class="string">'ENV_TYPE'</span>, <span class="string">choices:</span> [<span class="string">'test'</span>, <span class="string">'dev'</span>, <span class="string">'product'</span>], <span class="string">description:</span> <span class="string">'test means test env,….'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件参数"><a href="#文件参数" class="headerlink" title="文件参数"></a>文件参数</h4><p>文件（file）参数就是在Jenkins 参数化构建UI上提供一个文件路径的输入框，Jenkins会自动去你提供的网络路径去查找并下载。一般伴随着还有你需要在Pipleline代码中写解析文件。也有这样场景，这个构建job就是把一个war包部署到服务器上特定位置，你可以使用这个文件参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line"><span class="symbol">        name:</span> <span class="string">'FILE'</span>, <span class="string">description:</span> <span class="string">'Some file to upload'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="密码参数"><a href="#密码参数" class="headerlink" title="密码参数"></a>密码参数</h4><p>密码（password）参数就是在Jenkins 参数化构建UI提供一个密文密码输入框，例如，我需要在一些linux机器上做自动化操作，需要提供机器的用户名和密码，由于密码涉及安全问题，一般都采用暗文显示，这个时候你就不能用string类型参数，就需要使用password参数类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        password(<span class="string">name:</span> <span class="string">'PASSWORD'</span>, <span class="string">defaultValue:</span> <span class="string">'SECRET'</span>, <span class="string">description:</span> <span class="string">'A secret password'</span>)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="web-ui方式"><a href="#web-ui方式" class="headerlink" title="web ui方式"></a>web ui方式</h4><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/paramsFlow.gif" alt=""></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                println <span class="string">"stringValue = $&#123;stringValue&#125;"</span></span><br><span class="line">                println <span class="string">"passwordValue = $&#123;passwordValue&#125;"</span></span><br><span class="line">                println <span class="string">"boolValue = $&#123;boolValue&#125;"</span></span><br><span class="line">                println <span class="string">"choseValue = $&#123;choseValue&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="triggers指令"><a href="#triggers指令" class="headerlink" title="triggers指令"></a>triggers指令</h3><ol><li>该triggers指令定义了Pipeline应重新触发的自动化方式。对于与源代码集成的Pipeline，如GitHub或BitBucket，triggers可能不需要基于webhook的集成可能已经存在</li><li>目前有三个可用的触发器是cron和pollSCM 和 upstream    </li><li>在一个pipeline{…}代码中，只运行出现一次triggers{…},而且这个指令不是必须存在的。</li><li>triggers是触发器的意思，所以这块是设置什么条件下触发pipeline代码执行，以及触发的频率</li></ol><h4 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h4><p>接受一个cron风格的字符串来定义Pipeline应重新触发的常规间隔，例如： triggers { cron(‘H 4/* 0 0 1-5’) }</p><p>####pollSCM</p><p> 接受一个cron风格的字符串来定义Jenkins应该检查新的源更改的常规间隔。如果存在新的更改，则Pipeline将被重新触发。例如：triggers { pollSCM(‘H 4/* 0 0 1-5’) }</p><h4 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h4><p>接受逗号分隔的作业字符串和阈值。 当字符串中的任何作业以最小阈值结束时，将重新触发pipeline。例如：triggers { upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p><p>举例一个可能利用scm的场景，如果一个公司做到了很好的代码覆盖测试，一般都会，如果监控到有人提交代码，就会自动化触发启动相关的单元测试。这个场景就是适合在pipeline代码里使用triggers指令，下面代码举例一个pollSCM的基本使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        pollSCM (‘H H(<span class="number">9</span><span class="number">-16</span>)/<span class="number">2</span> * * <span class="number">1</span><span class="number">-5</span>)’)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释下“H H(9-16)/2 <em> </em> 1-5)”的含义，这个你可以在上面截图这个页面点击右侧这个问号，出来具体含义。第一步，先根据空格，把字符串切割成5段</p></blockquote><p>所以，H H(9-16)/2 <em> </em> 1-5) 的含义就是：</p><blockquote><p>第一部分“H” 表示hash，记住不是表示hour，是一个散列值，含义就是在一个小时之内，会执行一次，但是这次是一个散列值，而且不会并发执行。</p><p>第二部分“H(9-16)/2”，表示白天在早上9点到下午5点，每间隔2小时执行一次。</p><p>第三部分“*“，每天执行</p><p>第四部分“*“表示每月执行</p><p>第五部分“1-5“ 表示周一到周五执行</p><p>所以上面这个表达式“H H(9-16)/2 <em> </em> 1-5) “的含义就是，在每个月的周一到周五的白天，从早上9点到下午5点，每间隔两个小时去触发一次自动化构建。 这个就比较适合，我们每天上班，间隔两个小时去跑一次单元自动化测试。间隔时间长短，取决服务器压力和业务具体场景</p></blockquote><h3 id="input指令"><a href="#input指令" class="headerlink" title="input指令"></a>input指令</h3><p>该input指令允许在一个stage{…}显示提示输入等待。在inpt{…}写一些条件，然后用户触发构建这个job，但是这个时候没有接收到有效的input, job会一直在等待中；</p><p>下面解释input{…}里面支持写那些option。</p><h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>必选，这个message会在用户提交构建的页面显示，提示用户提交相关的input条件</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>可选，可以作为这个input的标记符，默认的标记符是这个stage的名称</p><h4 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h4><p>可选， 主要是在ok按钮上显示一些文本，在input表单里</p><h4 id="submitter"><a href="#submitter" class="headerlink" title="submitter"></a>submitter</h4><p>可选，里面可以写多个用户名称或者组名称，用逗号隔开。意思就是，只有这写名称的对应用户登陆jenkins，才能提交这个input动作，如果不写，默认是任何人都可以提交input。</p><h4 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h4><p>可选，我们前面学的parameters没有区别，就是定义一些参数的地方    </p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/inputFlow.gif" alt=""></p><p>代码示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage (<span class="string">'input-test'</span>) &#123;</span><br><span class="line">            input &#123;</span><br><span class="line">                message <span class="string">"是否继续执发布操作?"</span></span><br><span class="line">                ok <span class="string">"是的,继续执行"</span></span><br><span class="line">                <span class="comment">// 用户,好像设置了没什么用</span></span><br><span class="line">                submitter <span class="string">"admin"</span></span><br><span class="line">                parameters &#123;</span><br><span class="line">                    string(<span class="string">name:</span> <span class="string">'NAME'</span>, <span class="string">defaultValue:</span> <span class="string">'zhimma'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello, $&#123;NAME&#125;, nice to meet you."</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when指令"><a href="#when指令" class="headerlink" title="when指令"></a>when指令</h3><p><strong>when</strong>指令允许流水线根据给定的条件决定是否应该执行阶段</p><p> <strong>when</strong>指令必须包含至少一个条件。</p><p><strong>when</strong> 指令包含多个条件, 所有的子条件必须返回True，阶段才能执行</p><p>下面详细解释下<strong>when</strong>可以使用的内置条件</p><h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h4><p>当正在构建的分支与模式给定的分支匹配时，执行这个阶段;例如：<code>when { branch &#39;master&#39; }</code>。请注意，这仅适用于多分支Pipeline。</p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>当指定的环境变量是给定的值时，执行这个步骤, 例如: <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></p><h4 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h4><p>当指定的Groovy表达式评估为true时，执行这个阶段, 例如: <code>when { expression { return params.DEBUG_BUILD } }</code></p><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>当嵌套条件是错误时，执行这个阶段,必须包含一个条件，例如: <code>when { not { branch &#39;master&#39; } }</code></p><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p>当所有的嵌套条件都正确时，执行这个阶段,必须包含至少一个条件，例如: <code>when { allOf { branch &#39;master&#39;; environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; } }</code></p><h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>当至少有一个嵌套条件为真时，执行这个阶段,必须包含至少一个条件，例如: <code>when { anyOf { branch &#39;master&#39;; branch &#39;staging&#39; } }</code></p><h4 id="在进入-stage的-agent前测试执行when"><a href="#在进入-stage的-agent前测试执行when" class="headerlink" title="在进入 stage的 agent前测试执行when"></a>在进入 <code>stage</code>的 <code>agent</code>前测试执行<code>when</code></h4><p>默认情况下, 如果定义了某个阶段的agent，在进入该<code>stage</code>的<code>agent</code>后该 <code>stage</code>的<code>when</code> 条件将会被执行。但是, 可以通过在 <code>when</code>块中指定<code>beforeAgent</code> 选项来更改此选项。如果<code>beforeAgent</code> 被设置为 <code>true</code>, 那么就会首先对<code>when</code>条件进行评估 , 并且只有在<code>when</code>条件验证为真时才会进入<code>agent</code> </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        quick_test = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script &#123;</span><br><span class="line">                    echo <span class="string">'Hello World'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Example Deploy'</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                expression &#123; </span><br><span class="line">                   <span class="keyword">return</span>  (quick_test == <span class="string">"true"</span>)  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://testerhome.com/topics/9977" target="_blank" rel="noopener">https://testerhome.com/topics/9977</a></p><p><a href="https://testerhome.com/topics/17251" target="_blank" rel="noopener">https://testerhome.com/topics/17251</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;流水线最基础的部分是 “step”。基本上, step告诉 Jenkins 要做什么，以及作为声明式(Declarative)和脚本化(Scripted)流水线语法的基本构建块。&lt;/p&gt;
&lt;h2 id=&quot;Declarative-Pipeline-声
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins的Pipeline发布代码至远程服务器</title>
    <link href="https://blog.zhimma.com/2019/02/16/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84Pipeline%E5%8F%91%E5%B8%83%E4%BB%A3%E7%A0%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://blog.zhimma.com/2019/02/16/使用Jenkins的Pipeline发布代码至远程服务器/</id>
    <published>2019-02-16T14:07:31.000Z</published>
    <updated>2019-02-19T01:39:44.080Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们软件开发流程大概是下面所示：</p><p>本地开发-&gt;本地自测-&gt;提交代码-&gt;编译发布-&gt;测试人员测试-&gt;提交至生产</p><p>在发布阶段，</p><ol><li>有的项目是采用版本控制工具在Linux服务器上拉取对应分支的最新代码</li><li>有的是在本地对比Git版本的差异，生成差异的文件，打包上传至服务器，进行覆盖原来的代码文件完成发布</li></ol><p>上面2种方法是我工作中遇到的，下面我们来学习一种新的发布方式：<strong>Jenkins</strong></p><blockquote><p><strong>Jenkins可以帮你在写完代码后，一键完成开发过程中的一系列工作</strong></p></blockquote><p>特别是在开发阶段，配合<strong>WebHook</strong>可以非常省心的完成代码发布工作，开发者只需要提交代码，就会触发Jenkins发布任务的执行，从而将最新代码部署到服务器上</p><h2 id="什么是Jenkins？"><a href="#什么是Jenkins？" class="headerlink" title="什么是Jenkins？"></a>什么是Jenkins？</h2><p><strong>Jenkins</strong>是一个Java开放的开源程序，所以，需要提前安装Java JDK环境，能支持安装到windows,mac,linux平台，主要是一个管理工具</p><h2 id="为什么要使用Jenkins"><a href="#为什么要使用Jenkins" class="headerlink" title="为什么要使用Jenkins?"></a>为什么要使用Jenkins?</h2><p>我们用它，主要是项目上的持续集成和持续交付。持续集成对应英文（Continuous Integration），有时候简称CI，持续交付对应英文（Continuous Delivery），简称CD，以后，听到了CI和CD，就明白了什么意思。下面这张图，是Jenkins在实际项目运用上的一个经典的流程图</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/jenkinsFlow.png" alt=""></p><p>##安装Jenkins</p><p>安装的方式很多，我这里学习Jenkins采用的是Docker创建容器的方式运行</p><h3 id="下载Jenkins"><a href="#下载Jenkins" class="headerlink" title="下载Jenkins"></a>下载Jenkins</h3><p><code>docker pull jenkins</code></p><p>下载完成，查看下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker image ls</span><br><span class="line">REPOSITORY                                 TAG                 IMAGE ID     </span><br><span class="line">jenkins/jenkins                            latest              9b74eda1c268</span><br></pre></td></tr></table></figure><h3 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h3><p>这个目录根据个人需求，可以进行重新指定，我指定的是：<code>/Users/zhimma/jenkins</code></p><p><code>mkdir /Users/zhimma/jenkins</code></p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><code>docker run -d -p 49001:8080 -v $PWD/jenkins:/var/jenkins_home -t jenkins/jenkins</code></p><blockquote><p>我映射了容器的端口8080到主机上的端口49001， 第一个数字代表主机上的端口，而最后一个代表容器的端口</p></blockquote><p>运行后，Docker会帮我们创建一个Jenkins的运行环境的容器，使用<code>docker ps</code> 查看容器启动情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  ~  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                NAMES</span><br><span class="line">782c2fb5ef74        jenkins/jenkins     &quot;/sbin/tini -- /usr/…&quot;   3 days ago          Up 3 days           50000/tcp, 0.0.0.0:49001-&gt;8080/tcp   trusting_burnell</span><br></pre></td></tr></table></figure><p>到这，我们的Jenkins环境搭建完成，下面我们做一些初始化工作</p><h3 id="初始化Jenkins"><a href="#初始化Jenkins" class="headerlink" title="初始化Jenkins"></a>初始化Jenkins</h3><h4 id="解锁Jenkins"><a href="#解锁Jenkins" class="headerlink" title="解锁Jenkins"></a>解锁Jenkins</h4><p>在浏览器中输入<code>localhost:49001</code>，进入web页面，第一次需要先解锁Jenkins</p><p>进入<code>/Users/zhimma/jenkins/secrets</code>目录，制<code>initialAdminPassword</code>文件的内容就是首次解锁的密码</p><h4 id="安装推荐插件"><a href="#安装推荐插件" class="headerlink" title="安装推荐插件"></a>安装推荐插件</h4><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/init.gif" alt="初始化"></p><h4 id="设置管理员"><a href="#设置管理员" class="headerlink" title="设置管理员"></a>设置管理员</h4><h3 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h3><p>我们目前使用GitLab管理代码，所以我们先安装下面几个插件</p><ul><li>GitLab Plugin</li><li>Gitlab Hook Plugin</li><li>AnsiColor（可选）这个插件可以让Jenkins的控制台输出的log带有颜色（就和linux控制台那样）</li></ul><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/installPlugin.gif" alt="安装插件"></p><p>###配置SSH</p><p>本机生成SSH：<code>ssh-keygen -t rsa -C &quot;Your email&quot;</code>，最终生成id_rsa和id_rsa.pub(公钥)</p><p>Gitlab上添加公钥：复制id_rsa.pub里面的公钥添加到Gitlab</p><p>Jenkins上配置密钥到SSH：复制id_rsa里面的公钥添加到Jenkins（private key选项）</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/ssh.gif" alt=""></p><p>##开始Pipeline</p><p>在Jenkins中，把每一段管道比作是不同的Job，我们提到Jenkins的工作流程，build-deploy-test-release，每个流程之间我们都可以用Pipeline来连接，大致如下效果图。</p><p><img src="http://zhimma.oss-cn-beijing.aliyuncs.com/flow.png" alt=""></p><blockquote><p>SCM:软件配置管理工具</p></blockquote><p>###创建Pipeline风格的项目</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/createProject.gif" alt=""></p><p>###实现Pipeline-Web UI方式</p><p>如下图所示：</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/webuiway.gif" alt=""></p><p>###实现Pipeline-Jenkinsfile方式</p><p>上面通过Web UI方式只适用于非常简单的任务，而大型复杂的任务最好采用<code>Jenkinsfile</code>方式并纳入SCM管理。 这次我选择从SCM中的<code>Jenkinsfile</code>来定义管道。</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/scm.gif" alt=""></p><p>我们需要在自己的项目根目录创建<code>Jenkinsfile</code>文件，在里面编写具体的发布流程代码。</p><h3 id="使用Jenkinsfile"><a href="#使用Jenkinsfile" class="headerlink" title="使用Jenkinsfile"></a>使用Jenkinsfile</h3><p>接下来详细介绍一下怎样编写<code>Jenkinsfile</code>来完成各种复杂的任务。</p><p>Pipeline支持两种形式，一种是<code>Declarative</code>管道，一个是<code>Scripted</code>管道。</p><p>一个<code>Jenkinsfile</code>就是一个文本文件，里面定义了<code>Jenkins Pipeline</code>。 将这个文本文件放到项目的根目录下面，纳入版本系统。</p><p>####Declarative风格类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个Declarative类型的Pipeline，目前实际开发基本采用这种方式；</p><ul><li>第一行是小写的pipeline，然后一对大括{}，大括号里面就是代码块，用来和别的代码块隔离出来，pipeline是一个语法标识符,也叫关键字，如果是Declarative类型，一定是pipeline {}这样起头的；如果是脚本文件，pipeline不要求一定是第一行代码。也就是说pipeline前面可以有其他代码，例如导入语句，和其他功能代码。pipeline是一个执行pipeline代码的入口，jenkins可以根据这个入门开始执行里面不同stage</li><li>第二行agent any，agent是一个语法关键字，any是一个option类型，agent是代理的意思，这个和选择用jenkins平台上那一台机器去执行任务构建有关</li><li>第三行stages{}, stages是多个stage的意思，也就是说一个stages可以包含多个stage，从上面代码结果你也可以看出来。上面写了三个stage，根据你任务需要，你可以写十多个都可以</li><li>第四行stage(‘Build’) {}, 这个就是具体定义一个stage,一般一个stage就是指完成一个业务场景。<strong>Build</strong>是认为给这个任务取一个名字。</li><li>第五行steps{},字面意思就是很多个步骤的意思。这里提一下，看到了steps，当然还有step这个指令。一般来说，一个steps{}里面就写几行代码，或者一个try catch语句。</li></ul><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><p><code>post</code> section 定义了管道执行结束后要进行的操作。支持在里面定义很多<code>Conditions</code>块： <code>always</code>, <code>changed</code>, <code>failure</code>, <code>success</code> 和 <code>unstable</code>。 这些条件块会根据不同的返回结果来执行不同的逻辑。</p><ul><li>always：不管返回什么状态都会执行</li><li>changed：如果当前管道返回值和上一次已经完成的管道返回值不同时候执行</li><li>failure：当前管道返回状态值为”failed”时候执行，在Web UI界面上面是红色的标志</li><li>success：当前管道返回状态值为”success”时候执行，在Web UI界面上面是绿色的标志</li><li>unstable：当前管道返回状态值为”unstable”时候执行，通常因为测试失败，代码不合法引起的。在Web UI界面上面是黄色的标志</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123; ①</span><br><span class="line">        always &#123; ②</span><br><span class="line">            echo <span class="string">'I will always say Hello again!'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h5><p>由一个或多个<code>stage</code>指令组成，stages块也是核心逻辑的部分。 我们建议对于每个独立的交付部分（比如<code>Build</code>,<code>Test</code>,<code>Deploy</code>）都应该至少定义一个<code>stage</code>指令。比如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123; ①</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            echo <span class="string">'Hello World'</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h5><p>在<code>stage</code>中定义一系列的<code>step</code>来执行命令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123; ①</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h5><p><code>agent</code>指令指定整个管道或某个特定的<code>stage</code>的执行环境。它的参数可用使用：</p><ol><li>any - 任意一个可用的agent</li><li>none - 如果放在pipeline顶层，那么每一个<code>stage</code>都需要定义自己的<code>agent</code>指令</li><li>label - 在jenkins环境中指定标签的agent上面执行，比如<code>agent { label &#39;my-defined-label&#39; }</code></li><li>node - <code>agent { node { label &#39;labelName&#39; } }</code> 和 label一样，但是可用定义更多可选项</li><li>docker - 指定在docker容器中运行</li><li>dockerfile - 使用源码根目录下面的<code>Dockerfile</code>构建容器来运行</li></ol><h5 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h5><p><code>environment</code>定义键值对的环境变量</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123; ①</span><br><span class="line">        CC = <span class="string">'clang'</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            environment &#123; ②</span><br><span class="line">                AN_ACCESS_KEY = credentials(<span class="string">'my-prefined-secret-text'</span>) ③</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'printenv'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="options"><a href="#options" class="headerlink" title="options"></a>options</h5><p>还能定义一些管道特定的选项，介绍几个常用的：</p><ul><li>skipDefaultCheckout - 在<code>agent</code>指令中忽略源码<code>checkout</code>这一步骤。</li><li>timeout - 超时设置<code>options { timeout(time: 1, unit: &#39;HOURS&#39;) }</code></li><li>retry - 直到成功的重试次数<code>options { retry(3) }</code></li><li>timestamps - 控制台输出前面加时间戳<code>options { timestamps() }</code></li></ul><h5 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h5><p>参数指令，触发这个管道需要用户指定的参数，然后在<code>step</code>中通过<code>params</code>对象访问这些参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        string(<span class="string">name:</span> <span class="string">'PERSON'</span>, <span class="string">defaultValue:</span> <span class="string">'Mr Jenkins'</span>, <span class="string">description:</span> <span class="string">'Who should I say hello to?'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">"Hello $&#123;params.PERSON&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="triggers"><a href="#triggers" class="headerlink" title="triggers"></a>triggers</h5><p>触发器指令定义了这个管道何时该执行，一般我们会将管道和GitHub、GitLab、BitBucket关联， 然后使用它们的webhooks来触发，就不需要这个指令了。如果不适用<code>webhooks</code>，就可以定义两种<code>cron</code>和<code>pollSCM</code></p><ul><li>cron - linux的cron格式<code>triggers { cron(&#39;H 4/* 0 0 1-5&#39;) }</code></li><li>pollSCM - jenkins的<code>poll scm</code>语法，比如<code>triggers { pollSCM(&#39;H 4/* 0 0 1-5&#39;) }</code></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        cron(<span class="string">'H 4/* 0 0 1-5'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h5><p><code>stage</code>指令定义在<code>stages</code>块中，里面必须至少包含一个<code>steps</code>指令，一个可选的<code>agent</code>指令，以及其他stage相关指令。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h5><p>定义自动安装并自动放入<code>PATH</code>里面的工具集合</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">'apache-maven-3.0.1'</span> ①</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'mvn --version'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：① 工具名称必须预先在Jenkins中配置好了 → Global Tool Configuration.</p><h5 id="内置条件"><a href="#内置条件" class="headerlink" title="内置条件"></a>内置条件</h5><ul><li>branch - 分支匹配才执行 <code>when { branch &#39;master&#39; }</code></li><li>environment - 环境变量匹配才执行 <code>when { environment name: &#39;DEPLOY_TO&#39;, value: &#39;production&#39; }</code></li><li>expression - groovy表达式为真才执行 <code>expression { return params.DEBUG_BUILD } }</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Declarative //</span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;Example Build&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &apos;Hello World&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&apos;Example Deploy&apos;) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch &apos;production&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &apos;Deploying&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h5><p>这里就是实实在在的执行步骤了，每个步骤step都具体干些什么东西， 前面的<code>Sections</code>、<code>Directives</code>算控制逻辑和环境准备，这里的就是真实执行步骤。</p><p>这部分内容最多不可能全部讲完，<a href="https://jenkins.io/doc/pipeline/steps/" target="_blank" rel="noopener">官方Step指南</a> 包含所有的东西。</p><p><code>Declared Pipeline</code>和<code>Scripted Pipeline</code>都能使用这些step，除了下面这个特殊的<code>script</code>。</p><p>一个特殊的step就是<code>script</code>，它可以让你在声明管道中执行脚本，使用groovy语法，这个非常有用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative //</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Example'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Hello World'</span></span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="keyword">def</span> browsers = [<span class="string">'chrome'</span>, <span class="string">'firefox'</span>]</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; browsers.size(); ++i) &#123;</span><br><span class="line">                        echo <span class="string">"Testing the $&#123;browsers[i]&#125; browser"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                script &#123;</span><br><span class="line">                    <span class="comment">// 一个优雅的退出pipeline的方法，这里可执行任意逻辑</span></span><br><span class="line">                    <span class="keyword">if</span>( $VALUE1 == $VALUE2 ) &#123;</span><br><span class="line">                       currentBuild.result = <span class="string">'SUCCESS'</span></span><br><span class="line">                       <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Scripted风格类型"><a href="#Scripted风格类型" class="headerlink" title="Scripted风格类型"></a>Scripted风格类型</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node &#123;  </span><br><span class="line">    stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 这个代码，有两点和上面不同。</p><p>第一个是Scripted模式是node{}开头，并没有pipeline{}直观。</p><p>第二个要指出的是，scripted模式下没有stages这个关键字或者指令，只有stage。上面其实可以node(‘Node name’) {}来开头，Node name就是从节点或master节点的名称。</p></blockquote><p><code>Scripted Pipeline</code>没那么多东西，就是定义一个<code>node</code>， 里面多个<code>stage</code>，里面就是使用Groovy语法执行各个<code>step</code>了，非常简单和清晰，也非常灵活。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Jenkins定了很多内置的环境变量，可在文档<code>localhost:49001/pipeline-syntax/globals#env</code>找到， 通过<code>env</code>直接使用它们：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 测试环境变量</span></span><br><span class="line">            echo <span class="string">"Running $&#123;env.BUILD_ID&#125; on $&#123;env.JENKINS_URL&#125;"</span></span><br><span class="line">                echo <span class="string">'Building..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Testing..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">'Deploying..'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目根目录修改Jenkinsfile后，提交到服务器，点击立即构建，查看<code>Console Output</code>输出系统的环境变量</p><p><img src="https://zhimma.oss-cn-beijing.aliyuncs.com/envParams.png" alt=""></p><h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><p><a href="https://blog.csdn.net/u011541946/article/details/83152494" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/details/83152494</a></p><p><a href="https://blog.csdn.net/u011541946/article/category/8223796/2" target="_blank" rel="noopener">https://blog.csdn.net/u011541946/article/category/8223796/2</a>?</p><p><a href="https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html" target="_blank" rel="noopener">https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们软件开发流程大概是下面所示：&lt;/p&gt;
&lt;p&gt;本地开发-&amp;gt;本地自测-&amp;gt;提交代码-&amp;gt;编译发布-&amp;gt;测试人员测试-&amp;gt;提交至生产&lt;/p&gt;
&lt;p&gt;在发布阶段，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有的项目是采用版本控制工具在Linux服务器上拉取对应分支的最
      
    
    </summary>
    
      <category term="容器化服务" scheme="https://blog.zhimma.com/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="https://blog.zhimma.com/tags/Jenkins/"/>
    
  </entry>
  
</feed>
